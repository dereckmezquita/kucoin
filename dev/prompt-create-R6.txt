Ok but that seems like a lot. I think instead we can break these down into smaller classes. That way it's more managable. I'm going to use class composition at the end anyway so we will have one super class. 

So to be clear at the moment just asses everything and categorise/break things down modularise give an idea of how to architect this.

Take a look at what we have and you decide how to pull these together into a number of different classes.

Ok these are my current modules:

(base) work@Derecks-MacBook-Air kucoin % tree R
R
├── KucoinAccountAndFunding.R
├── KucoinDeposit.R
├── KucoinSpotMarketData.R
├── KucoinSubAccount.R
├── helpers_api.R
├── impl_account_account_and_funding.R
├── impl_account_deposit.R
├── impl_account_sub_account.R
├── impl_spottrading_market_data.R
├── impl_spottrading_market_data_get_klines.R
├── impl_spottrading_orders_add_order.R
├── impl_spottrading_orders_cancel_order.R
├── impl_spottrading_orders_get_order_by.R
├── impl_spottrading_orders_get_trade_history.R
├── impl_spottrading_orders_get_x.R
├── impl_spottrading_orders_oco.R
├── impl_spottrading_orders_stop.R
├── utils.R
├── utils_time_convert_kucoin.R
└── zzz.R

1 directory, 20 files
(base) work@Derecks-MacBook-Air kucoin % 

These are all my current functions and helpers etc:

export(add_deposit_address_v3_impl)
export(add_oco_order_impl)
export(add_order_batch_impl)
export(add_order_impl)
export(add_order_test_impl)
export(add_stop_order_impl)
export(add_subaccount_impl)
export(auto_paginate)
export(auto_paginate_old)
export(build_headers)
export(build_query)
export(cancel_all_orders_by_symbol_impl)
export(cancel_all_orders_impl)
export(cancel_oco_order_batch_impl)
export(cancel_oco_order_by_client_oid_impl)
export(cancel_oco_order_by_order_id_impl)
export(cancel_order_by_client_oid_impl)
export(cancel_order_by_order_id_impl)
export(cancel_partial_order_impl)
export(cancel_stop_order_batch_impl)
export(cancel_stop_order_by_client_oid_impl)
export(cancel_stop_order_by_order_id_impl)
export(check_allowed_frequency_s)
export(check_allowed_frequency_str)
export(fetch_klines_segment)
export(freq_to_second_map)
export(frequency_to_seconds)
export(get_24hr_stats_impl)
export(get_account_summary_info_impl)
export(get_all_currencies_impl)
export(get_all_symbols_impl)
export(get_all_tickers_impl)
export(get_announcements_impl)
export(get_api_keys)
export(get_apikey_info_impl)
export(get_base_url)
export(get_closed_orders_impl)
export(get_cross_margin_account_impl)
export(get_currency_impl)
export(get_deposit_addresses_v3_impl)
export(get_deposit_history_impl)
export(get_full_orderbook_impl)
export(get_isolated_margin_account_impl)
export(get_klines_impl)
export(get_market_list_impl)
export(get_oco_order_by_client_oid_impl)
export(get_oco_order_by_order_id_impl)
export(get_oco_order_detail_by_order_id_impl)
export(get_oco_order_list_impl)
export(get_open_orders_impl)
export(get_order_by_client_oid_impl)
export(get_order_by_order_id_impl)
export(get_part_orderbook_impl)
export(get_server_time)
export(get_spot_account_detail_impl)
export(get_spot_account_list_impl)
export(get_spot_account_type_impl)
export(get_spot_ledger_impl)
export(get_stop_order_by_client_oid_impl)
export(get_stop_order_by_order_id_impl)
export(get_stop_order_list_impl)
export(get_subaccount)
export(get_subaccount_detail_balance_impl)
export(get_subaccount_list_summary_impl)
export(get_subaccount_spot_v2_impl)
export(get_symbol_impl)
export(get_symbols_with_open_order_impl)
export(get_ticker_impl)
export(get_trade_history_impl)
export(process_kucoin_response)
export(split_time_range_by_candles)
export(time_convert_from_kucoin)
export(time_convert_to_kucoin)
export(verify_symbol)


Here is an example of an R6 class; here is an example just for inspiration of you course you can make it better to make an R6 class:

# File: ./R/KucoinDeposit.R

# box::use(
#     ./impl_account_deposit[
#         add_deposit_address_v3_impl,
#         get_deposit_addresses_v3_impl,
#         get_deposit_history_impl
#     ],
#     ./utils[get_api_keys, get_base_url]
# )

#' KucoinDeposit Class for KuCoin Deposit Endpoints
#'
#' The `KucoinDeposit` class provides an asynchronous interface for managing deposits on KuCoin.
#' It leverages the `coro` package for non-blocking HTTP requests, returning promises that typically resolve to `data.table`
#' objects. This class supports creating new deposit addresses, retrieving existing deposit addresses, and fetching deposit history.
#'
#' ### Workflow Overview
#' Not applicable (class definition overview).
#'
#' ### API Endpoint
#' Not applicable (class-level documentation; see individual methods).
#'
#' ### Usage
#' Utilised by users to manage KuCoin deposits programmatically. The class is initialised with API credentials,
#' automatically loaded via `get_api_keys()` if not provided, and a base URL from `get_base_url()`. For detailed endpoint
#' information and response schemas, refer to the official [KuCoin API Documentation](https://www.kucoin.com/docs-new).
#'
#' ### Official Documentation
#' [KuCoin API Documentation](https://www.kucoin.com/docs-new)
#'
#' @section Methods:
#' - **initialize(keys, base_url):** Initialises the object with API credentials and the base URL.
#' - **add_deposit_address(currency, chain, to, amount):** Creates a new deposit address for a specified currency.
#' - **get_deposit_addresses(currency, amount, chain):** Retrieves all deposit addresses for a specified currency.
#' - **get_deposit_history(currency, status, startAt, endAt, page_size, max_pages):** Retrieves the deposit history for a specified currency.
#'
#' @return Not applicable (class definition; see individual methods for return values).
#'
#' @examples
#' \dontrun{
#' # Comprehensive example demonstrating all methods
#' main_async <- coro::async(function() {
#'   # Initialise the class
#'   deposit <- KucoinDeposit$new()
#'
#'   # Add a new deposit address
#'   new_address <- await(deposit$add_deposit_address(
#'     currency = "USDT",
#'     chain = "trx",
#'     to = "trade"
#'   ))
#'   print("New Deposit Address:")
#'   print(new_address)
#'
#'   # Get all deposit addresses for a currency
#'   addresses <- await(deposit$get_deposit_addresses(currency = "USDT"))
#'   print("Deposit Addresses:")
#'   print(addresses)
#'
#'   # Get deposit history
#'   history <- await(deposit$get_deposit_history(
#'     currency = "USDT",
#'     status = "SUCCESS",
#'     startAt = 1728663338000,
#'     endAt = 1728692138000,
#'     page_size = 50,
#'     max_pages = 2
#'   ))
#'   print("Deposit History:")
#'   print(history)
#' })
#' main_async()
#' while (!later::loop_empty()) later::run_now()
#' }
#'
#' @importFrom R6 R6Class
#' @export
KucoinDeposit <- R6::R6Class(
    "KucoinDeposit",
    public = list(
        #' @field keys List containing KuCoin API keys (`api_key`, `api_secret`, `api_passphrase`, `key_version`).
        keys = NULL,
        #' @field base_url Character string representing the base URL for KuCoin API endpoints.
        base_url = NULL,
        
        #' Initialise a New KucoinDeposit Object
        #'
        #' ### Description
        #' Initialises a `KucoinDeposit` object with API credentials and a base URL for managing KuCoin deposits asynchronously.
        #' If not provided, credentials are sourced from `get_api_keys()` and the base URL from `get_base_url()`.
        #'
        #' ### Workflow Overview
        #' 1. **Credential Assignment**: Sets `self$keys` to the provided or default API keys.
        #' 2. **URL Assignment**: Sets `self$base_url` to the provided or default base URL.
        #'
        #' ### API Endpoint
        #' Not applicable (initialisation method).
        #'
        #' ### Usage
        #' Utilised to create an instance of the class with authentication details for deposit management.
        #'
        #' ### Official Documentation
        #' [KuCoin API Authentication](https://www.kucoin.com/docs-new/rest/introduction)
        #'
        #' @param keys List containing API configuration parameters from `get_api_keys()`, including:
        #'   - `api_key`: Character string; your KuCoin API key.
        #'   - `api_secret`: Character string; your KuCoin API secret.
        #'   - `api_passphrase`: Character string; your KuCoin API passphrase.
        #'   - `key_version`: Character string; API key version (e.g., `"2"`).
        #'   Defaults to `get_api_keys()`.
        #' @param base_url Character string representing the base URL for the API. Defaults to `get_base_url()`.
        #'
        #' @return A new instance of the `KucoinDeposit` class.
        initialize = function(keys = get_api_keys(), base_url = get_base_url()) {
            self$keys <- keys
            self$base_url <- base_url
        },
        
        #' Add Deposit Address
        #'
        #' ### Description
        #' Creates a new deposit address for a specified currency on KuCoin asynchronously by sending a POST request to the `/api/v3/deposit-address/create` endpoint.
        #' This method constructs a JSON request body, generates authentication headers, and processes the response into a `data.table`.
        #' It calls `add_deposit_address_v3_impl`.
        #'
        #' ### Workflow Overview
        #' 1. **URL Construction**: Combines the base URL with `/api/v3/deposit-address/create`.
        #' 2. **Request Body Preparation**: Builds a list with `currency`, `chain`, `to`, and optional `amount`, converted to JSON.
        #' 3. **Header Preparation**: Generates authentication headers asynchronously using `build_headers()`.
        #' 4. **API Request**: Sends a POST request with a 3-second timeout via `httr::POST()`.
        #' 5. **Response Processing**: Validates the response and converts the `"data"` field into a `data.table`.
        #'
        #' ### API Endpoint
        #' `POST https://api.kucoin.com/api/v3/deposit-address/create`
        #'
        #' ### Usage
        #' Utilised by users to create deposit addresses for various currencies, enabling deposits to the specified account type.
        #'
        #' ### Official Documentation
        #' [KuCoin Add Deposit Address (V3)](https://www.kucoin.com/docs-new/rest/account-info/deposit/add-deposit-address-v3)
        #'
        #' @param currency Character string; the currency for which to create the deposit address (e.g., "BTC", "ETH", "USDT").
        #' @param chain Character string (optional); the chain identifier (e.g., "eth", "bech32", "btc").
        #' @param to Character string (optional); the account type to deposit to ("main" or "trade").
        #' @param amount Character string (optional); the deposit amount, only used for Lightning Network invoices.
        #'
        #' @return Promise resolving to a `data.table` containing:
        #'   - `address` (character): The deposit address.
        #'   - `memo` (character): Address remark (may be empty).
        #'   - `chainId` (character): The chain identifier.
        #'   - `to` (character): The account type.
        #'   - `expirationDate` (integer): Expiration time (for Lightning Network).
        #'   - `currency` (character): The currency.
        #'   - `chainName` (character): The chain name.
        add_deposit_address = function(currency, chain = NULL, to = NULL, amount = NULL) {
            return(add_deposit_address_v3_impl(
                keys = self$keys,
                base_url = self$base_url,
                currency = currency,
                chain = chain,
                to = to,
                amount = amount
            ))
        },
        
        #' Get Deposit Addresses
        #'
        #' ### Description
        #' Retrieves all deposit addresses for a specified currency on KuCoin asynchronously by sending a GET request to the `/api/v3/deposit-addresses` endpoint.
        #' This method constructs the query string, generates authentication headers, and processes the response into a `data.table`.
        #' It calls `get_deposit_addresses_v3_impl`.
        #'
        #' ### Workflow Overview
        #' 1. **URL Construction**: Combines the base URL with `/api/v3/deposit-addresses` and appends query parameters.
        #' 2. **Header Preparation**: Generates authentication headers asynchronously using `build_headers()`.
        #' 3. **API Request**: Sends a GET request with a 3-second timeout via `httr::GET()`.
        #' 4. **Response Processing**: Validates the response and converts the `"data"` array into a `data.table`.
        #'
        #' ### API Endpoint
        #' `GET https://api.kucoin.com/api/v3/deposit-addresses`
        #'
        #' ### Usage
        #' Utilised by users to retrieve all existing deposit addresses for a given currency.
        #'
        #' ### Official Documentation
        #' [KuCoin Get Deposit Address (V3)](https://www.kucoin.com/docs-new/rest/account-info/deposit/get-deposit-address-v3)
        #'
        #' @param currency Character string; the currency for which to retrieve deposit addresses (e.g., "BTC", "ETH", "USDT").
        #' @param amount Character string (optional); the deposit amount, only used for Lightning Network invoices.
        #' @param chain Character string (optional); the chain identifier (e.g., "eth", "bech32", "btc").
        #'
        #' @return Promise resolving to a `data.table` containing:
        #'   - `address` (character): The deposit address.
        #'   - `memo` (character): Address remark (may be empty).
        #'   - `chainId` (character): The chain identifier.
        #'   - `to` (character): The account type ("main" or "trade").
        #'   - `expirationDate` (integer): Expiration time (for Lightning Network).
        #'   - `currency` (character): The currency.
        #'   - `contractAddress` (character): The token contract address.
        #'   - `chainName` (character): The chain name.
        get_deposit_addresses = function(currency, amount = NULL, chain = NULL) {
            return(get_deposit_addresses_v3_impl(
                keys = self$keys,
                base_url = self$base_url,
                currency = currency,
                amount = amount,
                chain = chain
            ))
        },
        
        #' Get Deposit History
        #'
        #' ### Description
        #' Retrieves a paginated list of deposit history entries for a specified currency on KuCoin asynchronously by sending a GET request to the `/api/v1/deposits` endpoint.
        #' This method handles pagination, constructs the query string, generates authentication headers, and processes the response into a `data.table` with a `createdAtDatetime` column.
        #' It calls `get_deposit_history_impl`.
        #'
        #' ### Workflow Overview
        #' 1. **URL Construction**: Combines the base URL with `/api/v1/deposits` and appends query parameters for filters and pagination.
        #' 2. **Pagination Initialisation**: Sets an initial query with `currentPage = 1` and the specified `page_size`.
        #' 3. **Page Fetching**: Defines an async helper to fetch each page with authentication headers.
        #' 4. **Automatic Pagination**: Uses `auto_paginate` to fetch all pages up to `max_pages`.
        #' 5. **Response Processing**: Combines `"items"` from each page into a `data.table`, adding `createdAtDatetime`.
        #'
        #' ### API Endpoint
        #' `GET https://api.kucoin.com/api/v1/deposits`
        #'
        #' ### Usage
        #' Utilised by users to fetch a comprehensive history of deposits for a KuCoin account, with optional filters for status and time range.
        #'
        #' ### Official Documentation
        #' [KuCoin Get Deposit History](https://www.kucoin.com/docs-new/rest/account-info/deposit/get-deposit-history)
        #'
        #' @param currency Character string; the currency to filter deposits by (e.g., "BTC", "ETH", "USDT").
        #' @param status Character string (optional); the status to filter by ("PROCESSING", "SUCCESS", "FAILURE").
        #' @param startAt Integer (optional); start time in milliseconds to filter deposits (e.g., 1728663338000).
        #' @param endAt Integer (optional); end time in milliseconds to filter deposits (e.g., 1728692138000).
        #' @param page_size Integer; number of results per page (10–500, default 50).
        #' @param max_pages Numeric; maximum number of pages to fetch (default `Inf` for all pages).
        #'
        #' @return Promise resolving to a `data.table` containing:
        #'   - `currency` (character): The currency of the deposit.
        #'   - `chain` (character): The chain identifier.
        #'   - `status` (character): Deposit status.
        #'   - `address` (character): Deposit address.
        #'   - `memo` (character): Address remark.
        #'   - `isInner` (logical): Whether the deposit is internal.
        #'   - `amount` (character): Deposit amount.
        #'   - `fee` (character): Fee charged.
        #'   - `walletTxId` (character or NULL): Wallet transaction ID.
        #'   - `createdAt` (integer): Creation timestamp in milliseconds.
        #'   - `createdAtDatetime` (POSIXct): Converted creation datetime.
        #'   - `updatedAt` (integer): Last updated timestamp in milliseconds.
        #'   - `remark` (character): Additional remarks.
        #'   - `arrears` (logical): Whether the deposit is in arrears.
        get_deposit_history = function(currency, status = NULL, startAt = NULL, endAt = NULL, page_size = 50, max_pages = Inf) {
            return(get_deposit_history_impl(
                keys = self$keys,
                base_url = self$base_url,
                currency = currency,
                status = status,
                startAt = startAt,
                endAt = endAt,
                page_size = page_size,
                max_pages = max_pages
            ))
        }
    )
)



Ok and here is the impl functions for all the implementation functions relating to orders. Use these to create the R6 classes and get full context and documentation.

# ./impl_spottrading_orders_add_order.R

# File: ./R/impl_spottrading_orders_add_order.R

# box::use(
#     ./helpers_api[process_kucoin_response, build_headers],
#     ./utils[build_query, get_base_url, verify_symbol],
#     ./utils_time_convert_kucoin[time_convert_to_kucoin],
#     coro[async, await],
#     data.table[as.data.table],
#     httr[POST, timeout, content_type_json],
#     jsonlite[toJSON],
#     rlang[abort, arg_match0]
# )

#' Place Order (Shared Implementation)
#'
#' This is a shared helper function for placing orders or testing order placement on the KuCoin Spot trading system.
#' It handles parameter validation, request body construction, authentication, API request sending, and response processing.
#'
#' @param keys List; API configuration parameters from `get_api_keys()`, including:
#'   - `api_key` (character): KuCoin API key.
#'   - `api_secret` (character): KuCoin API secret.
#'   - `api_passphrase` (character): KuCoin API passphrase.
#'   - `key_version` (character): API key version (e.g., "2"). Defaults to `get_api_keys()`.
#' @param base_url Character string; base URL for the KuCoin API. Defaults to `get_base_url()`.
#' @param endpoint Character string; the API endpoint to use (e.g., "/api/v1/hf/orders" or "/api/v1/hf/orders/test").
#' @param type Character string; order type: "limit" or "market". Required.
#' @param symbol Character string; trading pair (e.g., "BTC-USDT"). Required.
#' @param side Character string; order side: "buy" or "sell". Required.
#' @param clientOid Character string; unique client order ID (recommended UUID, max 40 chars). Optional.
#' @param price Character string; price for limit orders (must align with priceIncrement). Required for limit orders.
#' @param size Character string; quantity for limit or market orders (must align with baseIncrement). Required for limit, optional for market.
#' @param funds Character string; funds for market orders (must align with quoteIncrement). Optional for market, mutually exclusive with size.
#' @param stp Character string; self-trade prevention strategy: "CN", "CO", "CB", or "DC". Optional.
#' @param tags Character string; order tag (max 20 ASCII chars). Optional.
#' @param remark Character string; order remarks (max 20 ASCII chars). Optional.
#' @param timeInForce Character string; time-in-force strategy: "GTC", "GTT", "IOC", or "FOK". Optional, defaults to "GTC".
#' @param cancelAfter Integer; cancel after n seconds (for GTT). Optional.
#' @param postOnly Logical; passive order flag (disabled for IOC/FOK). Optional, defaults to FALSE.
#' @param hidden Logical; hide order from order book. Optional, defaults to FALSE.
#' @param iceberg Logical; show only visible portion in iceberg orders. Optional, defaults to FALSE.
#' @param visibleSize Character string; max visible quantity for iceberg orders. Optional.
#' @return Promise resolving to a `data.table` containing:
#'   - `orderId` (character): Unique order ID generated by KuCoin (or simulated for test).
#'   - `clientOid` (character): Client-specified order ID.
place_order_helper <- coro::async(function(
    keys = get_api_keys(),
    base_url = get_base_url(),
    endpoint,
    type,
    symbol,
    side,
    clientOid = NULL,
    price = NULL,
    size = NULL,
    funds = NULL,
    stp = NULL,
    tags = NULL,
    remark = NULL,
    timeInForce = NULL,
    cancelAfter = NULL,
    postOnly = NULL,
    hidden = NULL,
    iceberg = NULL,
    visibleSize = NULL
) {
    tryCatch({
        # Validate required parameters
        type <- rlang::arg_match0(type, c("limit", "market"), arg_name = "type")
        if (is.null(symbol) || !verify_symbol(symbol)) {
            rlang::abort("Parameter 'symbol' must be a valid ticker (e.g., 'BTC-USDT').")
        }
        side <- rlang::arg_match0(side, c("buy", "sell"), arg_name = "side")

        # Validate order type-specific parameters
        if (type == "limit") {
            if (is.null(price) || !is.character(price)) {
                rlang::abort("Parameter 'price' is required for limit orders and must be a character string.")
            }
            if (is.null(size) || !is.character(size)) {
                rlang::abort("Parameter 'size' is required for limit orders and must be a character string.")
            }
            if (!is.null(funds)) {
                rlang::abort("Parameter 'funds' is not applicable for limit orders.")
            }
        } else if (type == "market") {
            if (!is.null(price)) {
                rlang::abort("Parameter 'price' is not applicable for market orders.")
            }
            if (is.null(size) && is.null(funds)) {
                rlang::abort("Either 'size' or 'funds' must be specified for market orders.")
            }
            if (!is.null(size) && !is.null(funds)) {
                rlang::abort("Parameters 'size' and 'funds' are mutually exclusive for market orders.")
            }
            if (!is.null(size) && !is.character(size)) {
                rlang::abort("Parameter 'size' must be a character string for market orders.")
            }
            if (!is.null(funds) && !is.character(funds)) {
                rlang::abort("Parameter 'funds' must be a character string for market orders.")
            }
        }

        # Validate optional parameters
        if (!is.null(clientOid)) {
            if (!is.character(clientOid) || nchar(clientOid) > 40 || !grepl("^[a-zA-Z0-9_-]+$", clientOid)) {
                rlang::abort("Parameter 'clientOid' must be a string with maximum 40 characters, containing only letters, numbers, underscores, or hyphens.")
            }
        }
        if (!is.null(stp)) {
            stp <- rlang::arg_match0(stp, c("CN", "CO", "CB", "DC"), arg_name = "stp")
        }
        if (!is.null(tags)) {
            if (!is.character(tags) || nchar(tags) > 20 || !grepl("^[[:ascii:]]+$", tags)) {
                rlang::abort("Parameter 'tags' must be ASCII and maximum 20 characters.")
            }
        }
        if (!is.null(remark)) {
            if (!is.character(remark) || nchar(remark) > 20 || !grepl("^[[:ascii:]]+$", remark)) {
                rlang::abort("Parameter 'remark' must be ASCII and maximum 20 characters.")
            }
        }
        if (!is.null(timeInForce)) {
            timeInForce <- rlang::arg_match0(timeInForce, c("GTC", "GTT", "IOC", "FOK"), arg_name = "timeInForce")
        } else {
            timeInForce <- "GTC"  # Default as per API documentation
        }
        if (!is.null(cancelAfter)) {
            if (!is.numeric(cancelAfter) || cancelAfter <= 0) {
                rlang::abort("Parameter 'cancelAfter' must be a positive number.")
            }
        }
        if (!is.null(postOnly)) {
            if (!is.logical(postOnly)) {
                rlang::abort("Parameter 'postOnly' must be a logical value.")
            }
        } else {
            postOnly <- FALSE  # Default as per API documentation
        }
        if (!is.null(hidden)) {
            if (!is.logical(hidden)) {
                rlang::abort("Parameter 'hidden' must be a logical value.")
            }
        } else {
            hidden <- FALSE  # Default as per API documentation
        }
        if (!is.null(iceberg)) {
            if (!is.logical(iceberg)) {
                rlang::abort("Parameter 'iceberg' must be a logical value.")
            }
        } else {
            iceberg <- FALSE  # Default as per API documentation
        }
        if (!is.null(visibleSize)) {
            if (!is.character(visibleSize)) {
                rlang::abort("Parameter 'visibleSize' must be a character string.")
            }
            if (!iceberg) {
                rlang::abort("Parameter 'visibleSize' is only applicable when 'iceberg' is TRUE.")
            }
        }

        # Additional validation for timeInForce constraints
        if (timeInForce == "GTT" && is.null(cancelAfter)) {
            rlang::abort("Parameter 'cancelAfter' is required when 'timeInForce' is 'GTT'.")
        }
        if (postOnly && timeInForce %in% c("IOC", "FOK")) {
            rlang::abort("Parameter 'postOnly' cannot be TRUE when 'timeInForce' is 'IOC' or 'FOK'.")
        }
        if (iceberg && hidden) {
            rlang::abort("Parameters 'iceberg' and 'hidden' cannot both be TRUE.")
        }

        # Construct request body
        body_list <- list(
            type = type,
            symbol = symbol,
            side = side,
            clientOid = clientOid,
            price = price,
            size = size,
            funds = funds,
            stp = stp,
            tags = tags,
            remark = remark,
            timeInForce = timeInForce,
            cancelAfter = if (!is.null(cancelAfter)) as.integer(cancelAfter) else NULL,
            postOnly = postOnly,
            hidden = hidden,
            iceberg = iceberg,
            visibleSize = visibleSize
        )
        # Remove NULL values
        body_list <- body_list[!sapply(body_list, is.null)]
        body_json <- jsonlite::toJSON(body_list, auto_unbox = TRUE)

        # Prepare API request
        url <- paste0(base_url, endpoint)
        method <- "POST"

        # Generate authentication headers
        headers <- await(build_headers(method, endpoint, body_json, keys))

        # Send POST request
        response <- httr::POST(
            url = url,
            body = body_json,
            headers,
            httr::content_type_json(),
            httr::timeout(3)
        )

        # Process response
        parsed_response <- process_kucoin_response(response, url)
        if (parsed_response$code != "200000") {
            rlang::abort(sprintf("API error: %s - %s", parsed_response$code, parsed_response$msg))
        }

        # Convert response data to data.table
        result_dt <- data.table::as.data.table(parsed_response$data)

        return(result_dt)
    }, error = function(e) {
        rlang::abort(sprintf("Error in place_order_helper: %s", conditionMessage(e)))
    })
})

#' Add Order (Implementation)
#'
#' Places a new order (limit or market) to the KuCoin Spot trading system asynchronously.
#' This function handles both limit and market order types, validates parameters according to KuCoin's specifications,
#' and returns the order ID and client order ID upon successful placement.
#'
#' ### Workflow Overview
#' 1. **Parameter Validation**: Validates required and optional parameters based on order type (limit/market) using `rlang::arg_match0` for enumerated values.
#' 2. **Request Body Construction**: Builds a JSON body with mandatory and optional parameters.
#' 3. **Authentication**: Generates headers with API credentials using `build_headers()`.
#' 4. **API Request**: Sends a POST request to the KuCoin API with a 3-second timeout.
#' 5. **Response Processing**: Parses the response, validates success, and returns order details as a `data.table`.
#'
#' ### API Endpoint
#' `POST https://api.kucoin.com/api/v1/hf/orders`
#'
#' ### Usage
#' Utilised to place spot trading orders on KuCoin. Supports limit orders (price + size) and market orders (size or funds).
#' Requires sufficient funds in the account and adheres to KuCoin's trading rules (e.g., max 2000 active orders).
#'
#' ### Official Documentation
#' [KuCoin Add Order](https://www.kucoin.com/docs-new/rest/spot-trading/orders/add-order)
#'
#' @param keys List; API configuration parameters from `get_api_keys()`. Defaults to `get_api_keys()`.
#' @param base_url Character string; base URL for the KuCoin API. Defaults to `get_base_url()`.
#' @param type Character string; order type: "limit" or "market". Required.
#' @param symbol Character string; trading pair (e.g., "BTC-USDT"). Required.
#' @param side Character string; order side: "buy" or "sell". Required.
#' @param clientOid Character string; unique client order ID (recommended UUID, max 40 chars). Optional.
#' @param price Character string; price for limit orders (must align with priceIncrement). Required for limit orders.
#' @param size Character string; quantity for limit or market orders (must align with baseIncrement). Required for limit, optional for market.
#' @param funds Character string; funds for market orders (must align with quoteIncrement). Optional for market, mutually exclusive with size.
#' @param stp Character string; self-trade prevention strategy: "CN", "CO", "CB", or "DC". Optional.
#' @param tags Character string; order tag (max 20 ASCII chars). Optional.
#' @param remark Character string; order remarks (max 20 ASCII chars). Optional.
#' @param timeInForce Character string; time-in-force strategy: "GTC", "GTT", "IOC", or "FOK". Optional, defaults to "GTC".
#' @param cancelAfter Integer; cancel after n seconds (for GTT). Optional.
#' @param postOnly Logical; passive order flag (disabled for IOC/FOK). Optional, defaults to FALSE.
#' @param hidden Logical; hide order from order book. Optional, defaults to FALSE.
#' @param iceberg Logical; show only visible portion in iceberg orders. Optional, defaults to FALSE.
#' @param visibleSize Character string; max visible quantity for iceberg orders. Optional.
#' @return Promise resolving to a `data.table` containing:
#'   - `orderId` (character): Unique order ID generated by KuCoin.
#'   - `clientOid` (character): Client-specified order ID.
#' @examples
#' \dontrun{
#' main_async <- coro::async(function() {
#'   # Place a limit buy order
#'   order <- await(add_order_impl(
#'     type = "limit",
#'     symbol = "BTC-USDT",
#'     side = "buy",
#'     price = "50000",
#'     size = "0.0001",
#'     clientOid = uuid::UUIDgenerate(),
#'     remark = "Test limit order"
#'   ))
#'   print(order)
#'
#'   # Place a market buy order with funds
#'   market_order <- await(add_order_impl(
#'     type = "market",
#'     symbol = "BTC-USDT",
#'     side = "buy",
#'     funds = "10",
#'     clientOid = uuid::UUIDgenerate()
#'   ))
#'   print(market_order)
#' })
#' main_async()
#' while (!later::loop_empty()) later::run_now()
#' }
#' @importFrom coro async await
#' @importFrom data.table as.data.table
#' @importFrom httr POST timeout content_type_json
#' @importFrom jsonlite toJSON
#' @importFrom rlang abort arg_match0
#' @export
add_order_impl <- coro::async(function(
    keys = get_api_keys(),
    base_url = get_base_url(),
    type,
    symbol,
    side,
    clientOid = NULL,
    price = NULL,
    size = NULL,
    funds = NULL,
    stp = NULL,
    tags = NULL,
    remark = NULL,
    timeInForce = NULL,
    cancelAfter = NULL,
    postOnly = NULL,
    hidden = NULL,
    iceberg = NULL,
    visibleSize = NULL
) {
    return(place_order_helper(
        keys = keys,
        base_url = base_url,
        endpoint = "/api/v1/hf/orders",
        type = type,
        symbol = symbol,
        side = side,
        clientOid = clientOid,
        price = price,
        size = size,
        funds = funds,
        stp = stp,
        tags = tags,
        remark = remark,
        timeInForce = timeInForce,
        cancelAfter = cancelAfter,
        postOnly = postOnly,
        hidden = hidden,
        iceberg = iceberg,
        visibleSize = visibleSize
    ))
})

#' Add Order Test (Implementation)
#'
#' Simulates placing a new order (limit or market) to the KuCoin Spot trading system asynchronously for testing purposes.
#' This function validates parameters and checks the signature without actually placing an order.
#' It returns the same response structure as the actual order placement endpoint.
#'
#' ### Workflow Overview
#' 1. **Parameter Validation**: Validates required and optional parameters based on order type (limit/market) using `rlang::arg_match0` for enumerated values.
#' 2. **Request Body Construction**: Builds a JSON body with mandatory and optional parameters.
#' 3. **Authentication**: Generates headers with API credentials using `build_headers()`.
#' 4. **API Request**: Sends a POST request to the KuCoin API test endpoint with a 3-second timeout.
#' 5. **Response Processing**: Parses the response, validates success, and returns simulated order details as a `data.table`.
#'
#' ### API Endpoint
#' `POST https://api.kucoin.com/api/v1/hf/orders/test`
#'
#' ### Usage
#' Utilised to test order placement logic and signature validity without affecting the actual trading system.
#'
#' ### Official Documentation
#' [KuCoin Add Order Test](https://www.kucoin.com/docs-new/rest/spot-trading/orders/add-order-test)
#'
#' @param keys List; API configuration parameters from `get_api_keys()`. Defaults to `get_api_keys()`.
#' @param base_url Character string; base URL for the KuCoin API. Defaults to `get_base_url()`.
#' @param type Character string; order type: "limit" or "market". Required.
#' @param symbol Character string; trading pair (e.g., "BTC-USDT"). Required.
#' @param side Character string; order side: "buy" or "sell". Required.
#' @param clientOid Character string; unique client order ID (recommended UUID, max 40 chars). Optional.
#' @param price Character string; price for limit orders (must align with priceIncrement). Required for limit orders.
#' @param size Character string; quantity for limit or market orders (must align with baseIncrement). Required for limit, optional for market.
#' @param funds Character string; funds for market orders (must align with quoteIncrement). Optional for market, mutually exclusive with size.
#' @param stp Character string; self-trade prevention strategy: "CN", "CO", "CB", or "DC". Optional.
#' @param tags Character string; order tag (max 20 ASCII chars). Optional.
#' @param remark Character string; order remarks (max 20 ASCII chars). Optional.
#' @param timeInForce Character string; time-in-force strategy: "GTC", "GTT", "IOC", or "FOK". Optional, defaults to "GTC".
#' @param cancelAfter Integer; cancel after n seconds (for GTT). Optional.
#' @param postOnly Logical; passive order flag (disabled for IOC/FOK). Optional, defaults to FALSE.
#' @param hidden Logical; hide order from order book. Optional, defaults to FALSE.
#' @param iceberg Logical; show only visible portion in iceberg orders. Optional, defaults to FALSE.
#' @param visibleSize Character string; max visible quantity for iceberg orders. Optional.
#' @return Promise resolving to a `data.table` containing:
#'   - `orderId` (character): Simulated unique order ID.
#'   - `clientOid` (character): Client-specified order ID.
#' @examples
#' \dontrun{
#' main_async <- coro::async(function() {
#'   # Test a limit buy order
#'   test_order <- await(add_order_test_impl(
#'     type = "limit",
#'     symbol = "BTC-USDT",
#'     side = "buy",
#'     price = "50000",
#'     size = "0.0001",
#'     clientOid = uuid::UUIDgenerate(),
#'     remark = "Test limit order"
#'   ))
#'   print(test_order)
#'
#'   # Test a market buy order with funds
#'   test_market_order <- await(add_order_test_impl(
#'     type = "market",
#'     symbol = "BTC-USDT",
#'     side = "buy",
#'     funds = "10",
#'     clientOid = uuid::UUIDgenerate()
#'   ))
#'   print(test_market_order)
#' })
#' main_async()
#' while (!later::loop_empty()) later::run_now()
#' }
#' @importFrom coro async await
#' @importFrom data.table as.data.table
#' @importFrom httr POST timeout content_type_json
#' @importFrom jsonlite toJSON
#' @importFrom rlang abort arg_match0
#' @export
add_order_test_impl <- coro::async(function(
    keys = get_api_keys(),
    base_url = get_base_url(),
    type,
    symbol,
    side,
    clientOid = NULL,
    price = NULL,
    size = NULL,
    funds = NULL,
    stp = NULL,
    tags = NULL,
    remark = NULL,
    timeInForce = NULL,
    cancelAfter = NULL,
    postOnly = NULL,
    hidden = NULL,
    iceberg = NULL,
    visibleSize = NULL
) {
    return(place_order_helper(
        keys = keys,
        base_url = base_url,
        endpoint = "/api/v1/hf/orders/test",
        type = type,
        symbol = symbol,
        side = side,
        clientOid = clientOid,
        price = price,
        size = size,
        funds = funds,
        stp = stp,
        tags = tags,
        remark = remark,
        timeInForce = timeInForce,
        cancelAfter = cancelAfter,
        postOnly = postOnly,
        hidden = hidden,
        iceberg = iceberg,
        visibleSize = visibleSize
    ))
})

# ------------------------------------------------------------------------------

#' Validate a Single Order for Batch Placement
#'
#' Validates the parameters of a single order within a batch, ensuring all required fields are present
#' and optional fields meet KuCoin's specifications. Sets default values where applicable.
#'
#' @param order List; a list containing order parameters such as `symbol`, `type`, `side`, etc.
#' @return List; the validated order with defaults applied.
validate_order <- function(order) {
    if (!is.list(order)) {
        rlang::abort("Each order must be a list.")
    }

    # Check required fields
    required_fields <- c("symbol", "type", "side")
    for (field in required_fields) {
        if (is.null(order[[field]])) {
            rlang::abort(sprintf("Missing required field '%s' in order.", field))
        }
    }

    # Validate core parameters
    type <- rlang::arg_match0(order$type, c("limit", "market"), arg_name = "type")
    side <- rlang::arg_match0(order$side, c("buy", "sell"), arg_name = "side")
    if (!verify_symbol(order$symbol)) {
        rlang::abort(sprintf("Invalid symbol '%s' in order.", order$symbol))
    }

    # Initialize validated order with required fields
    validated_order <- list(
        symbol = order$symbol,
        type = type,
        side = side
    )

    # Type-specific validation
    if (type == "limit") {
        if (is.null(order$price) || !is.character(order$price)) {
            rlang::abort("Parameter 'price' is required for limit orders and must be a character string.")
        }
        if (is.null(order$size) || !is.character(order$size)) {
            rlang::abort("Parameter 'size' is required for limit orders and must be a character string.")
        }
        if (!is.null(order$funds)) {
            rlang::abort("Parameter 'funds' is not applicable for limit orders.")
        }
        validated_order$price <- order$price
        validated_order$size <- order$size
    } else if (type == "market") {
        if (!is.null(order$price)) {
            rlang::abort("Parameter 'price' is not applicable for market orders.")
        }
        if (is.null(order$size) && is.null(order$funds)) {
            rlang::abort("Either 'size' or 'funds' must be specified for market orders.")
        }
        if (!is.null(order$size) && !is.null(order$funds)) {
            rlang::abort("Parameters 'size' and 'funds' are mutually exclusive for market orders.")
        }
        if (!is.null(order$size)) {
            if (!is.character(order$size)) {
                rlang::abort("Parameter 'size' must be a character string for market orders.")
            }
            validated_order$size <- order$size
        }
        if (!is.null(order$funds)) {
            if (!is.character(order$funds)) {
                rlang::abort("Parameter 'funds' must be a character string for market orders.")
            }
            validated_order$funds <- order$funds
        }
    }

    # Validate optional parameters
    if (!is.null(order$clientOid)) {
        if (!is.character(order$clientOid) || nchar(order$clientOid) > 40 || !grepl("^[a-zA-Z0-9_-]+$", order$clientOid)) {
            rlang::abort("Parameter 'clientOid' must be a string with maximum 40 characters, containing only letters, numbers, underscores, or hyphens.")
        }
        validated_order$clientOid <- order$clientOid
    }
    if (!is.null(order$stp)) {
        validated_order$stp <- rlang::arg_match0(order$stp, c("CN", "CO", "CB", "DC"), arg_name = "stp")
    }
    if (!is.null(order$tags)) {
        if (!is.character(order$tags) || nchar(order$tags) > 20 || !grepl("^[[:ascii:]]+$", order$tags)) {
            rlang::abort("Parameter 'tags' must be ASCII and maximum 20 characters.")
        }
        validated_order$tags <- order$tags
    }
    if (!is.null(order$remark)) {
        if (!is.character(order$remark) || nchar(order$remark) > 20 || !grepl("^[[:ascii:]]+$", order$remark)) {
            rlang::abort("Parameter 'remark' must be ASCII and maximum 20 characters.")
        }
        validated_order$remark <- order$remark
    }
    if (!is.null(order$timeInForce)) {
        validated_order$timeInForce <- rlang::arg_match0(order$timeInForce, c("GTC", "GTT", "IOC", "FOK"), arg_name = "timeInForce")
    } else {
        validated_order$timeInForce <- "GTC"  # Default as per API documentation
    }
    if (!is.null(order$cancelAfter)) {
        if (!is.numeric(order$cancelAfter) || order$cancelAfter <= 0) {
            rlang::abort("Parameter 'cancelAfter' must be a positive number.")
        }
        validated_order$cancelAfter <- as.integer(order$cancelAfter)
    }
    if (!is.null(order$postOnly)) {
        if (!is.logical(order$postOnly)) {
            rlang::abort("Parameter 'postOnly' must be a logical value.")
        }
        validated_order$postOnly <- order$postOnly
    } else {
        validated_order$postOnly <- FALSE  # Default as per API documentation
    }
    if (!is.null(order$hidden)) {
        if (!is.logical(order$hidden)) {
            rlang::abort("Parameter 'hidden' must be a logical value.")
        }
        validated_order$hidden <- order$hidden
    } else {
        validated_order$hidden <- FALSE  # Default as per API documentation
    }
    if (!is.null(order$iceberg)) {
        if (!is.logical(order$iceberg)) {
            rlang::abort("Parameter 'iceberg' must be a logical value.")
        }
        validated_order$iceberg <- order$iceberg
    } else {
        validated_order$iceberg <- FALSE  # Default as per API documentation
    }
    if (!is.null(order$visibleSize)) {
        if (!is.character(order$visibleSize)) {
            rlang::abort("Parameter 'visibleSize' must be a character string.")
        }
        if (!validated_order$iceberg) {
            rlang::abort("Parameter 'visibleSize' is only applicable when 'iceberg' is TRUE.")
        }
        validated_order$visibleSize <- order$visibleSize
    }

    # Additional validation for timeInForce constraints
    if (validated_order$timeInForce == "GTT" && is.null(validated_order$cancelAfter)) {
        rlang::abort("Parameter 'cancelAfter' is required when 'timeInForce' is 'GTT'.")
    }
    if (validated_order$postOnly && validated_order$timeInForce %in% c("IOC", "FOK")) {
        rlang::abort("Parameter 'postOnly' cannot be TRUE when 'timeInForce' is 'IOC' or 'FOK'.")
    }
    if (validated_order$iceberg && validated_order$hidden) {
        rlang::abort("Parameters 'iceberg' and 'hidden' cannot both be TRUE.")
    }

    return(validated_order)
}

#' Add Orders Batch (Implementation)
#'
#' Places multiple new orders (up to 20) to the KuCoin Spot trading system asynchronously.
#' This function validates a list of orders, constructs a batch request, and returns the placement results for each order.
#'
#' ### Workflow Overview
#' 1. **Parameter Validation**: Ensures the `order_list` contains 1–20 valid orders, each validated via `validate_order()`.
#' 2. **Request Body Construction**: Builds a JSON body with the `orderList` key containing validated orders.
#' 3. **Authentication**: Generates headers with API credentials using `build_headers()`.
#' 4. **API Request**: Sends a POST request to the KuCoin API with a 3-second timeout.
#' 5. **Response Processing**: Parses the response and returns results as a `data.table`.
#'
#' ### API Endpoint
#' `POST https://api.kucoin.com/api/v1/hf/orders/multi`
#'
#' ### Usage
#' Used to place multiple spot trading orders on KuCoin in a single request. Each order can be a limit or market order,
#' with appropriate parameters. Requires sufficient funds and adheres to KuCoin's limits (e.g., max 20 orders per request,
#' 2000 active orders per account).
#'
#' ### Official Documentation
#' [KuCoin Batch Add Orders](https://www.kucoin.com/docs-new/rest/spot-trading/orders/batch-add-orders)
#'
#' @param keys List; API configuration parameters from `get_api_keys()`, including:
#'   - `api_key` (character): KuCoin API key.
#'   - `api_secret` (character): KuCoin API secret.
#'   - `api_passphrase` (character): KuCoin API passphrase.
#'   - `key_version` (character): API key version (e.g., "2"). Defaults to `get_api_keys()`.
#' @param base_url Character string; base URL for the KuCoin API. Defaults to `get_base_url()`.
#' @param order_list List; a list of orders, where each order is a list with parameters:
#'   - `symbol` (character): Trading pair (e.g., "BTC-USDT"). Required.
#'   - `type` (character): Order type: "limit" or "market". Required.
#'   - `side` (character): Order side: "buy" or "sell". Required.
#'   - `clientOid` (character): Unique client order ID (max 40 chars). Optional.
#'   - `price` (character): Price for limit orders. Required for limit.
#'   - `size` (character): Quantity for limit or market orders. Required for limit, optional for market.
#'   - `funds` (character): Funds for market orders. Optional for market, mutually exclusive with `size`.
#'   - `stp` (character): Self-trade prevention: "CN", "CO", "CB", or "DC". Optional.
#'   - `tags` (character): Order tag (max 20 ASCII chars). Optional.
#'   - `remark` (character): Order remarks (max 20 ASCII chars). Optional.
#'   - `timeInForce` (character): Time-in-force: "GTC", "GTT", "IOC", or "FOK". Optional, defaults to "GTC".
#'   - `cancelAfter` (integer): Cancel after n seconds (for GTT). Optional.
#'   - `postOnly` (logical): Passive order flag. Optional, defaults to FALSE.
#'   - `hidden` (logical): Hide order from order book. Optional, defaults to FALSE.
#'   - `iceberg` (logical): Iceberg order flag. Optional, defaults to FALSE.
#'   - `visibleSize` (character): Visible quantity for iceberg orders. Optional.
#' @return Promise resolving to a `data.table` containing results for each order, with columns:
#'   - `success` (logical): Whether the order placement was successful.
#'   - `orderId` (character): Unique order ID (if successful).
#'   - `clientOid` (character): Client-specified order ID (if provided).
#'   - `failMsg` (character): Error message (if failed).
#' @examples
#' \dontrun{
#' main_async <- coro::async(function() {
#'   # Define two orders
#'   order1 <- list(
#'     clientOid = uuid::UUIDgenerate(),
#'     symbol = "BTC-USDT",
#'     type = "limit",
#'     side = "buy",
#'     price = "30000",
#'     size = "0.00001",
#'     remark = "Batch buy"
#'   )
#'   order2 <- list(
#'     clientOid = uuid::UUIDgenerate(),
#'     symbol = "ETH-USDT",
#'     type = "market",
#'     side = "sell",
#'     size = "0.01"
#'   )
#'   # Place batch orders
#'   result <- await(add_order_batch_impl(order_list = list(order1, order2)))
#'   print(result)
#' })
#' main_async()
#' while (!later::loop_empty()) later::run_now()
#' }
#' @importFrom coro async await
#' @importFrom data.table as.data.table
#' @importFrom httr POST timeout content_type_json
#' @importFrom jsonlite toJSON
#' @importFrom rlang abort arg_match0
#' @export
add_order_batch_impl <- coro::async(function(
    keys = get_api_keys(),
    base_url = get_base_url(),
    order_list
) {
    tryCatch({
        # Validate order_list
        if (!is.list(order_list) || length(order_list) == 0 || length(order_list) > 20) {
            rlang::abort("Parameter 'order_list' must be a list containing 1 to 20 orders.")
        }

        # Validate each order in the list
        validated_orders <- lapply(order_list, validate_order)

        # Construct request body
        body_list <- list(orderList = validated_orders)
        body_json <- jsonlite::toJSON(body_list, auto_unbox = TRUE)

        # Prepare API request
        endpoint <- "/api/v1/hf/orders/multi"
        url <- paste0(base_url, endpoint)
        method <- "POST"

        # Generate authentication headers
        headers <- await(build_headers(method, endpoint, body_json, keys))

        # Send POST request
        response <- httr::POST(
            url = url,
            body = body_json,
            headers,
            httr::content_type_json(),
            httr::timeout(3)
        )

        # Process response
        parsed_response <- process_kucoin_response(response, url)
        if (parsed_response$code != "200000") {
            rlang::abort(sprintf("API error: %s - %s", parsed_response$code, parsed_response$msg))
        }

        # Convert response data to data.table
        result_dt <- data.table::as.data.table(parsed_response$data)

        return(result_dt)
    }, error = function(e) {
        rlang::abort(sprintf("Error in add_order_batch_impl: %s", conditionMessage(e)))
    })
})

# ./impl_spottrading_orders_cancel_order.R

# File: ./R/impl_spottrading_orders_cancel_order.R

# box::use(
#     ./helpers_api[process_kucoin_response, build_headers],
#     ./utils[build_query, get_base_url, verify_symbol, get_api_keys],
#     coro[async, await],
#     data.table[data.table],
#     httr[DELETE, timeout],
#     rlang[abort]
# )

#' Cancel Order By OrderId (Implementation)
#'
#' Cancels a spot order by its order ID on the KuCoin Spot trading system asynchronously.
#' This function sends a cancellation request and returns the order ID if the request is successfully sent.
#' Note that the actual cancellation status must be checked via order status or Websocket subscription.
#' 
#' ### Difference Between Cancel By OrderId and Cancel By ClientOid
#' - **Cancel By OrderId**: Use this when you have the unique order ID generated by KuCoin. This is useful if you are tracking orders using KuCoin's identifiers.
#' - **Cancel By ClientOid**: Use this when you have assigned a unique client order ID (clientOid) to your orders. This is convenient if you are tracking orders using your own identifiers and want to cancel them without mapping to KuCoin's order IDs.
#' 
#' Choose the method that aligns with how you manage and track your orders in your system.
#'
#' ### Workflow Overview
#' 1. **Parameter Validation**: Ensures `orderId` and `symbol` are provided and valid.
#' 2. **Request Construction**: Builds the API endpoint with `orderId` and `symbol` as a query parameter.
#' 3. **Authentication**: Generates headers with API credentials using `build_headers()`.
#' 4. **API Request**: Sends a DELETE request to the KuCoin API with a 3-second timeout.
#' 5. **Response Processing**: Parses the response and returns the order ID if successful.
#'
#' ### API Endpoint
#' `DELETE https://api.kucoin.com/api/v1/hf/orders/{orderId}?symbol={symbol}`
#'
#' ### Usage
#' Used to cancel a specific spot trading order on KuCoin by its order ID.
#'
#' ### Official Documentation
#' [KuCoin Cancel Order By OrderId](https://www.kucoin.com/docs-new/rest/spot-trading/orders/cancel-order-by-orderld)
#'
#' @param keys List; API configuration parameters from `get_api_keys()`. Defaults to `get_api_keys()`.
#' @param base_url Character string; base URL for the KuCoin API. Defaults to `get_base_url()`.
#' @param orderId Character string; the unique order ID to cancel. Required.
#' @param symbol Character string; the trading pair symbol (e.g., "BTC-USDT"). Required.
#' @return Promise resolving to a `data.table` containing:
#'   - `orderId` (character): The order ID that was requested to be cancelled.
#' @examples
#' \dontrun{
#' main_async <- coro::async(function() {
#'   # Cancel an order by orderId
#'   result <- await(cancel_order_by_order_id_impl(
#'     orderId = "671124f9365ccb00073debd4",
#'     symbol = "BTC-USDT"
#'   ))
#'   print(result)
#' })
#' main_async()
#' while (!later::loop_empty()) later::run_now()
#' }
#' @importFrom coro async await
#' @importFrom data.table data.table
#' @importFrom httr DELETE timeout
#' @importFrom rlang abort
#' @export
cancel_order_by_order_id_impl <- coro::async(function(
    keys = get_api_keys(),
    base_url = get_base_url(),
    orderId,
    symbol
) {
    tryCatch({
        # Validate parameters
        if (is.null(orderId) || !is.character(orderId) || nchar(orderId) == 0) {
            rlang::abort("Parameter 'orderId' must be a non-empty string.")
        }
        if (is.null(symbol) || !verify_symbol(symbol)) {
            rlang::abort("Parameter 'symbol' must be a valid ticker (e.g., 'BTC-USDT').")
        }

        # Construct endpoint and query string
        endpoint <- paste0("/api/v1/hf/orders/", orderId)
        query_params <- list(symbol = symbol)
        query_string <- build_query(query_params)
        endpoint_with_query <- paste0(endpoint, "?", query_string)
        full_url <- paste0(base_url, endpoint_with_query)

        # Generate authentication headers
        headers <- await(build_headers("DELETE", endpoint_with_query, NULL, keys))

        # Send DELETE request
        response <- httr::DELETE(
            url = full_url,
            headers,
            httr::timeout(3)
        )

        # Process response
        parsed_response <- process_kucoin_response(response, full_url)
        if (parsed_response$code != "200000") {
            rlang::abort(sprintf("API error: %s - %s", parsed_response$code, parsed_response$msg))
        }

        # Return result as data.table
        result_dt <- data.table::data.table(orderId = parsed_response$data$orderId)
        return(result_dt)
    }, error = function(e) {
        rlang::abort(sprintf("Error in cancel_order_by_order_id_impl: %s", conditionMessage(e)))
    })
})

#' Cancel Order By ClientOid (Implementation)
#'
#' Cancels a spot order by its client order ID (clientOid) on the KuCoin Spot trading system asynchronously.
#' This function sends a cancellation request and returns the clientOid if the request is successfully sent.
#' Note that the actual cancellation status must be checked via order status or Websocket subscription.
#'
#' ### Difference Between Cancel By OrderId and Cancel By ClientOid
#' - **Cancel By OrderId**: Use this when you have the unique order ID generated by KuCoin. This is useful if you are tracking orders using KuCoin's identifiers.
#' - **Cancel By ClientOid**: Use this when you have assigned a unique client order ID (clientOid) to your orders. This is convenient if you are tracking orders using your own identifiers and want to cancel them without mapping to KuCoin's order IDs.
#' 
#' Choose the method that aligns with how you manage and track your orders in your system.
#'
#' ### Workflow Overview
#' 1. **Parameter Validation**: Ensures `clientOid` and `symbol` are provided and valid.
#' 2. **Request Construction**: Builds the API endpoint with `clientOid` and `symbol` as a query parameter.
#' 3. **Authentication**: Generates headers with API credentials using `build_headers()`.
#' 4. **API Request**: Sends a DELETE request to the KuCoin API with a 3-second timeout.
#' 5. **Response Processing**: Parses the response and returns the clientOid if successful.
#'
#' ### API Endpoint
#' `DELETE https://api.kucoin.com/api/v1/hf/orders/client-order/{clientOid}?symbol={symbol}`
#'
#' ### Usage
#' Used to cancel a specific spot trading order on KuCoin by its client order ID.
#'
#' ### Official Documentation
#' [KuCoin Cancel Order By ClientOid](https://www.kucoin.com/docs-new/rest/spot-trading/orders/cancel-order-by-clientoid)
#'
#' @param keys List; API configuration parameters from `get_api_keys()`. Defaults to `get_api_keys()`.
#' @param base_url Character string; base URL for the KuCoin API. Defaults to `get_base_url()`.
#' @param clientOid Character string; the unique client order ID assigned by the user when placing the order. Required.
#' @param symbol Character string; the trading pair symbol (e.g., "BTC-USDT"). Required.
#' @return Promise resolving to a `data.table` containing:
#'   - `clientOid` (character): The client order ID that was requested to be cancelled.
#' @examples
#' \dontrun{
#' main_async <- coro::async(function() {
#'   # Cancel an order by clientOid
#'   result <- await(cancel_order_by_client_oid_impl(
#'     clientOid = "5c52e11203aa677f33e493fb",
#'     symbol = "BTC-USDT"
#'   ))
#'   print(result)
#' })
#' main_async()
#' while (!later::loop_empty()) later::run_now()
#' }
#' @importFrom coro async await
#' @importFrom data.table data.table
#' @importFrom httr DELETE timeout
#' @importFrom rlang abort
#' @export
cancel_order_by_client_oid_impl <- coro::async(function(
    keys = get_api_keys(),
    base_url = get_base_url(),
    clientOid,
    symbol
) {
    tryCatch({
        # Validate parameters
        if (is.null(clientOid) || !is.character(clientOid) || nchar(clientOid) == 0) {
            rlang::abort("Parameter 'clientOid' must be a non-empty string.")
        }
        if (is.null(symbol) || !verify_symbol(symbol)) {
            rlang::abort("Parameter 'symbol' must be a valid ticker (e.g., 'BTC-USDT').")
        }

        # Construct endpoint and query string
        endpoint <- paste0("/api/v1/hf/orders/client-order/", clientOid)
        query_params <- list(symbol = symbol)
        query_string <- build_query(query_params)
        endpoint_with_query <- paste0(endpoint, "?", query_string)
        full_url <- paste0(base_url, endpoint_with_query)

        # Generate authentication headers
        headers <- await(build_headers("DELETE", endpoint_with_query, NULL, keys))

        # Send DELETE request
        response <- httr::DELETE(
            url = full_url,
            headers,
            httr::timeout(3)
        )

        # Process response
        parsed_response <- process_kucoin_response(response, full_url)
        if (parsed_response$code != "200000") {
            rlang::abort(sprintf("API error: %s - %s", parsed_response$code, parsed_response$msg))
        }

        # Return result as data.table
        result_dt <- data.table::data.table(clientOid = parsed_response$data$clientOid)
        return(result_dt)
    }, error = function(e) {
        rlang::abort(sprintf("Error in cancel_order_by_client_oid_impl: %s", conditionMessage(e)))
    })
})

#' Cancel Partial Order (Implementation)
#'
#' Cancels a specified quantity of a spot order by its order ID on the KuCoin Spot trading system asynchronously.
#' This function sends a cancellation request for the specified size and returns the order ID and canceled size if the request is successfully sent.
#' Note that the actual cancellation status must be checked via order status or WebSocket subscription.
#'
#' ### Description
#' This endpoint cancels a specified quantity of an existing order based on its `orderId`. Unlike full cancellation endpoints, it allows partial cancellation, leaving the remaining order quantity active. The order execution priority (price first, time first) is not affected by this operation.
#'
#' ### Differences from Other Cancellation Functions
#' - **Cancel Order By OrderId**: Cancels the entire order using the order ID.
#' - **Cancel Order By ClientOid**: Cancels the entire order using the client-assigned ID.
#' - **Cancel Partial Order**: Cancels only a specified quantity of the order, useful for reducing order size without full cancellation.
#'
#' ### Workflow
#' 1. **Parameter Validation**: Ensures `orderId`, `symbol`, and `cancelSize` are non-empty strings, with `symbol` being a valid trading pair.
#' 2. **Request Construction**: Builds the API endpoint with `orderId` in the path and `symbol` and `cancelSize` as query parameters.
#' 3. **Authentication**: Generates headers using API credentials via `build_headers()`.
#' 4. **API Request**: Sends a DELETE request to the KuCoin API with a 3-second timeout.
#' 5. **Response Processing**: Parses the response and returns the `orderId` and `cancelSize` if successful.
#'
#' ### API Endpoint
#' `DELETE https://api.kucoin.com/api/v1/hf/orders/cancel/{orderId}?symbol={symbol}&cancelSize={cancelSize}`
#'
#' ### Rate Limit
#' - **Weight**: 2 (higher than full cancellation endpoints, which are typically 1).
#'
#' ### Official Documentation
#' [KuCoin Cancel Partial Order](https://www.kucoin.com/docs-new/rest/spot-trading/orders/cancel-partial-order)
#'
#' @param keys List; API configuration parameters from `get_api_keys()`. Defaults to `get_api_keys()`.
#' @param base_url Character string; base URL for the KuCoin API. Defaults to `get_base_url()`.
#' @param orderId Character string; the unique order ID to partially cancel. Required.
#' @param symbol Character string; the trading pair symbol (e.g., "BTC-USDT"). Required.
#' @param cancelSize Character string; the quantity of the order to cancel (e.g., "0.00001"). Required.
#' @return Promise resolving to a `data.table` containing:
#'   - `orderId` (character): The order ID that was partially canceled.
#'   - `cancelSize` (character): The quantity that was canceled.
#' @examples
#' \dontrun{
#' main_async <- coro::async(function() {
#'   # Partially cancel an order
#'   result <- await(cancel_partial_order_impl(
#'     orderId = "6711f73c1ef16c000717bb31",
#'     symbol = "BTC-USDT",
#'     cancelSize = "0.00001"
#'   ))
#'   print(result)
#' })
#' main_async()
#' while (!later::loop_empty()) later::run_now()
#' }
#' @importFrom coro async await
#' @importFrom data.table data.table
#' @importFrom httr DELETE timeout
#' @importFrom rlang abort
#' @export
cancel_partial_order_impl <- coro::async(function(
    keys = get_api_keys(),
    base_url = get_base_url(),
    orderId,
    symbol,
    cancelSize
) {
    tryCatch({
        # Validate parameters
        if (is.null(orderId) || !is.character(orderId) || nchar(orderId) == 0) {
            rlang::abort("Parameter 'orderId' must be a non-empty string.")
        }
        if (is.null(symbol) || !verify_symbol(symbol)) {
            rlang::abort("Parameter 'symbol' must be a valid ticker (e.g., 'BTC-USDT').")
        }
        if (is.null(cancelSize) || !is.character(cancelSize) || nchar(cancelSize) == 0) {
            rlang::abort("Parameter 'cancelSize' must be a non-empty string.")
        }

        # Construct endpoint and query string
        endpoint <- paste0("/api/v1/hf/orders/cancel/", orderId)
        query_params <- list(symbol = symbol, cancelSize = cancelSize)
        query_string <- build_query(query_params)
        endpoint_with_query <- paste0(endpoint, "?", query_string)
        full_url <- paste0(base_url, endpoint_with_query)

        # Generate authentication headers
        headers <- await(build_headers("DELETE", endpoint_with_query, NULL, keys))

        # Send DELETE request
        response <- httr::DELETE(
            url = full_url,
            headers,
            httr::timeout(3)
        )

        # Process response
        parsed_response <- process_kucoin_response(response, full_url)
        if (parsed_response$code != "200000") {
            rlang::abort(sprintf("API error: %s - %s", parsed_response$code, parsed_response$msg))
        }

        # Return result as data.table
        result_dt <- data.table::data.table(
            orderId = parsed_response$data$orderId,
            cancelSize = parsed_response$data$cancelSize
        )
        return(result_dt)
    }, error = function(e) {
        rlang::abort(sprintf("Error in cancel_partial_order_impl: %s", conditionMessage(e)))
    })
})

#' Cancel All Orders By Symbol (Implementation)
#'
#' Cancels all spot orders for a specified symbol on the KuCoin Spot trading system asynchronously.
#' This endpoint sends a cancellation request for all orders associated with the given symbol and returns a success indicator if the request is accepted.
#' Note that this endpoint only initiates cancellation; the actual status of individual orders must be checked via order status endpoints or WebSocket subscription.
#'
#' @section Description:
#' This function interacts with the KuCoin API endpoint `DELETE /api/v1/hf/orders?symbol={symbol}` to cancel all spot orders for a specific trading pair (e.g., "BTC-USDT").
#' It is useful for quickly canceling multiple orders for a symbol, such as when adjusting trading strategies or managing risk in a specific market.
#'
#' @section Differences from Other Cancellation Endpoints:
#' - **Cancel Order By OrderId**: Targets a single order using its unique order ID.
#' - **Cancel Order By ClientOid**: Targets a single order using a client-assigned ID.
#' - **Cancel Partial Order**: Cancels a portion of a single order.
#' - **Cancel All Orders By Symbol**: Cancels **all** orders for a specified symbol in one request, offering efficiency for bulk cancellations.
#'
#' Use this function when you need to clear all open orders for a trading pair in a single operation.
#'
#' @section Workflow:
#' 1. **Parameter Validation**: Ensures `symbol` is a non-empty string.
#' 2. **Request Construction**: Builds the endpoint URL with `symbol` as a query parameter.
#' 3. **Authentication**: Generates private API headers using the provided `keys`.
#' 4. **API Request**: Sends a DELETE request to the KuCoin API with a 3-second timeout.
#' 5. **Response Processing**: Parses the response and returns a `data.table` with the result if successful.
#'
#' @section API Details:
#' - **Endpoint**: `DELETE https://api.kucoin.com/api/v1/hf/orders?symbol={symbol}`
#' - **Domain**: Spot
#' - **API Channel**: Private
#' - **API Permission**: Spot
#' - **Rate Limit Pool**: Spot
#' - **Rate Limit Weight**: 2
#' - **Official Documentation**: [KuCoin Cancel All Orders By Symbol](https://www.kucoin.com/docs-new/rest/spot-trading/orders/cancel-all-orders-by-symbol)
#'
#' @param keys List; API configuration parameters (e.g., from `get_api_keys()`). Contains API key, secret, and passphrase. Defaults to `get_api_keys()`.
#' @param base_url Character string; base URL for the KuCoin API (e.g., "https://api.kucoin.com"). Defaults to `get_base_url()`.
#' @param symbol Character string; the trading pair symbol (e.g., "BTC-USDT"). Required.
#' @return Promise resolving to a `data.table` with:
#'   - `result` (character): "success" if the cancellation request is accepted.
#' @section Examples:
#' ```r
#' library(coro)
#' library(data.table)
#'
#' main_async <- coro::async(function() {
#'   # Cancel all orders for BTC-USDT
#'   result <- await(cancel_all_orders_by_symbol_impl(sound = "BTC-USDT"))
#'   print(result)
#' })
#'
#' # Run the async function
#' main_async()
#' while (!later::loop_empty()) later::run_now()
#' ```
#' **Expected Output**:
#' ```
#'    result
#' 1: success
#' ```
#'
#' @importFrom coro async await
#' @importFrom data.table data.table
#' @importFrom httr DELETE timeout
#' @importFrom rlang abort
#' @export
cancel_all_orders_by_symbol_impl <- coro::async(function(
    keys = get_api_keys(),
    base_url = get_base_url(),
    symbol
) {
    tryCatch({
        # Validate parameters
        if (is.null(symbol) || !is.character(symbol) || nchar(symbol) == 0) {
            rlang::abort("Parameter 'symbol' must be a non-empty string (e.g., 'BTC-USDT').")
        }

        # Construct endpoint and query string
        endpoint <- "/api/v1/hf/orders"
        query_params <- list(symbol = symbol)
        query_string <- paste0("symbol=", symbol) # Simplified; assumes build_query exists elsewhere
        endpoint_with_query <- paste0(endpoint, "?", query_string)
        full_url <- paste0(base_url, endpoint_with_query)

        # Generate authentication headers (assumes build_headers is defined)
        headers <- await(build_headers("DELETE", endpoint_with_query, NULL, keys))

        # Send DELETE request
        response <- httr::DELETE(
            url = full_url,
            headers,
            httr::timeout(3)
        )

        # Process response (assumes process_kucoin_response is defined)
        parsed_response <- process_kucoin_response(response, full_url)
        if (parsed_response$code != "200000") {
            rlang::abort(sprintf("API error: %s - %s", parsed_response$code, parsed_response$msg))
        }

        # Return result as data.table
        data.table::data.table(result = parsed_response$data)
    }, error = function(e) {
        rlang::abort(sprintf("Error in cancel_all_orders_by_symbol_impl: %s", conditionMessage(e)))
    })
})

#' Cancel All Orders (Implementation)
#'
#' Cancels all spot orders across all symbols on the KuCoin Spot trading system asynchronously.
#' This endpoint sends a cancellation request for all open spot orders and returns a success indicator
#' if the request is accepted. Note that this endpoint only initiates cancellation; the actual
#' status of individual orders must be checked via order status endpoints or WebSocket subscription.
#'
#' @section Description:
#' This function interacts with the KuCoin API endpoint `DELETE /api/v1/hf/orders/cancelAll`
#' to cancel all spot orders for the authenticated account, regardless of symbol. It is useful
#' for quickly clearing all open orders, such as during portfolio rebalancing or emergency stops.
#'
#' @section Differences from Other Cancellation Endpoints:
#' - **Cancel Order By OrderId**: Cancels a single order using its unique order ID.
#' - **Cancel Order By ClientOid**: Cancels a single order using a client-assigned ID.
#' - **Cancel Partial Order**: Cancels a portion of a single order.
#' - **Cancel All Orders By Symbol**: Cancels all orders for a specific symbol.
#' - **Cancel All Orders**: Cancels **all** spot orders across all symbols in one request,
#'   offering maximum efficiency for bulk cancellations.
#'
#' Use this function when you need to terminate all spot trading activity instantly.
#'
#' @section Workflow:
#' 1. **Authentication**: Generates private API headers using the provided `keys`.
#' 2. **API Request**: Sends a DELETE request to the KuCoin API with a 3-second timeout.
#' 3. **Response Processing**: Parses the response and returns successful and failed symbols
#'    if the request is accepted.
#'
#' @section API Details:
#' - **Endpoint**: `DELETE https://api.kucoin.com/api/v1/hf/orders/cancelAll`
#' - **Domain**: Spot
#' - **API Channel**: Private
#' - **API Permission**: Spot
#' - **Rate Limit Pool**: Spot
#' - **Rate Limit Weight**: 30
#' - **SDK Details**: Service: Spot, Sub-service: Order, Method: cancelAllOrders
#' - **Official Documentation**: [KuCoin Cancel All Orders](https://www.kucoin.com/docs-new/rest/spot-trading/orders/cancel-all-orders)
#'
#' @param keys List; API configuration parameters (e.g., from `get_api_keys()`). Contains API key,
#'   secret, passphrase, and key version. Defaults to `get_api_keys()`.
#' @param base_url Character string; base URL for the KuCoin API (e.g., "https://api.kucoin.com").
#'   Defaults to `get_base_url()`.
#' @return Promise resolving to a `data.table` with:
#'   - `succeedSymbols` (character): Vector of symbols for which orders were successfully canceled.
#'   - `failedSymbols` (list): List of objects with `symbol` (character) and `error` (character)
#'     for symbols where cancellation failed.
#' @section Examples:
#' ```r
#' library(coro)
#' library(data.table)
#'
#' main_async <- coro::async(function() {
#'   # Cancel all spot orders
#'   result <- await(cancel_all_orders_impl())
#'   print(result)
#' })
#'
#' # Run the async function
#' main_async()
#' while (!later::loop_empty()) later::run_now()
#' ```
#' **Expected Output**:
#' ```
#'    succeedSymbols failedSymbols
#' 1:    ETH-USDT            []
#' 2:    BTC-USDT            []
#' ```
#'
#' @importFrom coro async await
#' @importFrom data.table data.table
#' @importFrom httr DELETE timeout
#' @importFrom rlang abort
#' @export
cancel_all_orders_impl <- coro::async(function(
    keys = get_api_keys(),
    base_url = get_base_url()
) {
    tryCatch({
        # Construct endpoint
        endpoint <- "/api/v1/hf/orders/cancelAll"
        full_url <- paste0(base_url, endpoint)

        # Generate authentication headers
        headers <- await(build_headers("DELETE", endpoint, NULL, keys))

        # Send DELETE request
        response <- httr::DELETE(
            url = full_url,
            headers,
            httr::timeout(3)
        )

        # Process response
        parsed_response <- process_kucoin_response(response, full_url)
        if (parsed_response$code != "200000") {
            rlang::abort(sprintf("API error: %s - %s", parsed_response$code, parsed_response$msg))
        }

        # Handle failedSymbols as a list of objects
        failed_symbols <- if (length(parsed_response$data$failedSymbols) > 0) {
            lapply(parsed_response$data$failedSymbols, function(x) {
                list(symbol = x$symbol, error = x$error)
            })
        } else {
            list()
        }

        # Return result as data.table
        result_dt <- data.table::data.table(
            succeedSymbols = I(list(parsed_response$data$succeedSymbols)),
            failedSymbols = I(list(failed_symbols))
        )
        return(result_dt)
    }, error = function(e) {
        rlang::abort(sprintf("Error in cancel_all_orders_impl: %s", conditionMessage(e)))
    })
})

# ./impl_spottrading_orders_get_order_by.R

# File: ./R/impl_spottrading_orders_get_order_by.R

# box::use(
#     ./helpers_api[process_kucoin_response, build_headers],
#     ./utils[build_query, get_base_url, verify_symbol, get_api_keys],
#     ./utils_time_convert_kucoin[time_convert_from_kucoin],
#     coro[async, await],
#     data.table[rbindlist, data.table],
#     httr[GET, timeout],
#     rlang[abort]
# )

#' Get Order By OrderId (Implementation)
#'
#' Retrieves detailed information for a single spot order using its order ID from the KuCoin Spot trading system asynchronously.
#' This function returns a `data.table` with comprehensive order details, including additional UTC datetime columns derived from timestamps.
#'
#' ## Description
#' This endpoint fetches data for a specific spot order identified by its `orderId`. The order can be in an active or done state:
#' - **Active Orders**: Orders currently in the order book (check `inOrderBook` to confirm).
#' - **Done Orders**: Orders that are canceled or fully filled (data available only within 3 * 24 hours from the current time).
#'
#' If the order is not active and exceeds the 3 * 24-hour window, the API defaults to querying within that timeframe, potentially returning no data if outside the range.
#'
#' ## Workflow
#' 1. **Parameter Validation**: Ensures `orderId` and `symbol` are non-empty strings, with `symbol` validated as a trading pair.
#' 2. **Request Construction**: Builds the endpoint URL with `orderId` in the path and `symbol` as a query parameter.
#' 3. **Authentication**: Generates private API headers using `build_headers()` with the GET method and endpoint.
#' 4. **API Request**: Sends a GET request to the KuCoin API with a 3-second timeout.
#' 5. **Response Processing**: Parses the response, converts the `data` object to a `data.table`, and adds `createdAtDatetime` and `lastUpdatedAtDatetime` columns.
#'
#' ## API Details
#' - **Endpoint**: `GET https://api.kucoin.com/api/v1/hf/orders/{orderId}?symbol={symbol}`
#' - **Domain**: Spot
#' - **API Channel**: Private
#' - **API Permission**: General
#' - **Rate Limit Pool**: Spot
#' - **Rate Limit Weight**: 2
#' - **SDK Service**: Spot
#' - **SDK Sub-Service**: Order
#' - **SDK Method Name**: getOrderByOrderId
#' - **Official Documentation**: [KuCoin Get Order By OrderId](https://www.kucoin.com/docs-new/rest/spot-trading/orders/get-order-by-orderld)
#'
#' ## Request
#' ### Path Parameters
#' - `orderId`: String (required) - The unique order ID generated by the trading system (e.g., "6717422bd51c29000775ea03").
#'
#' ### Query Parameters
#' - `symbol`: String (required) - The trading pair symbol (e.g., "BTC-USDT").
#'
#' ### Example Request
#' ```bash
#' curl --location --request GET 'https://api.kucoin.com/api/v1/hf/orders/6717422bd51c29000775ea03?symbol=BTC-USDT'
#' ```
#'
#' ## Response
#' ### HTTP Code: 200
#' - **Content Type**: `application/json`
#'
#' ### Data Schema
#' - `code`: String (required) - Response code ("200000" indicates success).
#' - `data`: Object (required) - Order details with the following fields:
#'   - `id`: String (required) - Unique order ID.
#'   - `clientOid`: String (required) - Client-assigned order ID.
#'   - `symbol`: String (required) - Trading pair (e.g., "BTC-USDT").
#'   - `opType`: String (required) - Operation type.
#'   - `type`: Enum<String> (required) - Order type: "limit" or "market".
#'   - `side`: Enum<String> (required) - Order side: "buy" or "sell".
#'   - `price`: String (required) - Order price.
#'   - `size`: String (required) - Order size.
#'   - `funds`: String (required) - Order funds.
#'   - `dealSize`: String (required) - Filled quantity.
#'   - `dealFunds`: String (required) - Filled funds.
#'   - `cancelledSize`: String (required) - Canceled quantity.
#'   - `cancelledFunds`: String (required) - Canceled funds.
#'   - `remainSize`: String (required) - Remaining quantity.
#'   - `remainFunds`: String (required) - Remaining funds.
#'   - `fee`: String (required) - Handling fees.
#'   - `feeCurrency`: String (required) - Fee currency.
#'   - `stp`: Enum<String> (optional) - Self Trade Prevention: "DC", "CO", "CN", "CB".
#'   - `timeInForce`: Enum<String> (required) - Time in force: "GTC", "GTT", "IOC", "FOK".
#'   - `postOnly`: Boolean (required) - Post-only flag.
#'   - `hidden`: Boolean (required) - Hidden order flag.
#'   - `iceberg`: Boolean (required) - Iceberg order flag.
#'   - `visibleSize`: String (required) - Visible size for iceberg orders.
#'   - `cancelAfter`: Integer (required) - Seconds until cancellation for GTT.
#'   - `channel`: String (required) - Order channel.
#'   - `remark`: String (optional) - Order remarks.
#'   - `tags`: String (optional) - Order tags.
#'   - `cancelExist`: Boolean (required) - Indicates a cancellation record.
#'   - `tradeType`: String (required) - Trade type (redundant parameter).
#'   - `inOrderBook`: Boolean (required) - Whether the order is in the order book.
#'   - `active`: Boolean (required) - Order status (true = active, false = done).
#'   - `tax`: String (required) - Tax information (for certain regions).
#'   - `createdAt`: Integer<int64> (required) - Creation timestamp in milliseconds.
#'   - `lastUpdatedAt`: Integer<int64> (required) - Last update timestamp in milliseconds.
#'
#' ### JSON Response Example
#' ```json
#' {
#'   "code": "200000",
#'   "data": {
#'     "id": "6717422bd51c29000775ea03",
#'     "clientOid": "5c52e11203aa677f33e493fb",
#'     "symbol": "BTC-USDT",
#'     "opType": "DEAL",
#'     "type": "limit",
#'     "side": "buy",
#'     "price": "70000",
#'     "size": "0.00001",
#'     "funds": "0.7",
#'     "dealSize": "0.00001",
#'     "dealFunds": "0.677176",
#'     "remainSize": "0",
#'     "remainFunds": "0.022824",
#'     "cancelledSize": "0",
#'     "cancelledFunds": "0",
#'     "fee": "0.000677176",
#'     "feeCurrency": "USDT",
#'     "stp": null,
#'     "timeInForce": "GTC",
#'     "postOnly": false,
#'     "hidden": false,
#'     "iceberg": false,
#'     "visibleSize": "0",
#'     "cancelAfter": 0,
#'     "channel": "API",
#'     "remark": "order remarks",
#'     "tags": null,
#'     "cancelExist": false,
#'     "tradeType": "TRADE",
#'     "inOrderBook": false,
#'     "active": false,
#'     "tax": "0",
#'     "createdAt": 1729577515444,
#'     "lastUpdatedAt": 1729577515481
#'   }
#' }
#' ```
#'
#' @param keys List; API configuration parameters from `get_api_keys()`. Defaults to `get_api_keys()`.
#' @param base_url Character string; base URL for the KuCoin API. Defaults to `get_base_url()`.
#' @param orderId Character string; the unique order ID to retrieve (e.g., "6717422bd51c29000775ea03"). Required.
#' @param symbol Character string; the trading pair symbol (e.g., "BTC-USDT"). Required.
#' @return Promise resolving to a `data.table` with one row containing order details, including:
#'   - `id` (character): Unique order ID.
#'   - `clientOid` (character): Client-assigned order ID.
#'   - `symbol` (character): Trading pair.
#'   - `opType` (character): Operation type.
#'   - `type` (character): Order type ("limit" or "market").
#'   - `side` (character): Order side ("buy" or "sell").
#'   - `price` (character): Order price.
#'   - `size` (character): Order size.
#'   - `funds` (character): Order funds.
#'   - `dealSize` (character): Filled quantity.
#'   - `dealFunds` (character): Filled funds.
#'   - `cancelledSize` (character): Canceled quantity.
#'   - `cancelledFunds` (character): Canceled funds.
#'   - `remainSize` (character): Remaining quantity.
#'   - `remainFunds` (character): Remaining funds.
#'   - `fee` (character): Handling fees.
#'   - `feeCurrency` (character): Fee currency.
#'   - `stp` (character or NA): Self Trade Prevention strategy.
#'   - `timeInForce` (character): Time in force.
#'   - `postOnly` (logical): Post-only flag.
#'   - `hidden` (logical): Hidden order flag.
#'   - `iceberg` (logical): Iceberg order flag.
#'   - `visibleSize` (character): Visible size for iceberg orders.
#'   - `cancelAfter` (integer): Seconds until cancellation for GTT.
#'   - `channel` (character): Order channel.
#'   - `remark` (character or NA): Order remarks.
#'   - `tags` (character or NA): Order tags.
#'   - `cancelExist` (logical): Indicates a cancellation record.
#'   - `tradeType` (character): Trade type.
#'   - `inOrderBook` (logical): Whether in the order book.
#'   - `active` (logical): Order status (true = active, false = done).
#'   - `tax` (character): Tax information.
#'   - `createdAt` (integer): Creation timestamp (milliseconds).
#'   - `lastUpdatedAt` (integer): Last update timestamp (milliseconds).
#'   - `createdAtDatetime` (POSIXct): Creation time in UTC.
#'   - `lastUpdatedAtDatetime` (POSIXct): Last update time in UTC.
#' @examples
#' \dontrun{
#' library(coro)
#' library(data.table)
#'
#' main_async <- coro::async(function() {
#'   # Retrieve order details
#'   order_details <- await(get_order_by_order_id_impl(
#'     orderId = "6717422bd51c29000775ea03",
#'     symbol = "BTC-USDT"
#'   ))
#'   print(order_details)
#' })
#'
#' # Run the async function
#' main_async()
#' while (!later::loop_empty()) later::run_now()
#' }
#'
#' # Expected Output (simplified):
#' #    id                    clientOid symbol opType type  side price size  ... createdAtDatetime   lastUpdatedAtDatetime
#' # 1: 6717422bd51c29000775ea03 5c52e11203aa677f33e493fb BTC-USDT DEAL limit buy  70000 0.00001 ... 2023-10-22 03:31:55 2023-10-22 03:31:55
#' @importFrom coro async await
#' @importFrom data.table rbindlist data.table
#' @importFrom httr GET timeout
#' @importFrom rlang abort
#' @export
get_order_by_order_id_impl <- coro::async(function(
    keys = get_api_keys(),
    base_url = get_base_url(),
    orderId,
    symbol
) {
    tryCatch({
        # Validate parameters
        if (is.null(orderId) || !is.character(orderId) || nchar(orderId) == 0) {
            rlang::abort("Parameter 'orderId' must be a non-empty string.")
        }
        if (is.null(symbol) || !verify_symbol(symbol)) {
            rlang::abort("Parameter 'symbol' must be a valid ticker (e.g., 'BTC-USDT').")
        }

        # Construct endpoint and query string
        endpoint <- paste0("/api/v1/hf/orders/", orderId)
        query_params <- list(symbol = symbol)
        query_string <- build_query(query_params)
        endpoint_with_query <- paste0(endpoint, query_string)
        full_url <- paste0(base_url, endpoint_with_query)

        # Generate authentication headers
        headers <- await(build_headers("GET", endpoint_with_query, NULL, keys))

        # Send GET request
        response <- httr::GET(
            url = full_url,
            headers,
            httr::timeout(3)
        )

        # Process response
        parsed_response <- process_kucoin_response(response, full_url)
        if (parsed_response$code != "200000") {
            rlang::abort(sprintf("API error: %s - %s", parsed_response$code, parsed_response$msg))
        }

        # Convert response data to data.table
        order_details <- data.table::rbindlist(list(parsed_response$data), fill = TRUE)

        # Add datetime columns from millisecond timestamps
        order_details[, createdAtDatetime := time_convert_from_kucoin(createdAt, unit = "ms")]
        order_details[, lastUpdatedAtDatetime := time_convert_from_kucoin(lastUpdatedAt, unit = "ms")]

        return(order_details)
    }, error = function(e) {
        rlang::abort(sprintf("Error in get_order_by_order_id_impl: %s", conditionMessage(e)))
    })
})

#' Get Order By ClientOid (Implementation)
#'
#' Retrieves detailed information for a single spot order using its client order ID (clientOid) from the KuCoin Spot trading system asynchronously.
#' This function returns a `data.table` with comprehensive order details, including additional UTC datetime columns derived from timestamps.
#'
#' ## Description
#' This endpoint fetches data for a specific spot order identified by its `clientOid`, a unique identifier assigned by the user when placing the order.
#' The order can be in an active or done state:
#' - **Active Orders**: Orders currently in the order book (check `inOrderBook` to confirm).
#' - **Done Orders**: Orders that are canceled or fully filled (data available only within 3 * 24 hours from the current time).
#'
#' If the order is not active and exceeds the 3 * 24-hour window, the API defaults to querying within that timeframe, potentially returning no data if outside the range.
#'
#' ## Differences from Get Order By OrderId
#' - **Get Order By OrderId**: Uses the KuCoin-generated `orderId` to retrieve order details, suitable when tracking orders via system-assigned IDs.
#' - **Get Order By ClientOid**: Uses the user-assigned `clientOid`, ideal when managing orders with custom identifiers without needing to map to KuCoin’s IDs.
#'
#' Choose this method if you track orders using your own identifiers.
#'
#' ## Workflow
#' 1. **Parameter Validation**: Ensures `clientOid` and `symbol` are non-empty strings, with `symbol` validated as a trading pair.
#' 2. **Request Construction**: Builds the endpoint URL with `clientOid` in the path and `symbol` as a query parameter.
#' 3. **Authentication**: Generates private API headers using `build_headers()` with the GET method and endpoint.
#' 4. **API Request**: Sends a GET request to the KuCoin API with a 3-second timeout.
#' 5. **Response Processing**: Parses the response, converts the `data` object to a `data.table`, and adds `createdAtDatetime` and `lastUpdatedAtDatetime` columns.
#'
#' ## API Details
#' - **Endpoint**: `GET https://api.kucoin.com/api/v1/hf/orders/client-order/{clientOid}?symbol={symbol}`
#' - **Domain**: Spot
#' - **API Channel**: Private
#' - **API Permission**: General
#' - **Rate Limit Pool**: Spot
#' - **Rate Limit Weight**: 2
#' - **SDK Service**: Spot
#' - **SDK Sub-Service**: Order
#' - **SDK Method Name**: getOrderByClientOid
#' - **Official Documentation**: [KuCoin Get Order By ClientOid](https://www.kucoin.com/docs-new/rest/spot-trading/orders/get-order-by-clientoid)
#'
#' ## Request
#' ### Path Parameters
#' - `clientOid`: String (required) - The unique client order ID created by the user (e.g., "5c52e11203aa677f33e493fb").
#'
#' ### Query Parameters
#' - `symbol`: String (required) - The trading pair symbol (e.g., "BTC-USDT").
#'
#' ### Example Request
#' ```bash
#' curl --location --request GET 'https://api.kucoin.com/api/v1/hf/orders/client-order/5c52e11203aa677f33e493fb?symbol=BTC-USDT'
#' ```
#'
#' ## Response
#' ### HTTP Code: 200
#' - **Content Type**: `application/json`
#'
#' ### Data Schema
#' - `code`: String (required) - Response code ("200000" indicates success).
#' - `data`: Object (required) - Order details with the following fields:
#'   - `id`: String (required) - Unique order ID generated by the trading system.
#'   - `clientOid`: String (required) - Client-assigned order ID.
#'   - `symbol`: String (required) - Trading pair (e.g., "BTC-USDT").
#'   - `opType`: String (required) - Operation type.
#'   - `type`: Enum<String> (required) - Order type: "limit" or "market".
#'   - `side`: Enum<String> (required) - Order side: "buy" or "sell".
#'   - `price`: String (required) - Order price.
#'   - `size`: String (required) - Order size.
#'   - `funds`: String (required) - Order funds.
#'   - `dealSize`: String (required) - Filled quantity.
#'   - `dealFunds`: String (required) - Filled funds.
#'   - `cancelledSize`: String (required) - Canceled quantity.
#'   - `cancelledFunds`: String (required) - Canceled funds.
#'   - `remainSize`: String (required) - Remaining quantity.
#'   - `remainFunds`: String (required) - Remaining funds.
#'   - `fee`: String (required) - Handling fees.
#'   - `feeCurrency`: String (required) - Fee currency.
#'   - `stp`: Enum<String> (optional) - Self Trade Prevention: "DC", "CO", "CN", "CB".
#'   - `timeInForce`: Enum<String> (required) - Time in force: "GTC", "GTT", "IOC", "FOK".
#'   - `postOnly`: Boolean (required) - Post-only flag.
#'   - `hidden`: Boolean (required) - Hidden order flag.
#'   - `iceberg`: Boolean (required) - Iceberg order flag.
#'   - `visibleSize`: String (required) - Visible size for iceberg orders.
#'   - `cancelAfter`: Integer (required) - Seconds until cancellation for GTT.
#'   - `channel`: String (required) - Order channel.
#'   - `remark`: String (optional) - Order remarks.
#'   - `tags`: String (optional) - Order tags.
#'   - `cancelExist`: Boolean (required) - Indicates a cancellation record.
#'   - `tradeType`: String (required) - Trade type (redundant parameter).
#'   - `inOrderBook`: Boolean (required) - Whether the order is in the order book.
#'   - `active`: Boolean (required) - Order status (true = active, false = done).
#'   - `tax`: String (required) - Tax information (for certain regions).
#'   - `createdAt`: Integer<int64> (required) - Creation timestamp in milliseconds.
#'   - `lastUpdatedAt`: Integer<int64> (required) - Last update timestamp in milliseconds.
#'
#' ### JSON Response Example
#' ```json
#' {
#'   "code": "200000",
#'   "data": {
#'     "id": "6717422bd51c29000775ea03",
#'     "clientOid": "5c52e11203aa677f33e493fb",
#'     "symbol": "BTC-USDT",
#'     "opType": "DEAL",
#'     "type": "limit",
#'     "side": "buy",
#'     "price": "70000",
#'     "size": "0.00001",
#'     "funds": "0.7",
#'     "dealSize": "0.00001",
#'     "dealFunds": "0.677176",
#'     "remainSize": "0",
#'     "remainFunds": "0.022824",
#'     "cancelledSize": "0",
#'     "cancelledFunds": "0",
#'     "fee": "0.000677176",
#'     "feeCurrency": "USDT",
#'     "stp": null,
#'     "timeInForce": "GTC",
#'     "postOnly": false,
#'     "hidden": false,
#'     "iceberg": false,
#'     "visibleSize": "0",
#'     "cancelAfter": 0,
#'     "channel": "API",
#'     "remark": "order remarks",
#'     "tags": null,
#'     "cancelExist": false,
#'     "tradeType": "TRADE",
#'     "inOrderBook": false,
#'     "active": false,
#'     "tax": "0",
#'     "createdAt": 1729577515444,
#'     "lastUpdatedAt": 1729577515481
#'   }
#' }
#' ```
#'
#' @param keys List; API configuration parameters from `get_api_keys()`. Defaults to `get_api_keys()`.
#' @param base_url Character string; base URL for the KuCoin API. Defaults to `get_base_url()`.
#' @param clientOid Character string; the unique client order ID to retrieve (e.g., "5c52e11203aa677f33e493fb"). Required.
#' @param symbol Character string; the trading pair symbol (e.g., "BTC-USDT"). Required.
#' @return Promise resolving to a `data.table` with one row containing order details, including:
#'   - `id` (character): Unique order ID.
#'   - `clientOid` (character): Client-assigned order ID.
#'   - `symbol` (character): Trading pair.
#'   - `opType` (character): Operation type.
#'   - `type` (character): Order type ("limit" or "market").
#'   - `side` (character): Order side ("buy" or "sell").
#'   - `price` (character): Order price.
#'   - `size` (character): Order size.
#'   - `funds` (character): Order funds.
#'   - `dealSize` (character): Filled quantity.
#'   - `dealFunds` (character): Filled funds.
#'   - `cancelledSize` (character): Canceled quantity.
#'   - `cancelledFunds` (character): Canceled funds.
#'   - `remainSize` (character): Remaining quantity.
#'   - `remainFunds` (character): Remaining funds.
#'   - `fee` (character): Handling fees.
#'   - `feeCurrency` (character): Fee currency.
#'   - `stp` (character or NA): Self Trade Prevention strategy.
#'   - `timeInForce` (character): Time in force.
#'   - `postOnly` (logical): Post-only flag.
#'   - `hidden` (logical): Hidden order flag.
#'   - `iceberg` (logical): Iceberg order flag.
#'   - `visibleSize` (character): Visible size for iceberg orders.
#'   - `cancelAfter` (integer): Seconds until cancellation for GTT.
#'   - `channel` (character): Order channel.
#'   - `remark` (character or NA): Order remarks.
#'   - `tags` (character or NA): Order tags.
#'   - `cancelExist` (logical): Indicates a cancellation record.
#'   - `tradeType` (character): Trade type.
#'   - `inOrderBook` (logical): Whether in the order book.
#'   - `active` (logical): Order status (true = active, false = done).
#'   - `tax` (character): Tax information.
#'   - `createdAt` (integer): Creation timestamp (milliseconds).
#'   - `lastUpdatedAt` (integer): Last update timestamp (milliseconds).
#'   - `createdAtDatetime` (POSIXct): Creation time in UTC.
#'   - `lastUpdatedAtDatetime` (POSIXct): Last update time in UTC.
#' @examples
#' \dontrun{
#' library(coro)
#' library(data.table)
#'
#' main_async <- coro::async(function() {
#'   # Retrieve order details by clientOid
#'   order_details <- await(get_order_by_client_oid_impl(
#'     clientOid = "5c52e11203aa677f33e493fb",
#'     symbol = "BTC-USDT"
#'   ))
#'   print(order_details)
#' })
#'
#' # Run the async function
#' main_async()
#' while (!later::loop_empty()) later::run_now()
#' }
#'
#' # Expected Output (simplified):
#' #    id                    clientOid symbol opType type  side price size  ... createdAtDatetime   lastUpdatedAtDatetime
#' # 1: 6717422bd51c29000775ea03 5c52e11203aa677f33e493fb BTC-USDT DEAL limit buy  70000 0.00001 ... 2023-10-22 03:31:55 2023-10-22 03:31:55
#' @importFrom coro async await
#' @importFrom data.table rbindlist data.table
#' @importFrom httr GET timeout
#' @importFrom rlang abort
#' @export
get_order_by_client_oid_impl <- coro::async(function(
    keys = get_api_keys(),
    base_url = get_base_url(),
    clientOid,
    symbol
) {
    tryCatch({
        # Validate parameters
        if (is.null(clientOid) || !is.character(clientOid) || nchar(clientOid) == 0) {
            rlang::abort("Parameter 'clientOid' must be a non-empty string.")
        }
        if (is.null(symbol) || !verify_symbol(symbol)) {
            rlang::abort("Parameter 'symbol' must be a valid ticker (e.g., 'BTC-USDT').")
        }

        # Construct endpoint and query string
        endpoint <- paste0("/api/v1/hf/orders/client-order/", clientOid)
        query_params <- list(symbol = symbol)
        query_string <- build_query(query_params)
        endpoint_with_query <- paste0(endpoint, query_string)
        full_url <- paste0(base_url, endpoint_with_query)

        # Generate authentication headers
        headers <- await(build_headers("GET", endpoint_with_query, NULL, keys))

        # Send GET request
        response <- httr::GET(
            url = full_url,
            headers,
            httr::timeout(3)
        )

        # Process response
        parsed_response <- process_kucoin_response(response, full_url)
        if (parsed_response$code != "200000") {
            rlang::abort(sprintf("API error: %s - %s", parsed_response$code, parsed_response$msg))
        }

        # Convert response data to data.table
        order_details <- data.table::rbindlist(list(parsed_response$data), fill = TRUE)

        # Add datetime columns from millisecond timestamps
        order_details[, createdAtDatetime := time_convert_from_kucoin(createdAt, unit = "ms")]
        order_details[, lastUpdatedAtDatetime := time_convert_from_kucoin(lastUpdatedAt, unit = "ms")]

        return(order_details)
    }, error = function(e) {
        rlang::abort(sprintf("Error in get_order_by_client_oid_impl: %s", conditionMessage(e)))
    })
})

# ./impl_spottrading_orders_get_trade_history.R

# File: ./R/impl_spottrading_orders_get_trade_history.R

# box::use(
#     ./helpers_api[process_kucoin_response, build_headers],
#     ./utils[build_query, get_base_url, verify_symbol, get_api_keys],
#     ./utils_time_convert_kucoin[time_convert_from_kucoin],
#     coro[async, await],
#     data.table[rbindlist, data.table],
#     httr[GET, timeout],
#     rlang[abort],
#     purrr[map_dfr]
# )

#' Get Trade History (Implementation)
#'
#' Retrieves a list of the latest spot transaction details (fills) for a specified symbol or orderId from the KuCoin Spot trading system asynchronously.
#' This function returns a `data.table` with detailed information about each fill, sorted by the latest update time in descending order.
#'
#' ## Description
#' This endpoint fetches the latest transaction details (fills) for a given trading pair or specific order. The data is sorted in descending order based on the update time of the order.
#' If `orderId` is provided, it overrides other query parameters except for `lastId`, `limit`, `startAt`, and `endAt`.
#'
#' ## Workflow
#' 1. **Parameter Validation**: Ensures `symbol` is a valid trading pair if `orderId` is not provided. Validates optional parameters.
#' 2. **Request Construction**: Builds the endpoint URL with query parameters.
#' 3. **Authentication**: Generates private API headers using `build_headers()` with the GET method and endpoint.
#' 4. **API Request**: Sends a GET request to the KuCoin API with a 3-second timeout.
#' 5. **Response Processing**: Parses the response, converts the `items` array to a `data.table`, and adds a `createdAtDatetime` column.
#'
#' ## API Details
#' - **Endpoint**: `GET https://api.kucoin.com/api/v1/hf/fills`
#' - **Domain**: Spot
#' - **API Channel**: Private
#' - **API Permission**: General
#' - **Rate Limit Pool**: Spot
#' - **Rate Limit Weight**: 2
#' - **SDK Service**: Spot
#' - **SDK Sub-Service**: Order
#' - **SDK Method Name**: getTradeHistory
#' - **Official Documentation**: [KuCoin Get Trade History](https://www.kucoin.com/docs-new/rest/spot-trading/orders/get-trade-history)
#'
#' ## Request
#' ### Query Parameters
#' - `symbol`: String (required if `orderId` is not provided) - The trading pair symbol (e.g., "BTC-USDT").
#' - `orderId`: String (optional) - The unique order ID. If provided, other parameters (except `lastId`, `limit`, `startAt`, `endAt`) are ignored.
#' - `side`: Enum<String> (optional) - Order side: "buy" or "sell".
#' - `type`: Enum<String> (optional) - Order type: "limit" or "market".
#' - `lastId`: Integer<int64> (optional) - The ID of the last fill from the previous batch for pagination.
#' - `limit`: Integer (optional) - Number of fills per page (1 to 100, default 20).
#' - `startAt`: Integer<int64> (optional) - Start time in milliseconds.
#' - `endAt`: Integer<int64> (optional) - End time in milliseconds.
#'
#' ### Example Request
#' ```bash
#' curl --location --request GET 'https://api.kucoin.com/api/v1/hf/fills?symbol=BTC-USDT&limit=100&startAt=1728663338000&endAt=1728692138000'
#' ```
#'
#' ## Response
#' ### HTTP Code: 200
#' - **Content Type**: `application/json`
#'
#' ### Data Schema
#' - `code`: String (required) - Response code ("200000" indicates success).
#' - `data`: Object (required) - Contains:
#'   - `lastId`: Integer<int64> (required) - The ID of the last fill in the current batch.
#'   - `items`: Array of objects (required) - List of fill details, each with:
#'     - `id`: Integer<int64> - Fill ID.
#'     - `orderId`: String - Order ID.
#'     - `counterOrderId`: String - Counterparty order ID.
#'     - `tradeId`: Integer<int64> - Trade ID.
#'     - `symbol`: String - Trading pair.
#'     - `side`: Enum<String> - "buy" or "sell".
#'     - `liquidity`: Enum<String> - "taker" or "maker".
#'     - `type`: Enum<String> - "limit" or "market".
#'     - `forceTaker`: Boolean - Whether the order was forced to take liquidity.
#'     - `price`: String - Fill price.
#'     - `size`: String - Fill size.
#'     - `funds`: String - Funds involved in the fill.
#'     - `fee`: String - Handling fees.
#'     - `feeRate`: String - Fee rate.
#'     - `feeCurrency`: String - Fee currency.
#'     - `stop`: String - Stop type (currently empty for HFT).
#'     - `tradeType`: String - Trade type.
#'     - `taxRate`: String - Tax rate.
#'     - `tax`: String - Tax amount.
#'     - `createdAt`: Integer<int64> - Fill timestamp in milliseconds.
#'
#' ### JSON Response Example
#' ```json
#' {
#'   "code": "200000",
#'   "data": {
#'     "items": [
#'       {
#'         "id": 19814995255305,
#'         "orderId": "6717422bd51c29000775ea03",
#'         "counterOrderId": "67174228135f9e000709da8c",
#'         "tradeId": 11029373945659392,
#'         "symbol": "BTC-USDT",
#'         "side": "buy",
#'         "liquidity": "taker",
#'         "type": "limit",
#'         "forceTaker": false,
#'         "price": "67717.6",
#'         "size": "0.00001",
#'         "funds": "0.677176",
#'         "fee": "0.000677176",
#'         "feeRate": "0.001",
#'         "feeCurrency": "USDT",
#'         "stop": "",
#'         "tradeType": "TRADE",
#'         "taxRate": "0",
#'         "tax": "0",
#'         "createdAt": 1729577515473
#'       }
#'     ],
#'     "lastId": 19814995255305
#'   }
#' }
#' ```
#'
#' @param keys List; API configuration parameters from `get_api_keys()`. Defaults to `get_api_keys()`.
#' @param base_url Character string; base URL for the KuCoin API. Defaults to `get_base_url()`.
#' @param symbol Character string; the trading pair symbol (e.g., "BTC-USDT"). Required if `orderId` is not provided.
#' @param orderId Character string; the unique order ID. If provided, other parameters are ignored except for pagination and time filters.
#' @param side Character string; optional filter for order side: "buy" or "sell".
#' @param type Character string; optional filter for order type: "limit" or "market".
#' @param lastId Integer; optional ID of the last fill for pagination.
#' @param limit Integer; number of fills to return per request (1–100, default 20).
#' @param startAt Integer; optional start time in milliseconds.
#' @param endAt Integer; optional end time in milliseconds.
#' @return Promise resolving to a `data.table` with columns corresponding to the fill fields, including:
#'   - `id` (integer): Fill ID.
#'   - `orderId` (character): Order ID.
#'   - `counterOrderId` (character): Counterparty order ID.
#'   - `tradeId` (integer): Trade ID.
#'   - `symbol` (character): Trading pair.
#'   - `side` (character): "buy" or "sell".
#'   - `liquidity` (character): "taker" or "maker".
#'   - `type` (character): "limit" or "market".
#'   - `forceTaker` (logical): Whether forced to take liquidity.
#'   - `price` (character): Fill price.
#'   - `size` (character): Fill size.
#'   - `funds` (character): Funds involved.
#'   - `fee` (character): Handling fees.
#'   - `feeRate` (character): Fee rate.
#'   - `feeCurrency` (character): Fee currency.
#'   - `stop` (character): Stop type.
#'   - `tradeType` (character): Trade type.
#'   - `taxRate` (character): Tax rate.
#'   - `tax` (character): Tax amount.
#'   - `createdAt` (integer): Fill timestamp (milliseconds).
#'   - `createdAtDatetime` (POSIXct): Fill time in UTC.
#' @examples
#' \dontrun{
#' library(coro)
#' library(data.table)
#'
#' main_async <- coro::async(function() {
#'   # Retrieve trade history for BTC-USDT
#'   trade_history <- await(get_trade_history_impl(
#'     symbol = "BTC-USDT",
#'     limit = 50
#'   ))
#'   print(trade_history)
#' })
#'
#' # Run the async function
#' main_async()
#' while (!later::loop_empty()) later::run_now()
#' }
#' @importFrom coro async await
#' @importFrom data.table rbindlist data.table
#' @importFrom httr GET timeout
#' @importFrom rlang abort
#' @export
get_trade_history_impl <- coro::async(function(
    keys = get_api_keys(),
    base_url = get_base_url(),
    symbol = NULL,
    orderId = NULL,
    side = NULL,
    type = NULL,
    lastId = NULL,
    limit = 20,
    startAt = NULL,
    endAt = NULL
) {
    tryCatch({
        # Validate parameters
        if (is.null(orderId)) {
            if (is.null(symbol) || !verify_symbol(symbol)) {
                rlang::abort("Parameter 'symbol' must be a valid ticker (e.g., 'BTC-USDT') when 'orderId' is not provided.")
            }
        }
        if (!is.null(limit) && (!is.integer(limit) || limit < 1 || limit > 100)) {
            rlang::abort("Parameter 'limit' must be an integer between 1 and 100.")
        }

        # Construct query parameters
        query_params <- list()
        if (!is.null(orderId)) {
            query_params$orderId <- orderId
        } else {
            query_params$symbol <- symbol
            if (!is.null(side)) query_params$side <- side
            if (!is.null(type)) query_params$type <- type
        }
        if (!is.null(lastId)) query_params$lastId <- lastId
        if (!is.null(limit)) query_params$limit <- limit
        if (!is.null(startAt)) query_params$startAt <- startAt
        if (!is.null(endAt)) query_params$endAt <- endAt

        # Build query string
        query_string <- build_query(query_params)
        endpoint <- "/api/v1/hf/fills"
        full_url <- paste0(base_url, endpoint, query_string)

        # Generate authentication headers
        headers <- await(build_headers("GET", endpoint, query_string, keys))

        # Send GET request
        response <- httr::GET(
            url = full_url,
            headers,
            httr::timeout(3)
        )

        # Process response
        parsed_response <- process_kucoin_response(response, full_url)
        if (parsed_response$code != "200000") {
            rlang::abort(sprintf("API error: %s - %s", parsed_response$code, parsed_response$msg))
        }

        # Convert response data to data.table
        if (length(parsed_response$data$items) == 0) {
            fills_dt <- data.table::data.table(
                id = integer(),
                orderId = character(),
                counterOrderId = character(),
                tradeId = integer(),
                symbol = character(),
                side = character(),
                liquidity = character(),
                type = character(),
                forceTaker = logical(),
                price = character(),
                size = character(),
                funds = character(),
                fee = character(),
                feeRate = character(),
                feeCurrency = character(),
                stop = character(),
                tradeType = character(),
                taxRate = character(),
                tax = character(),
                createdAt = integer(),
                createdAtDatetime = as.POSIXct(character())
            )
        } else {
            fills_dt <- data.table::rbindlist(parsed_response$data$items, fill = TRUE)
            fills_dt[, createdAtDatetime := time_convert_from_kucoin(createdAt, unit = "ms")]
        }

        return(fills_dt)
    }, error = function(e) {
        rlang::abort(sprintf("Error in get_trade_history_impl: %s", conditionMessage(e)))
    })
})

# ./impl_spottrading_orders_get_x.R

# File: ./R/impl_spottrading_orders_get_x.R

# box::use(
#     ./helpers_api[process_kucoin_response, build_headers],
#     ./utils[get_base_url, verify_symbol, get_api_keys],
#     coro[async, await],
#     data.table[rbindlist, data.table],
#     httr[GET, timeout],
#     rlang[abort]
# )

#' Get Symbols With Open Order (Implementation)
#'
#' Retrieves a list of spot trading symbols with active orders from the KuCoin Spot trading system asynchronously.
#' This function returns a `data.table` containing the symbols that currently have open orders.
#'
#' ## Description
#' This endpoint queries all trading pair symbols (e.g., "BTC-USDT", "ETH-USDT") that have active orders for the authenticated account.
#' An active order is one that is currently in the order book and has not been fully filled or canceled.
#' This is useful for monitoring which markets have ongoing trading activity for the user.
#'
#' ## Workflow
#' 1. **Request Construction**: Builds the endpoint URL with no additional parameters since none are required.
#' 2. **Authentication**: Generates private API headers using `build_headers()` with the GET method and endpoint.
#' 3. **API Request**: Sends a GET request to the KuCoin API with a 3-second timeout.
#' 4. **Response Processing**: Parses the response and converts the `symbols` array within the `data` object to a `data.table`.
#'
#' ## API Details
#' - **Endpoint**: `GET https://api.kucoin.com/api/v1/hf/orders/active/symbols`
#' - **Domain**: Spot
#' - **API Channel**: Private
#' - **API Permission**: Spot
#' - **Rate Limit Pool**: Spot
#' - **Rate Limit Weight**: 2
#' - **SDK Service**: Spot
#' - **SDK Sub-Service**: Order
#' - **SDK Method Name**: getSymbolsWithOpenOrder
#' - **Official Documentation**: [KuCoin Get Symbols With Open Order](https://www.kucoin.com/docs-new/rest/spot-trading/orders/get-symbols-with-open-order)
#'
#' ## Request
#' ### Path Parameters
#' - None
#'
#' ### Query Parameters
#' - None
#'
#' ### Example Request
#' ```bash
#' curl --location --request GET 'https://api.kucoin.com/api/v1/hf/orders/active/symbols'
#' ```
#'
#' ## Response
#' ### HTTP Code: 200
#' - **Content Type**: `application/json`
#'
#' ### Data Schema
#' - `code`: String (required) - Response code ("200000" indicates success).
#' - `data`: Object (required) - Contains the following field:
#'   - `symbols`: Array[String] (required) - List of trading pair symbols with active orders (e.g., "ETH-USDT", "BTC-USDT").
#'
#' ### JSON Response Example
#' ```json
#' {
#'   "code": "200000",
#'   "data": {
#'     "symbols": [
#'       "ETH-USDT",
#'       "BTC-USDT"
#'     ]
#'   }
#' }
#' ```
#'
#' @param keys List; API configuration parameters from `get_api_keys()`. Defaults to `get_api_keys()`.
#' @param base_url Character string; base URL for the KuCoin API. Defaults to `get_base_url()`.
#' @return Promise resolving to a `data.table` with one column:
#'   - `symbols` (character): Vector of trading pair symbols with active orders.
#' @examples
#' \dontrun{
#' library(coro)
#' library(data.table)
#'
#' main_async <- coro::async(function() {
#'   # Retrieve symbols with open orders
#'   active_symbols <- await(get_symbols_with_open_order_impl())
#'   print(active_symbols)
#' })
#'
#' # Run the async function
#' main_async()
#' while (!later::loop_empty()) later::run_now()
#' }
#'
#' # Expected Output (example):
#' #    symbols
#' # 1: ETH-USDT
#' # 2: BTC-USDT
#' @importFrom coro async await
#' @importFrom data.table data.table
#' @importFrom httr GET timeout
#' @importFrom rlang abort
#' @export
get_symbols_with_open_order_impl <- coro::async(function(
    keys = get_api_keys(),
    base_url = get_base_url()
) {
    tryCatch({
        # Construct endpoint
        endpoint <- "/api/v1/hf/orders/active/symbols"
        full_url <- paste0(base_url, endpoint)

        # Generate authentication headers
        headers <- await(build_headers("GET", endpoint, NULL, keys))

        # Send GET request
        response <- httr::GET(
            url = full_url,
            headers,
            httr::timeout(3)
        )

        # Process response
        parsed_response <- process_kucoin_response(response, full_url)
        if (parsed_response$code != "200000") {
            rlang::abort(sprintf("API error: %s - %s", parsed_response$code, parsed_response$msg))
        }

        # Convert response data to data.table
        # If no symbols, return an empty data.table with the correct column
        if (length(parsed_response$data$symbols) == 0) {
            result_dt <- data.table::data.table(symbols = character())
        } else {
            result_dt <- data.table::data.table(symbols = parsed_response$data$symbols)
        }

        return(result_dt)
    }, error = function(e) {
        rlang::abort(sprintf("Error in get_symbols_with_open_order_impl: %s", conditionMessage(e)))
    })
})

#' Get Open Orders (Implementation)
#'
#' Retrieves all active spot orders for a specified symbol from the KuCoin Spot trading system asynchronously.
#' This function returns a `data.table` with detailed information about each active order, sorted by the latest update time in descending order.
#'
#' ## Description
#' This endpoint fetches all active orders for a given trading pair (e.g., "BTC-USDT"). Active orders are those currently in the order book and not fully filled or canceled.
#' The orders are returned in descending order based on their last update time.
#'
#' ## Workflow
#' 1. **Parameter Validation**: Ensures `symbol` is a non-empty string and a valid trading pair.
#' 2. **Request Construction**: Builds the endpoint URL with `symbol` as a query parameter.
#' 3. **Authentication**: Generates private API headers using `build_headers()` with the GET method and endpoint.
#' 4. **API Request**: Sends a GET request to the KuCoin API with a 3-second timeout.
#' 5. **Response Processing**: Parses the response, converts the array of orders to a `data.table`, and adds `createdAtDatetime` and `lastUpdatedAtDatetime` columns.
#'
#' ## API Details
#' - **Endpoint**: `GET https://api.kucoin.com/api/v1/hf/orders/active?symbol={symbol}`
#' - **Domain**: Spot
#' - **API Channel**: Private
#' - **API Permission**: General
#' - **Rate Limit Pool**: Spot
#' - **Rate Limit Weight**: 2
#' - **SDK Service**: Spot
#' - **SDK Sub-Service**: Order
#' - **SDK Method Name**: getOpenOrders
#' - **Official Documentation**: [KuCoin Get Open Orders](https://www.kucoin.com/docs-new/rest/spot-trading/orders/get-open-orders)
#'
#' ## Request
#' ### Query Parameters
#' - `symbol`: String (required) - The trading pair symbol (e.g., "BTC-USDT").
#'
#' ### Example Request
#' ```bash
#' curl --location --request GET 'https://api.kucoin.com/api/v1/hf/orders/active?symbol=BTC-USDT'
#' ```
#'
#' ## Response
#' ### HTTP Code: 200
#' - **Content Type**: `application/json`
#'
#' ### Data Schema
#' - `code`: String (required) - Response code ("200000" indicates success).
#' - `data`: Array of objects (required) - List of active orders, each with fields such as:
#'   - `id`: String - Unique order ID.
#'   - `clientOid`: String - Client-assigned order ID.
#'   - `symbol`: String - Trading pair.
#'   - `opType`: String - Operation type.
#'   - `type`: Enum<String> - Order type: "limit" or "market".
#'   - `side`: Enum<String> - Order side: "buy" or "sell".
#'   - `price`: String - Order price.
#'   - `size`: String - Order size.
#'   - `funds`: String - Order funds.
#'   - `dealSize`: String - Filled quantity.
#'   - `dealFunds`: String - Filled funds.
#'   - `cancelledSize`: String - Canceled quantity.
#'   - `cancelledFunds`: String - Canceled funds.
#'   - `remainSize`: String - Remaining quantity.
#'   - `remainFunds`: String - Remaining funds.
#'   - `fee`: String - Handling fees.
#'   - `feeCurrency`: String - Fee currency.
#'   - `stp`: Enum<String> - Self Trade Prevention: "DC", "CO", "CN", "CB" or null.
#'   - `timeInForce`: Enum<String> - Time in force: "GTC", "GTT", "IOC", "FOK".
#'   - `postOnly`: Boolean - Post-only flag.
#'   - `hidden`: Boolean - Hidden order flag.
#'   - `iceberg`: Boolean - Iceberg order flag.
#'   - `visibleSize`: String - Visible size for iceberg orders.
#'   - `cancelAfter`: Integer - Seconds until cancellation for GTT.
#'   - `channel`: String - Order channel.
#'   - `remark`: String or null - Order remarks.
#'   - `tags`: String or null - Order tags.
#'   - `cancelExist`: Boolean - Indicates a cancellation record.
#'   - `tradeType`: String - Trade type.
#'   - `inOrderBook`: Boolean - Whether in the order book.
#'   - `tax`: String - Tax information.
#'   - `active`: Boolean - Order status (true = active).
#'   - `createdAt`: Integer<int64> - Creation timestamp in milliseconds.
#'   - `lastUpdatedAt`: Integer<int64> - Last update timestamp in milliseconds.
#'
#' ### JSON Response Example
#' ```json
#' {
#'   "code": "200000",
#'   "data": [
#'     {
#'       "id": "67120bbef094e200070976f6",
#'       "clientOid": "5c52e11203aa677f33e493fb",
#'       "symbol": "BTC-USDT",
#'       "opType": "DEAL",
#'       "type": "limit",
#'       "side": "buy",
#'       "price": "50000",
#'       "size": "0.00001",
#'       "funds": "0.5",
#'       "dealSize": "0",
#'       "dealFunds": "0",
#'       "fee": "0",
#'       "feeCurrency": "USDT",
#'       "stp": null,
#'       "timeInForce": "GTC",
#'       "postOnly": false,
#'       "hidden": false,
#'       "iceberg": false,
#'       "visibleSize": "0",
#'       "cancelAfter": 0,
#'       "channel": "API",
#'       "remark": "order remarks",
#'       "tags": "order tags",
#'       "cancelExist": false,
#'       "tradeType": "TRADE",
#'       "inOrderBook": true,
#'       "cancelledSize": "0",
#'       "cancelledFunds": "0",
#'       "remainSize": "0.00001",
#'       "remainFunds": "0.5",
#'       "tax": "0",
#'       "active": true,
#'       "createdAt": 1729235902748,
#'       "lastUpdatedAt": 1729235909862
#'     }
#'   ]
#' }
#' ```
#'
#' @param keys List; API configuration parameters from `get_api_keys()`. Defaults to `get_api_keys()`.
#' @param base_url Character string; base URL for the KuCoin API. Defaults to `get_base_url()`.
#' @param symbol Character string; the trading pair symbol (e.g., "BTC-USDT"). Required.
#' @return Promise resolving to a `data.table` with columns corresponding to the order fields, including:
#'   - `id` (character): Unique order ID.
#'   - `clientOid` (character): Client-assigned order ID.
#'   - `symbol` (character): Trading pair.
#'   - `opType` (character): Operation type.
#'   - `type` (character): Order type ("limit" or "market").
#'   - `side` (character): Order side ("buy" or "sell").
#'   - `price` (character): Order price.
#'   - `size` (character): Order size.
#'   - `funds` (character): Order funds.
#'   - `dealSize` (character): Filled quantity.
#'   - `dealFunds` (character): Filled funds.
#'   - `cancelledSize` (character): Canceled quantity.
#'   - `cancelledFunds` (character): Canceled funds.
#'   - `remainSize` (character): Remaining quantity.
#'   - `remainFunds` (character): Remaining funds.
#'   - `fee` (character): Handling fees.
#'   - `feeCurrency` (character): Fee currency.
#'   - `stp` (character or NA): Self Trade Prevention strategy.
#'   - `timeInForce` (character): Time in force.
#'   - `postOnly` (logical): Post-only flag.
#'   - `hidden` (logical): Hidden order flag.
#'   - `iceberg` (logical): Iceberg order flag.
#'   - `visibleSize` (character): Visible size for iceberg orders.
#'   - `cancelAfter` (integer): Seconds until cancellation for GTT.
#'   - `channel` (character): Order channel.
#'   - `remark` (character or NA): Order remarks.
#'   - `tags` (character or NA): Order tags.
#'   - `cancelExist` (logical): Indicates a cancellation record.
#'   - `tradeType` (character): Trade type.
#'   - `inOrderBook` (logical): Whether in the order book.
#'   - `tax` (character): Tax information.
#'   - `active` (logical): Order status (true = active).
#'   - `createdAt` (integer): Creation timestamp (milliseconds).
#'   - `lastUpdatedAt` (integer): Last update timestamp (milliseconds).
#'   - `createdAtDatetime` (POSIXct): Creation time in UTC.
#'   - `lastUpdatedAtDatetime` (POSIXct): Last update time in UTC.
#' @examples
#' \dontrun{
#' library(coro)
#' library(data.table)
#'
#' main_async <- coro::async(function() {
#'   # Retrieve open orders for BTC-USDT
#'   open_orders <- await(get_open_orders_impl(symbol = "BTC-USDT"))
#'   print(open_orders)
#' })
#'
#' # Run the async function
#' main_async()
#' while (!later::loop_empty()) later::run_now()
#' }
#' @importFrom coro async await
#' @importFrom data.table data.table rbindlist
#' @importFrom httr GET timeout
#' @importFrom rlang abort
#' @export
get_open_orders_impl <- coro::async(function(
    keys = get_api_keys(),
    base_url = get_base_url(),
    symbol
) {
    tryCatch({
        # Validate parameters
        if (is.null(symbol) || !is.character(symbol) || nchar(symbol) == 0) {
            rlang::abort("Parameter 'symbol' must be a non-empty string (e.g., 'BTC-USDT').")
        }
        if (!verify_symbol(symbol)) {
            rlang::abort("Parameter 'symbol' must be a valid trading pair (e.g., 'BTC-USDT').")
        }

        # Construct endpoint and query string
        endpoint <- "/api/v1/hf/orders/active"
        query_params <- list(symbol = symbol)
        query_string <- build_query(query_params)
        endpoint_with_query <- paste0(endpoint, query_string)
        full_url <- paste0(base_url, endpoint_with_query)

        # Generate authentication headers
        headers <- await(build_headers("GET", endpoint_with_query, NULL, keys))

        # Send GET request
        response <- httr::GET(
            url = full_url,
            headers,
            httr::timeout(3)
        )

        # Process response
        parsed_response <- process_kucoin_response(response, full_url)
        if (parsed_response$code != "200000") {
            rlang::abort(sprintf("API error: %s - %s", parsed_response$code, parsed_response$msg))
        }

        # Convert response data to data.table
        if (length(parsed_response$data) == 0) {
            # Define empty data.table with expected columns
            order_details <- data.table::data.table(
                id = character(),
                clientOid = character(),
                symbol = character(),
                opType = character(),
                type = character(),
                side = character(),
                price = character(),
                size = character(),
                funds = character(),
                dealSize = character(),
                dealFunds = character(),
                cancelledSize = character(),
                cancelledFunds = character(),
                remainSize = character(),
                remainFunds = character(),
                fee = character(),
                feeCurrency = character(),
                stp = character(),
                timeInForce = character(),
                postOnly = logical(),
                hidden = logical(),
                iceberg = logical(),
                visibleSize = character(),
                cancelAfter = integer(),
                channel = character(),
                remark = character(),
                tags = character(),
                cancelExist = logical(),
                tradeType = character(),
                inOrderBook = logical(),
                tax = character(),
                active = logical(),
                createdAt = integer(),
                lastUpdatedAt = integer(),
                createdAtDatetime = as.POSIXct(character()),
                lastUpdatedAtDatetime = as.POSIXct(character())
            )
        } else {
            order_details <- data.table::rbindlist(parsed_response$data, fill = TRUE)
            # Add datetime columns
            order_details[, createdAtDatetime := time_convert_from_kucoin(createdAt, unit = "ms")]
            order_details[, lastUpdatedAtDatetime := time_convert_from_kucoin(lastUpdatedAt, unit = "ms")]
        }

        return(order_details)
    }, error = function(e) {
        rlang::abort(sprintf("Error in get_open_orders_impl: %s", conditionMessage(e)))
    })
})

#' Get Closed Orders (Implementation)
#'
#' Retrieves all closed spot orders for a specified symbol from the KuCoin Spot trading system asynchronously.
#' This function supports pagination and returns a `data.table` with detailed information about each closed order,
#' sorted by the latest update time in descending order.
#'
#' ## Description
#' This endpoint fetches all closed orders (canceled or fully filled) for a given trading pair (e.g., "BTC-USDT").
#' The orders are returned in descending order based on their last update time. The function handles pagination
#' using the `lastId` parameter to fetch multiple pages of results, with data availability limited to the last
#' 72 hours by default if no time range is specified beyond that period.
#'
#' ## Workflow
#' 1. **Parameter Validation**: Ensures `symbol` is a valid trading pair and `limit` is an integer between 1 and 100.
#' 2. **Request Construction**: Builds the API endpoint with query parameters including `symbol`, `side`, `type`, `startAt`, `endAt`, and `limit`.
#' 3. **Authentication**: Generates private API headers using `build_headers()` with the GET method and endpoint.
#' 4. **API Request**: Sends asynchronous GET requests to fetch pages of closed orders until no more orders are returned or `max_pages` is reached.
#' 5. **Response Processing**: Combines the fetched orders into a single `data.table` and adds `createdAtDatetime` and `lastUpdatedAtDatetime` columns using `time_convert_from_kucoin()`.
#'
#' ## API Details
#' - **Endpoint**: `GET https://api.kucoin.com/api/v1/hf/orders/done`
#' - **Domain**: Spot
#' - **API Channel**: Private
#' - **API Permission**: General
#' - **Rate Limit Pool**: Spot
#' - **Rate Limit Weight**: 2
#' - **SDK Service**: Spot
#' - **SDK Sub-Service**: Order
#' - **SDK Method Name**: getClosedOrders
#' - **Official Documentation**: [KuCoin Get Closed Orders](https://www.kucoin.com/docs-new/rest/spot-trading/orders/get-closed-orders)
#'
#' ## Request
#' ### Query Parameters
#' - `symbol`: String (required) - The trading pair symbol (e.g., "BTC-USDT").
#' - `side`: Enum<String> (optional) - Order side: "buy" or "sell".
#' - `type`: Enum<String> (optional) - Order type: "limit" or "market".
#' - `lastId`: Integer<int64> (optional) - The ID of the last order from the previous batch for pagination.
#' - `limit`: Integer (optional) - Number of orders per page (default 20, max 100).
#' - `startAt`: Integer<int64> (optional) - Start time in milliseconds.
#' - `endAt`: Integer<int64> (optional) - End time in milliseconds.
#'
#' ### Example Request
#' ```bash
#' curl --location --request GET 'https://api.kucoin.com/api/v1/hf/orders/done?symbol=BTC-USDT&side=buy&type=limit&lastId=254062248624417&limit=20&startAt=1728663338000&endAt=1728692138000'
#' ```
#'
#' ## Response
#' ### HTTP Code: 200
#' - **Content Type**: `application/json`
#'
#' ### Data Schema
#' - `code`: String (required) - Response code ("200000" indicates success).
#' - `data`: Object (required) - Contains:
#'   - `lastId`: Integer<int64> (required) - The ID for the next page of data.
#'   - `items`: Array of objects (required) - List of closed orders, each with fields:
#'     - `id`: String - Unique order ID.
#'     - `clientOid`: String - Client-assigned order ID.
#'     - `symbol`: String - Trading pair.
#'     - `opType`: String - Operation type.
#'     - `type`: Enum<String> - Order type: "limit" or "market".
#'     - `side`: Enum<String> - Order side: "buy" or "sell".
#'     - `price`: String - Order price.
#'     - `size`: String - Order size.
#'     - `funds`: String - Order funds.
#'     - `dealSize`: String - Filled quantity.
#'     - `dealFunds`: String - Filled funds.
#'     - `remainSize`: String - Remaining quantity.
#'     - `remainFunds`: String - Remaining funds.
#'     - `cancelledSize`: String - Canceled quantity.
#'     - `cancelledFunds`: String - Canceled funds.
#'     - `fee`: String - Handling fees.
#'     - `feeCurrency`: String - Fee currency.
#'     - `stp`: Enum<String> - Self Trade Prevention: "DC", "CO", "CN", "CB" or NA.
#'     - `timeInForce`: Enum<String> - Time in force: "GTC", "GTT", "IOC", "FOK".
#'     - `postOnly`: Boolean - Post-only flag.
#'     - `hidden`: Boolean - Hidden order flag.
#'     - `iceberg`: Boolean - Iceberg order flag.
#'     - `visibleSize`: String - Visible size for iceberg orders.
#'     - `cancelAfter`: Integer - Seconds until cancellation for GTT.
#'     - `channel`: String - Order channel.
#'     - `remark`: String or NA - Order remarks.
#'     - `tags`: String or NA - Order tags.
#'     - `cancelExist`: Boolean - Indicates a cancellation record.
#'     - `tradeType`: String - Trade type.
#'     - `inOrderBook`: Boolean - Whether in the order book.
#'     - `tax`: String - Tax information.
#'     - `active`: Boolean - Order status (false for closed orders).
#'     - `createdAt`: Integer<int64> - Creation timestamp in milliseconds.
#'     - `lastUpdatedAt`: Integer<int64> - Last update timestamp in milliseconds.
#'
#' ### JSON Response Example
#' ```json
#' {
#'   "code": "200000",
#'   "data": {
#'     "lastId": 19814995255305,
#'     "items": [
#'       {
#'         "id": "6717422bd51c29000775ea03",
#'         "clientOid": "5c52e11203aa677f33e493fb",
#'         "symbol": "BTC-USDT",
#'         "opType": "DEAL",
#'         "type": "limit",
#'         "side": "buy",
#'         "price": "70000",
#'         "size": "0.00001",
#'         "funds": "0.7",
#'         "dealSize": "0.00001",
#'         "dealFunds": "0.677176",
#'         "remainSize": "0",
#'         "remainFunds": "0.022824",
#'         "cancelledSize": "0",
#'         "cancelledFunds": "0",
#'         "fee": "0.000677176",
#'         "feeCurrency": "USDT",
#'         "stp": null,
#'         "timeInForce": "GTC",
#'         "postOnly": false,
#'         "hidden": false,
#'         "iceberg": false,
#'         "visibleSize": "0",
#'         "cancelAfter": 0,
#'         "channel": "API",
#'         "remark": "order remarks",
#'         "tags": null,
#'         "cancelExist": false,
#'         "tradeType": "TRADE",
#'         "inOrderBook": false,
#'         "active": false,
#'         "tax": "0",
#'         "createdAt": 1729577515444,
#'         "lastUpdatedAt": 1729577515481
#'       }
#'     ]
#'   }
#' }
#' ```
#'
#' @param keys List; API configuration parameters from `get_api_keys()`. Defaults to `get_api_keys()`.
#' @param base_url Character string; base URL for the KuCoin API. Defaults to `get_base_url()`.
#' @param symbol Character string; the trading pair symbol (e.g., "BTC-USDT"). Required.
#' @param side Character string; optional filter for order side: "buy" or "sell".
#' @param type Character string; optional filter for order type: "limit" or "market".
#' @param startAt Numeric; optional start time in milliseconds.
#' @param endAt Numeric; optional end time in milliseconds.
#' @param limit Integer; number of orders per page (1 to 100, default 20).
#' @param max_pages Numeric; maximum number of pages to fetch (default `Inf`).
#' @return Promise resolving to a `data.table` with columns:
#'   - `id` (character): Unique order ID.
#'   - `clientOid` (character): Client-assigned order ID.
#'   - `symbol` (character): Trading pair.
#'   - `opType` (character): Operation type.
#'   - `type` (character): Order type ("limit" or "market").
#'   - `side` (character): Order side ("buy" or "sell").
#'   - `price` (character): Order price.
#'   - `size` (character): Order size.
#'   - `funds` (character): Order funds.
#'   - `dealSize` (character): Filled quantity.
#'   - `dealFunds` (character): Filled funds.
#'   - `remainSize` (character): Remaining quantity.
#'   - `remainFunds` (character): Remaining funds.
#'   - `cancelledSize` (character): Canceled quantity.
#'   - `cancelledFunds` (character): Canceled funds.
#'   - `fee` (character): Handling fees.
#'   - `feeCurrency` (character): Fee currency.
#'   - `stp` (character or NA): Self Trade Prevention strategy.
#'   - `timeInForce` (character): Time in force.
#'   - `postOnly` (logical): Post-only flag.
#'   - `hidden` (logical): Hidden order flag.
#'   - `iceberg` (logical): Iceberg order flag.
#'   - `visibleSize` (character): Visible size for iceberg orders.
#'   - `cancelAfter` (integer): Seconds until cancellation for GTT.
#'   - `channel` (character): Order channel.
#'   - `remark` (character or NA): Order remarks.
#'   - `tags` (character or NA): Order tags.
#'   - `cancelExist` (logical): Indicates a cancellation record.
#'   - `tradeType` (character): Trade type.
#'   - `inOrderBook` (logical): Whether in the order book.
#'   - `tax` (character): Tax information.
#'   - `active` (logical): Order status (false for closed orders).
#'   - `createdAt` (numeric): Creation timestamp (milliseconds).
#'   - `lastUpdatedAt` (numeric): Last update timestamp (milliseconds).
#'   - `createdAtDatetime` (POSIXct): Creation time in UTC.
#'   - `lastUpdatedAtDatetime` (POSIXct): Last update time in UTC.
#' @examples
#' \dontrun{
#' library(coro)
#' library(data.table)
#'
#' main_async <- coro::async(function() {
#'   # Retrieve closed orders for BTC-USDT
#'   closed_orders <- await(get_closed_orders_impl(
#'     symbol = "BTC-USDT",
#'     side = "buy",
#'     type = "limit",
#'     startAt = 1728663338000,
#'     endAt = 1728692138000,
#'     limit = 50,
#'     max_pages = 2
#'   ))
#'   print(closed_orders)
#' })
#'
#' # Run the async function
#' main_async()
#' while (!later::loop_empty()) later::run_now()
#' }
#' @importFrom coro async await
#' @importFrom data.table data.table rbindlist
#' @importFrom httr GET timeout
#' @importFrom rlang abort
#' @export
get_closed_orders_impl <- coro::async(function(
    keys = get_api_keys(),
    base_url = get_base_url(),
    symbol,
    side = NULL,
    type = NULL,
    startAt = NULL,
    endAt = NULL,
    limit = 20,
    max_pages = Inf
) {
    tryCatch({
        # Validate parameters
        if (is.null(symbol) || !is.character(symbol) || nchar(symbol) == 0) {
            rlang::abort("Parameter 'symbol' must be a non-empty string (e.g., 'BTC-USDT').")
        }
        if (!verify_symbol(symbol)) {
            rlang::abort("Parameter 'symbol' must be a valid trading pair (e.g., 'BTC-USDT').")
        }
        if (!is.numeric(limit) || limit < 1 || limit > 100 || limit %% 1 != 0) {
            rlang::abort("Parameter 'limit' must be an integer between 1 and 100.")
        }

        # Construct base query
        query <- list(symbol = symbol, limit = as.integer(limit))
        if (!is.null(side)) query$side <- side
        if (!is.null(type)) query$type <- type
        if (!is.null(startAt)) query$startAt <- as.numeric(startAt)
        if (!is.null(endAt)) query$endAt <- as.numeric(endAt)

        # Inner function to fetch a single page
        fetch_page <- coro::async(function(lastId = NULL) {
            if (!is.null(lastId)) query$lastId <- lastId
            query_string <- build_query(query)
            endpoint <- "/api/v1/hf/orders/done"
            full_url <- paste0(base_url, endpoint, query_string)
            headers <- await(build_headers("GET", paste0(endpoint, query_string), NULL, keys))
            response <- httr::GET(full_url, headers, httr::timeout(3))
            parsed <- process_kucoin_response(response, full_url)
            if (parsed$code != "200000") {
                rlang::abort(sprintf("API error: %s - %s", parsed$code, parsed$msg))
            }
            return(parsed$data)
        })

        # Collect pages
        orders_list <- list()
        page <- 1
        lastId <- NULL
        while (TRUE) {
            data <- await(fetch_page(lastId))
            if (length(data$items) == 0 || page >= max_pages) {
                break
            }
            orders_list[[page]] <- data$items
            lastId <- data$lastId
            page <- page + 1
        }

        # Combine results and add datetime columns
        if (length(orders_list) == 0) {
            orders_dt <- data.table::data.table(
                id = character(),
                clientOid = character(),
                symbol = character(),
                opType = character(),
                type = character(),
                side = character(),
                price = character(),
                size = character(),
                funds = character(),
                dealSize = character(),
                dealFunds = character(),
                remainSize = character(),
                remainFunds = character(),
                cancelledSize = character(),
                cancelledFunds = character(),
                fee = character(),
                feeCurrency = character(),
                stp = character(),
                timeInForce = character(),
                postOnly = logical(),
                hidden = logical(),
                iceberg = logical(),
                visibleSize = character(),
                cancelAfter = integer(),
                channel = character(),
                remark = character(),
                tags = character(),
                cancelExist = logical(),
                tradeType = character(),
                inOrderBook = logical(),
                tax = character(),
                active = logical(),
                createdAt = numeric(),
                lastUpdatedAt = numeric(),
                createdAtDatetime = as.POSIXct(character()),
                lastUpdatedAtDatetime = as.POSIXct(character())
            )
        } else {
            orders_dt <- data.table::rbindlist(orders_list, fill = TRUE)
            orders_dt[, createdAtDatetime := time_convert_from_kucoin(createdAt, unit = "ms")]
            orders_dt[, lastUpdatedAtDatetime := time_convert_from_kucoin(lastUpdatedAt, unit = "ms")]
        }

        return(orders_dt)
    }, error = function(e) {
        rlang::abort(sprintf("Error in get_closed_orders_impl: %s", conditionMessage(e)))
    })
})

# ./impl_spottrading_orders_oco.R

# File: ./R/impl_spottrading_orders_oco.R

# box::use(
#     ./helpers_api[process_kucoin_response, build_headers],
#     ./utils[build_query, get_base_url, verify_symbol, get_api_keys],
#     ./utils_time_convert_kucoin[time_convert_from_kucoin],
#     coro[async, await],
#     data.table[data.table, rbindlist],
#     httr[POST, DELETE, GET, timeout, content_type_json],
#     jsonlite[toJSON],
#     rlang[abort, arg_match0]
# )

#' Add OCO Order (Implementation)
#'
#' Places an OCO (One-Cancels-the-Other) order on the KuCoin Spot trading system asynchronously by sending a POST request to the `/api/v3/oco/order` endpoint.
#' An OCO order combines a limit order and a stop-limit order, where executing one cancels the other, returning a `data.table` with the order ID.
#'
#' ## What is an OCO Order?
#' An OCO (One-Cancels-the-Other) order is a sophisticated trading tool that pairs a limit order (to secure profits) with a stop-limit order (to cap losses).
#' When one order executes—either hitting a profit target or a stop-loss threshold—the other is automatically canceled. This is particularly useful for:
#' - **Risk Management**: Set a stop-loss to limit potential losses if the market moves against your position, e.g., buying BTC at $50,000 with a stop at $48,000.
#' - **Profit Taking**: Lock in gains at a target price without constant monitoring, e.g., selling at $55,000 after buying at $50,000.
#' - **Volatile Markets**: Automate trading decisions in fast-moving conditions, reducing emotional bias and ensuring discipline.
#' For example, a trader might place an OCO order to buy BTC at $50,000, setting a limit sell at $55,000 (profit) and a stop-limit sell at $48,000 (loss protection).
#' If BTC reaches $55,000, the profit is secured, and the stop cancels; if it drops to $48,000, losses are limited, and the limit cancels.
#'
#' ## Description
#' This function constructs a JSON request body with required parameters (`symbol`, `side`, `price`, `size`, `clientOid`, `stopPrice`, `limitPrice`)
#' and optional fields (`remark`, `tradeType`), authenticates the request, and processes the response into a `data.table`.
#'
#' ## Workflow
#' 1. **Parameter Validation**: Ensures required fields are non-empty strings and validates `side` and `tradeType` enums.
#' 2. **Request Construction**: Builds a named list of parameters, excluding NULL values, and converts it to JSON using `toJSON`.
#' 3. **Authentication**: Generates private API headers using `build_headers()` with the POST method, endpoint, and JSON body.
#' 4. **API Request**: Sends a POST request to the KuCoin API with a 3-second timeout via `httr::POST`.
#' 5. **Response Processing**: Parses the response with `process_kucoin_response`, checks for success ("200000"), and converts the `data` field to a `data.table`.
#'
#' ## API Details
#' - **Endpoint**: `POST https://api.kucoin.com/api/v3/oco/order`
#' - **Domain**: Spot
#' - **API Channel**: Private
#' - **API Permission**: Spot
#' - **Rate Limit Pool**: Spot
#' - **Rate Limit Weight**: 2
#' - **SDK Service**: Spot
#' - **SDK Sub-Service**: Order
#' - **SDK Method Name**: addOcoOrder
#' - **Official Documentation**: [KuCoin Add OCO Order](https://www.kucoin.com/docs-new/rest/spot-trading/orders/add-oco-order)
#'
#' ## Request
#' ### Body Parameters (application/json)
#' - `symbol`: String (required) - Trading pair symbol (e.g., "BTC-USDT").
#' - `side`: Enum<String> (required) - Order side: "buy" or "sell".
#' - `price`: String (required) - Limit order price.
#' - `size`: String (required) - Order quantity.
#' - `clientOid`: String (required) - Unique client order ID (max 40 characters, alphanumeric, underscores, or hyphens).
#' - `stopPrice`: String (required) - Trigger price for the stop-limit order.
#' - `limitPrice`: String (required) - Limit order price after triggering take-profit or stop-loss.
#' - `remark`: String (optional) - Order remarks (max 20 characters).
#' - `tradeType`: Enum<String> (optional) - Transaction type: "TRADE" (default).
#'
#' ### Example Request
#' ```bash
#' curl --location --request POST 'https://api.kucoin.com/api/v3/oco/order' \
#' --header 'Content-Type: application/json' \
#' --data-raw '{
#'     "symbol": "BTC-USDT",
#'     "side": "buy",
#'     "price": "94000",
#'     "size": "0.1",
#'     "clientOid": "5c52e11203aa67f1e493fb",
#'     "stopPrice": "98000",
#'     "limitPrice": "96000",
#'     "remark": "this is remark",
#'     "tradeType": "TRADE"
#' }'
#' ```
#'
#' ## Response
#' ### HTTP Code: 200
#' - **Content Type**: `application/json`
#'
#' ### Data Schema
#' - `code`: String (required) - Response code ("200000" indicates success).
#' - `data`: Object (required) - Contains:
#'   - `orderId`: String (required) - Unique order ID generated by the system.
#'
#' ### JSON Response Example
#' ```json
#' {
#'   "code": "200000",
#'   "data": {
#'     "orderId": "674c316e688dea0007c7b986"
#'   }
#' }
#' ```
#'
#' @param keys List; API configuration parameters from `get_api_keys()`. Defaults to `get_api_keys()`.
#' @param base_url Character string; base URL for the KuCoin API. Defaults to `get_base_url()`.
#' @param symbol Character string; trading pair symbol (e.g., "BTC-USDT"). Required.
#' @param side Character string; order side: "buy" or "sell". Required.
#' @param price Character string; limit order price (e.g., "94000"). Required.
#' @param size Character string; order quantity (e.g., "0.1"). Required.
#' @param clientOid Character string; unique client order ID (max 40 characters, e.g., "5c52e11203aa67f1e493fb"). Required.
#' @param stopPrice Character string; stop-limit trigger price (e.g., "98000"). Required.
#' @param limitPrice Character string; stop-limit order price (e.g., "96000"). Required.
#' @param remark Character string; optional remarks (max 20 characters, e.g., "this is remark").
#' @param tradeType Character string; transaction type: "TRADE" (default).
#' @return Promise resolving to a `data.table` with one row containing:
#'   - `orderId` (character): Unique order ID generated by the KuCoin system for the OCO order.
#' @examples
#' \dontrun{
#' library(coro)
#' library(data.table)
#'
#' main_async <- coro::async(function() {
#'   # Place an OCO order for BTC-USDT
#'   oco_order <- await(add_oco_order_impl(
#'     symbol = "BTC-USDT",
#'     side = "buy",
#'     price = "94000",
#'     size = "0.1",
#'     clientOid = "5c52e11203aa67f1e493fb",
#'     stopPrice = "98000",
#'     limitPrice = "96000",
#'     remark = "Profit and Stop"
#'   ))
#'   print(oco_order)
#' })
#'
#' # Run the async function
#' main_async()
#' while (!later::loop_empty()) later::run_now()
#' }
#' @importFrom coro async await
#' @importFrom data.table data.table
#' @importFrom httr POST timeout content_type_json
#' @importFrom jsonlite toJSON
#' @importFrom rlang abort arg_match0
#' @export
add_oco_order_impl <- coro::async(function(
    keys = get_api_keys(),
    base_url = get_base_url(),
    symbol,
    side,
    price,
    size,
    clientOid,
    stopPrice,
    limitPrice,
    remark = NULL,
    tradeType = "TRADE"
) {
    tryCatch({
        # Validate parameters
        if (is.null(symbol) || !is.character(symbol) || !verify_symbol(symbol)) {
            rlang::abort("Parameter 'symbol' must be a valid trading pair (e.g., 'BTC-USDT').")
        }
        if (is.null(side) || !is.character(side)) {
            rlang::abort("Parameter 'side' must be 'buy' or 'sell'.")
        }
        side <- rlang::arg_match0(side, c("buy", "sell"), "side")
        if (is.null(price) || !is.character(price) || nchar(price) == 0) {
            rlang::abort("Parameter 'price' must be a non-empty string (e.g., '94000').")
        }
        if (is.null(size) || !is.character(size) || nchar(size) == 0) {
            rlang::abort("Parameter 'size' must be a non-empty string (e.g., '0.1').")
        }
        if (is.null(clientOid) || !is.character(clientOid) || nchar(clientOid) > 40) {
            rlang::abort("Parameter 'clientOid' must be a non-empty string with max 40 characters.")
        }
        if (is.null(stopPrice) || !is.character(stopPrice) || nchar(stopPrice) == 0) {
            rlang::abort("Parameter 'stopPrice' must be a non-empty string (e.g., '98000').")
        }
        if (is.null(limitPrice) || !is.character(limitPrice) || nchar(limitPrice) == 0) {
            rlang::abort("Parameter 'limitPrice' must be a non-empty string (e.g., '96000').")
        }
        if (!is.null(remark) && (!is.character(remark) || nchar(remark) > 20)) {
            rlang::abort("Parameter 'remark' must be a string with max 20 characters.")
        }
        if (!is.null(tradeType)) {
            tradeType <- rlang::arg_match0(tradeType, "TRADE", "tradeType")
        }

        # Construct request body
        body_list <- list(
            symbol = symbol,
            side = side,
            price = price,
            size = size,
            clientOid = clientOid,
            stopPrice = stopPrice,
            limitPrice = limitPrice,
            tradeType = tradeType
        )
        if (!is.null(remark)) body_list$remark <- remark
        body_json <- jsonlite::toJSON(body_list, auto_unbox = TRUE)

        # Prepare API request
        endpoint <- "/api/v3/oco/order"
        full_url <- paste0(base_url, endpoint)

        # Generate authentication headers
        headers <- await(build_headers("POST", endpoint, body_json, keys))

        # Send POST request
        response <- httr::POST(
            url = full_url,
            body = body_json,
            headers,
            httr::content_type_json(),
            httr::timeout(3)
        )

        # Process response
        parsed_response <- process_kucoin_response(response, full_url)
        if (parsed_response$code != "200000") {
            rlang::abort(sprintf("API error: %s - %s", parsed_response$code, parsed_response$msg))
        }

        # Return as data.table
        return(data.table::data.table(orderId = parsed_response$data$orderId))
    }, error = function(e) {
        rlang::abort(sprintf("Error in add_oco_order_impl: %s", conditionMessage(e)))
    })
})

#' Cancel OCO Order By OrderId (Implementation)
#'
#' Cancels an existing OCO order on the KuCoin Spot trading system using its system-generated order ID (`orderId`) asynchronously by sending a DELETE request to the `/api/v3/oco/order/{orderId}` endpoint.
#'
#' ## What is an OCO Order?
#' An OCO (One-Cancels-the-Other) order pairs a limit order (profit target) with a stop-limit order (loss limit). Canceling an OCO order removes both components, which is useful when:
#' - **Strategy Adjustment**: Market conditions shift, and you no longer want automated profit-taking or loss-limiting (e.g., news-driven volatility).
#' - **Manual Intervention**: You decide to manage the position manually instead of relying on pre-set triggers.
#' - **Error Correction**: You need to correct an OCO order placed with incorrect parameters.
#' For instance, if you set an OCO to sell BTC at $55,000 (profit) or $48,000 (stop-loss) but BTC’s volatility decreases, you might cancel it to set tighter limits.
#'
#' ## Description
#' This function initiates the cancellation of an OCO order identified by its `orderId`, returning a `data.table` with the IDs of the canceled limit and stop-limit orders.
#'
#' ## Workflow
#' 1. **Parameter Validation**: Ensures `orderId` is a non-empty string.
#' 2. **Request Construction**: Constructs the endpoint URL by embedding `orderId` as a path parameter.
#' 3. **Authentication**: Generates private API headers using `build_headers()` with the DELETE method and endpoint.
#' 4. **API Request**: Sends a DELETE request to the KuCoin API with a 3-second timeout via `httr::DELETE`.
#' 5. **Response Processing**: Parses the response, confirms success ("200000"), and converts the `cancelledOrderIds` array to a `data.table` column as a list.
#'
#' ## API Details
#' - **Endpoint**: `DELETE https://api.kucoin.com/api/v3/oco/order/{orderId}`
#' - **Domain**: Spot
#' - **API Channel**: Private
#' - **API Permission**: Spot
#' - **Rate Limit Pool**: Spot
#' - **Rate Limit Weight**: 3
#' - **SDK Service**: Spot
#' - **SDK Sub-Service**: Order
#' - **SDK Method Name**: cancelOcoOrderByOrderId
#' - **Official Documentation**: [KuCoin Cancel OCO Order By OrderId](https://www.kucoin.com/docs-new/rest/spot-trading/orders/cancel-oco-order-by-orderld)
#'
#' ## Request
#' ### Path Parameters
#' - `orderId`: String (required) - The unique order ID generated by the trading system (e.g., "674c316e688dea0007c7b986").
#'
#' ### Example Request
#' ```bash
#' curl --location --request DELETE 'https://api.kucoin.com/api/v3/oco/order/674c316e688dea0007c7b986'
#' ```
#'
#' ## Response
#' ### HTTP Code: 200
#' - **Content Type**: `application/json`
#'
#' ### Data Schema
#' - `code`: String (required) - Response code ("200000" indicates success).
#' - `data`: Object (required) - Contains:
#'   - `cancelledOrderIds`: Array[String] (required) - List of two order IDs related to the canceled OCO order (limit and stop-limit components).
#'
#' ### JSON Response Example
#' ```json
#' {
#'   "code": "200000",
#'   "data": {
#'     "cancelledOrderIds": [
#'       "vs93gpqc6kkmkk57003gok16",
#'       "vs93gpqc6kkmkk57003gok17"
#'     ]
#'   }
#' }
#' ```
#'
#' @param keys List; API configuration parameters from `get_api_keys()`. Defaults to `get_api_keys()`.
#' @param base_url Character string; base URL for the KuCoin API. Defaults to `get_base_url()`.
#' @param orderId Character string; the unique order ID to cancel (e.g., "674c316e688dea0007c7b986"). Required.
#' @return Promise resolving to a `data.table` with one row containing:
#'   - `cancelledOrderIds` (list): A list of two character strings representing the IDs of the canceled limit and stop-limit orders.
#' @examples
#' \dontrun{
#' library(coro)
#' library(data.table)
#'
#' main_async <- coro::async(function() {
#'   # Cancel an OCO order by orderId
#'   canceled_orders <- await(cancel_oco_order_by_order_id_impl(
#'     orderId = "674c316e688dea0007c7b986"
#'   ))
#'   print(canceled_orders)
#' })
#'
#' # Run the async function
#' main_async()
#' while (!later::loop_empty()) later::run_now()
#' }
#' @importFrom coro async await
#' @importFrom data.table data.table
#' @importFrom httr DELETE timeout
#' @importFrom rlang abort
#' @export
cancel_oco_order_by_order_id_impl <- coro::async(function(
    keys = get_api_keys(),
    base_url = get_base_url(),
    orderId
) {
    tryCatch({
        # Validate parameters
        if (is.null(orderId) || !is.character(orderId) || nchar(orderId) == 0) {
            rlang::abort("Parameter 'orderId' must be a non-empty string.")
        }

        # Construct endpoint
        endpoint <- paste0("/api/v3/oco/order/", orderId)
        full_url <- paste0(base_url, endpoint)

        # Generate authentication headers
        headers <- await(build_headers("DELETE", endpoint, NULL, keys))

        # Send DELETE request
        response <- httr::DELETE(
            url = full_url,
            headers,
            httr::timeout(3)
        )

        # Process response
        parsed_response <- process_kucoin_response(response, full_url)
        if (parsed_response$code != "200000") {
            rlang::abort(sprintf("API error: %s - %s", parsed_response$code, parsed_response$msg))
        }

        # Return as data.table
        return(data.table::data.table(cancelledOrderIds = list(parsed_response$data$cancelledOrderIds)))
    }, error = function(e) {
        rlang::abort(sprintf("Error in cancel_oco_order_by_order_id_impl: %s", conditionMessage(e)))
    })
})

#' Cancel OCO Order By ClientOid (Implementation)
#'
#' Cancels an existing OCO order on the KuCoin Spot trading system using its client-assigned order ID (`clientOid`) asynchronously by sending a DELETE request to the `/api/v3/oco/client-order/{clientOid}` endpoint.
#'
#' ## What is an OCO Order?
#' An OCO (One-Cancels-the-Other) order links a limit order (profit target) with a stop-limit order (loss limit). Canceling by `clientOid` allows:
#' - **Custom Tracking**: Use your unique ID to cancel without needing the system `orderId`, ideal for systems tracking orders locally.
#' - **Flexibility**: Adjust strategies when market trends shift unexpectedly (e.g., canceling an OCO if a breakout is anticipated).
#' - **Error Handling**: Quickly remove an OCO order if set incorrectly, such as wrong price levels.
#' For example, if an OCO order was placed with a `clientOid` to sell BTC at $55,000 or $48,000 but you detect a potential rally, you might cancel it using your custom ID.
#'
#' ## Description
#' This function initiates the cancellation of an OCO order identified by its `clientOid`, returning a `data.table` with the IDs of the canceled limit and stop-limit orders.
#'
#' ## Workflow
#' 1. **Parameter Validation**: Ensures `clientOid` is a non-empty string.
#' 2. **Request Construction**: Constructs the endpoint URL by embedding `clientOid` as a path parameter.
#' 3. **Authentication**: Generates private API headers using `build_headers()` with the DELETE method and endpoint.
#' 4. **API Request**: Sends a DELETE request to the KuCoin API with a 3-second timeout via `httr::DELETE`.
#' 5. **Response Processing**: Parses the response, confirms success ("200000"), and converts the `cancelledOrderIds` array to a `data.table` column as a list.
#'
#' ## API Details
#' - **Endpoint**: `DELETE https://api.kucoin.com/api/v3/oco/client-order/{clientOid}`
#' - **Domain**: Spot
#' - **API Channel**: Private
#' - **API Permission**: Spot
#' - **Rate Limit Pool**: Spot
#' - **Rate Limit Weight**: 3
#' - **SDK Service**: Spot
#' - **SDK Sub-Service**: Order
#' - **SDK Method Name**: cancelOcoOrderByClientOid
#' - **Official Documentation**: [KuCoin Cancel OCO Order By ClientOid](https://www.kucoin.com/docs-new/rest/spot-trading/orders/cancel-oco-order-by-clientoid)
#'
#' ## Request
#' ### Path Parameters
#' - `clientOid`: String (required) - Unique client order ID created by the user (e.g., "5c52e11203aa67f1e493fb").
#'
#' ### Example Request
#' ```bash
#' curl --location --request DELETE 'https://api.kucoin.com/api/v3/oco/client-order/5c52e11203aa67f1e493fb'
#' ```
#'
#' ## Response
#' ### HTTP Code: 200
#' - **Content Type**: `application/json`
#'
#' ### Data Schema
#' - `code`: String (required) - Response code ("200000" indicates success).
#' - `data`: Object (required) - Contains:
#'   - `cancelledOrderIds`: Array[String] (required) - List of two order IDs related to the canceled OCO order (limit and stop-limit components).
#'
#' ### JSON Response Example
#' ```json
#' {
#'   "code": "200000",
#'   "data": {
#'     "cancelledOrderIds": [
#'       "vs93gpqc6r0mkk57003gok3h",
#'       "vs93gpqc6r0mkk57003gok3i"
#'     ]
#'   }
#' }
#' ```
#'
#' @param keys List; API configuration parameters from `get_api_keys()`. Defaults to `get_api_keys()`.
#' @param base_url Character string; base URL for the KuCoin API. Defaults to `get_base_url()`.
#' @param clientOid Character string; the unique client order ID to cancel (e.g., "5c52e11203aa67f1e493fb"). Required.
#' @return Promise resolving to a `data.table` with one row containing:
#'   - `cancelledOrderIds` (list): A list of two character strings representing the IDs of the canceled limit and stop-limit orders.
#' @examples
#' \dontrun{
#' library(coro)
#' library(data.table)
#'
#' main_async <- coro::async(function() {
#'   # Cancel an OCO order by clientOid
#'   canceled_orders <- await(cancel_oco_order_by_client_oid_impl(
#'     clientOid = "5c52e11203aa67f1e493fb"
#'   ))
#'   print(canceled_orders)
#' })
#'
#' # Run the async function
#' main_async()
#' while (!later::loop_empty()) later::run_now()
#' }
#' @importFrom coro async await
#' @importFrom data.table data.table
#' @importFrom httr DELETE timeout
#' @importFrom rlang abort
#' @export
cancel_oco_order_by_client_oid_impl <- coro::async(function(
    keys = get_api_keys(),
    base_url = get_base_url(),
    clientOid
) {
    tryCatch({
        # Validate parameters
        if (is.null(clientOid) || !is.character(clientOid) || nchar(clientOid) == 0) {
            rlang::abort("Parameter 'clientOid' must be a non-empty string.")
        }

        # Construct endpoint
        endpoint <- paste0("/api/v3/oco/client-order/", clientOid)
        full_url <- paste0(base_url, endpoint)

        # Generate authentication headers
        headers <- await(build_headers("DELETE", endpoint, NULL, keys))

        # Send DELETE request
        response <- httr::DELETE(
            url = full_url,
            headers,
            httr::timeout(3)
        )

        # Process response
        parsed_response <- process_kucoin_response(response, full_url)
        if (parsed_response$code != "200000") {
            rlang::abort(sprintf("API error: %s - %s", parsed_response$code, parsed_response$msg))
        }

        # Return as data.table
        return(data.table::data.table(cancelledOrderIds = list(parsed_response$data$cancelledOrderIds)))
    }, error = function(e) {
        rlang::abort(sprintf("Error in cancel_oco_order_by_client_oid_impl: %s", conditionMessage(e)))
    })
})

#' Batch Cancel OCO Orders (Implementation)
#'
#' Cancels a batch of OCO (One-Cancels-the-Other) orders on the KuCoin Spot trading system asynchronously by sending a DELETE request to the `/api/v3/oco/orders` endpoint.
#' Returns a `data.table` with the IDs of the canceled limit and stop-limit orders associated with the OCO orders.
#'
#' ## What is an OCO Order and Batch Cancellation?
#' An OCO (One-Cancels-the-Other) order pairs a limit order (e.g., to secure profits) with a stop-limit order (e.g., to cap losses), canceling one when the other executes. Batch cancellation of OCO orders is useful for:
#' - **Portfolio Cleanup**: Remove all OCO orders for a symbol (e.g., "BTC-USDT") or specific IDs if market conditions no longer favor your strategy.
#' - **Risk Adjustment**: Cancel multiple OCOs during unexpected volatility to avoid unintended triggers (e.g., canceling BTC-USDT OCOs during a flash crash).
#' - **Strategy Overhaul**: Reset all OCO orders across trading pairs to implement a new trading plan without manual intervention.
#' For example, if you have OCO orders on BTC-USDT to sell at $55,000 (profit) or $48,000 (stop-loss) but anticipate a breakout, batch canceling them prevents premature execution.
#'
#' ## Description
#' This function cancels multiple OCO orders using optional filters (`orderIds`, `symbol`) via a DELETE request. If no parameters are provided, all OCO orders are canceled by default. The response includes the IDs of the canceled limit and stop-limit orders.
#'
#' ## Workflow
#' 1. **Parameter Validation**: Ensures `query` is a named list and validates `symbol` and `orderIds` if provided.
#' 2. **Request Construction**: Builds the endpoint URL with query parameters (`orderIds`, `symbol`) using `build_query`.
#' 3. **Authentication**: Generates private API headers using `build_headers()` with the DELETE method and endpoint.
#' 4. **API Request**: Sends a DELETE request to the KuCoin API with a 3-second timeout via `httr::DELETE`.
#' 5. **Response Processing**: Parses the response with `process_kucoin_response`, confirms success ("200000"), and converts the `cancelledOrderIds` array to a `data.table` column as a list.
#'
#' ## API Details
#' - **Endpoint**: `DELETE https://api.kucoin.com/api/v3/oco/orders`
#' - **Domain**: Spot
#' - **API Channel**: Private
#' - **API Permission**: Spot
#' - **Rate Limit Pool**: Spot
#' - **Rate Limit Weight**: 3
#' - **SDK Service**: Spot
#' - **SDK Sub-Service**: Order
#' - **SDK Method Name**: batchCancelOcoOrders
#' - **Official Documentation**: [KuCoin Batch Cancel OCO Order](https://www.kucoin.com/docs-new/rest/spot-trading/orders/batch-cancel-oco-order)
#'
#' ## Request
#' ### Query Parameters
#' - `orderIds`: String (optional) - Comma-separated list of OCO order IDs (e.g., "674c388172cf2800072ee746,674c38bdfd8300000795167e"). If omitted, all OCO orders are canceled.
#' - `symbol`: String (optional) - Trading pair symbol (e.g., "BTC-USDT"). If omitted, OCO orders for all symbols are canceled.
#'
#' ### Example Request
#' ```bash
#' curl --location --request DELETE 'https://api.kucoin.com/api/v3/oco/orders?orderIds=674c388172cf2800072ee746,674c38bdfd8300000795167e&symbol=BTC-USDT'
#' ```
#'
#' ## Response
#' ### HTTP Code: 200
#' - **Content Type**: `application/json`
#'
#' ### Data Schema
#' - `code`: String (required) - Response code ("200000" indicates success).
#' - `data`: Object (required) - Contains:
#'   - `cancelledOrderIds`: Array[String] (required) - List of canceled order IDs (typically two per OCO order: limit and stop-limit components).
#'
#' ### JSON Response Example
#' ```json
#' {
#'   "code": "200000",
#'   "data": {
#'     "cancelledOrderIds": [
#'       "vs93gpqc750mkk57003gok6i",
#'       "vs93gpqc750mkk57003gok6j",
#'       "vs93gpqc75c39p83003tnriu",
#'       "vs93gpqc75c39p83003tnriv"
#'     ]
#'   }
#' }
#' ```
#'
#' @param keys List; API configuration parameters from `get_api_keys()`. Defaults to `get_api_keys()`.
#' @param base_url Character string; base URL for the KuCoin API. Defaults to `get_base_url()`.
#' @param query Named list; optional query parameters for filtering (e.g., `list(orderIds = "674c388172cf2800072ee746,674c38bdfd8300000795167e", symbol = "BTC-USDT")`).
#' @return Promise resolving to a `data.table` with one row containing:
#'   - `cancelledOrderIds` (list): A list of character strings representing the IDs of the canceled limit and stop-limit orders associated with the OCO orders.
#' @examples
#' \dontrun{
#' library(coro)
#' library(data.table)
#'
#' main_async <- coro::async(function() {
#'   # Batch cancel specific OCO orders for BTC-USDT
#'   canceled_orders <- await(cancel_oco_order_batch_impl(
#'     query = list(
#'       orderIds = "674c388172cf2800072ee746,674c38bdfd8300000795167e",
#'       symbol = "BTC-USDT"
#'     )
#'   ))
#'   print(canceled_orders)
#' })
#'
#' # Run the async function
#' main_async()
#' while (!later::loop_empty()) later::run_now()
#' }
#' @importFrom coro async await
#' @importFrom data.table data.table
#' @importFrom httr DELETE timeout
#' @importFrom rlang abort
#' @export
cancel_oco_order_batch_impl <- coro::async(function(
    keys = get_api_keys(),
    base_url = get_base_url(),
    query = list()
) {
    tryCatch({
        # Validate parameters
        if (!is.list(query)) {
            rlang::abort("Parameter 'query' must be a named list.")
        }
        if ("symbol" %in% names(query) && !is.null(query$symbol) && !verify_symbol(query$symbol)) {
            rlang::abort("Parameter 'query$symbol', if provided, must be a valid trading pair (e.g., 'BTC-USDT').")
        }
        if ("orderIds" %in% names(query) && (!is.character(query$orderIds) || nchar(query$orderIds) == 0)) {
            rlang::abort("Parameter 'query$orderIds', if provided, must be a non-empty comma-separated string.")
        }

        # Construct endpoint and query string
        endpoint <- "/api/v3/oco/orders"
        query_string <- build_query(query)
        full_url <- paste0(base_url, endpoint, query_string)

        # Generate authentication headers
        headers <- await(build_headers("DELETE", paste0(endpoint, query_string), NULL, keys))

        # Send DELETE request
        response <- httr::DELETE(
            url = full_url,
            headers,
            httr::timeout(3)
        )

        # Process response
        parsed_response <- process_kucoin_response(response, full_url)
        if (parsed_response$code != "200000") {
            rlang::abort(sprintf("API error: %s - %s", parsed_response$code, parsed_response$msg))
        }

        # Return as data.table
        return(data.table::data.table(cancelledOrderIds = list(parsed_response$data$cancelledOrderIds)))
    }, error = function(e) {
        rlang::abort(sprintf("Error in cancel_oco_order_batch_impl: %s", conditionMessage(e)))
    })
})

#' Get OCO Order By OrderId (Implementation)
#'
#' Retrieves basic information about an OCO order using its system-generated order ID (`orderId`) from the KuCoin Spot trading system asynchronously by sending a GET request to the `/api/v3/oco/order/{orderId}` endpoint.
#'
#' ## What is an OCO Order?
#' An OCO order combines a limit order (e.g., to take profits) with a stop-limit order (e.g., to limit losses), canceling one when the other executes. Retrieving this info is useful for:
#' - **Status Monitoring**: Check if the order is "NEW", "TRIGGERED", or "CANCELED" to assess its current state.
#' - **Trade Review**: Confirm order details like symbol and placement time match your strategy.
#' - **Decision Making**: Use status to decide whether to adjust or cancel (e.g., if still "NEW" during a trend shift).
#' For example, checking an OCO order placed at $50,000 for BTC might show it’s still "NEW", prompting a tighter stop if volatility rises.
#'
#' ## Description
#' This function fetches basic OCO order details (`orderId`, `symbol`, `clientOid`, `orderTime`, `status`) and returns them in a `data.table`.
#'
#' ## Workflow
#' 1. **Parameter Validation**: Ensures `orderId` is a non-empty string.
#' 2. **Request Construction**: Constructs the endpoint URL by embedding `orderId` as a path parameter.
#' 3. **Authentication**: Generates private API headers using `build_headers()` with the GET method and endpoint.
#' 4. **API Request**: Sends a GET request to the KuCoin API with a 3-second timeout via `httr::GET`.
#' 5. **Response Processing**: Parses the response, confirms success ("200000"), and converts the `data` object to a `data.table`.
#'
#' ## API Details
#' - **Endpoint**: `GET https://api.kucoin.com/api/v3/oco/order/{orderId}`
#' - **Domain**: Spot
#' - **API Channel**: Private
#' - **API Permission**: General
#' - **Rate Limit Pool**: Spot
#' - **Rate Limit Weight**: 2
#' - **SDK Service**: Spot
#' - **SDK Sub-Service**: Order
#' - **SDK Method Name**: getOcoOrderByOrderId
#' - **Official Documentation**: [KuCoin Get OCO Order By OrderId](https://www.kucoin.com/docs-new/rest/spot-trading/orders/get-oco-order-by-orderld)
#'
#' ## Request
#' ### Path Parameters
#' - `orderId`: String (required) - The unique order ID generated by the trading system (e.g., "674c3b6e688dea0007c7bab2").
#'
#' ### Example Request
#' ```bash
#' curl --location --request GET 'https://api.kucoin.com/api/v3/oco/order/674c3b6e688dea0007c7bab2'
#' ```
#'
#' ## Response
#' ### HTTP Code: 200
#' - **Content Type**: `application/json`
#'
#' ### Data Schema
#' - `code`: String (required) - Response code ("200000" indicates success).
#' - `data`: Object (required) - Contains:
#'   - `symbol`: String (required) - Trading pair symbol.
#'   - `clientOid`: String (required) - Client-assigned order ID.
#'   - `orderId`: String (required) - System-generated order ID.
#'   - `orderTime`: Integer<int64> (required) - Order placement time in milliseconds.
#'   - `status`: Enum<String> (required) - Order status: "NEW", "DONE", "TRIGGERED", "CANCELED".
#'
#' ### JSON Response Example
#' ```json
#' {
#'   "code": "200000",
#'   "data": {
#'     "orderId": "674c3b6e688dea0007c7bab2",
#'     "symbol": "BTC-USDT",
#'     "clientOid": "5c52e1203aa6f37f1e493fb",
#'     "orderTime": 1733049198863,
#'     "status": "NEW"
#'   }
#' }
#' ```
#'
#' @param keys List; API configuration parameters from `get_api_keys()`. Defaults to `get_api_keys()`.
#' @param base_url Character string; base URL for the KuCoin API. Defaults to `get_base_url()`.
#' @param orderId Character string; the unique order ID to retrieve (e.g., "674c3b6e688dea0007c7bab2"). Required.
#' @return Promise resolving to a `data.table` with one row containing:
#'   - `orderId` (character): Unique order ID generated by the KuCoin system.
#'   - `symbol` (character): Trading pair symbol (e.g., "BTC-USDT").
#'   - `clientOid` (character): Client-assigned order ID.
#'   - `orderTime` (integer): Order placement time in milliseconds.
#'   - `status` (character): Order status ("NEW", "DONE", "TRIGGERED", "CANCELED").
#' @examples
#' \dontrun{
#' library(coro)
#' library(data.table)
#'
#' main_async <- coro::async(function() {
#'   # Retrieve OCO order by orderId
#'   oco_order <- await(get_oco_order_by_order_id_impl(
#'     orderId = "674c3b6e688dea0007c7bab2"
#'   ))
#'   print(oco_order)
#' })
#'
#' # Run the async function
#' main_async()
#' while (!later::loop_empty()) later::run_now()
#' }
#' @importFrom coro async await
#' @importFrom data.table data.table rbindlist
#' @importFrom httr GET timeout
#' @importFrom rlang abort
#' @export
get_oco_order_by_order_id_impl <- coro::async(function(
    keys = get_api_keys(),
    base_url = get_base_url(),
    orderId
) {
    tryCatch({
        # Validate parameters
        if (is.null(orderId) || !is.character(orderId) || nchar(orderId) == 0) {
            rlang::abort("Parameter 'orderId' must be a non-empty string.")
        }

        # Construct endpoint
        endpoint <- paste0("/api/v3/oco/order/", orderId)
        full_url <- paste0(base_url, endpoint)

        # Generate authentication headers
        headers <- await(build_headers("GET", endpoint, NULL, keys))

        # Send GET request
        response <- httr::GET(
            url = full_url,
            headers,
            httr::timeout(3)
        )

        # Process response
        parsed_response <- process_kucoin_response(response, full_url)
        if (parsed_response$code != "200000") {
            rlang::abort(sprintf("API error: %s - %s", parsed_response$code, parsed_response$msg))
        }

        # Convert response data to data.table
        return(data.table::rbindlist(list(parsed_response$data), fill = TRUE))
    }, error = function(e) {
        rlang::abort(sprintf("Error in get_oco_order_by_order_id_impl: %s", conditionMessage(e)))
    })
})

#' Get OCO Order By ClientOid (Implementation)
#'
#' Retrieves basic information about an OCO order using its client-assigned order ID (`clientOid`) from the KuCoin Spot trading system asynchronously by sending a GET request to the `/api/v3/oco/client-order/{clientOid}` endpoint.
#'
#' ## What is an OCO Order?
#' An OCO order pairs a limit order (profit target) with a stop-limit order (loss limit), canceling one when the other executes. Fetching by `clientOid` is useful for:
#' - **Custom Tracking**: Monitor orders using your own ID system without relying on KuCoin’s `orderId`.
#' - **Status Checks**: Verify if an order is still active ("NEW") or has executed ("TRIGGERED"/"DONE").
#' - **Strategy Sync**: Ensure your trading system’s records align with KuCoin’s state (e.g., after a network delay).
#' For instance, retrieving an OCO order with a `clientOid` might confirm it’s "NEW", allowing you to adjust if market conditions change.
#'
#' ## Description
#' This function fetches basic OCO order details (`orderId`, `symbol`, `clientOid`, `orderTime`, `status`) and returns them in a `data.table`.
#'
#' ## Workflow
#' 1. **Parameter Validation**: Ensures `clientOid` is a non-empty string.
#' 2. **Request Construction**: Constructs the endpoint URL by embedding `clientOid` as a path parameter.
#' 3. **Authentication**: Generates private API headers using `build_headers()` with the GET method and endpoint.
#' 4. **API Request**: Sends a GET request to the KuCoin API with a 3-second timeout via `httr::GET`.
#' 5. **Response Processing**: Parses the response, confirms success ("200000"), and converts the `data` object to a `data.table`.
#'
#' ## API Details
#' - **Endpoint**: `GET https://api.kucoin.com/api/v3/oco/client-order/{clientOid}`
#' - **Domain**: Spot
#' - **API Channel**: Private
#' - **API Permission**: General
#' - **Rate Limit Pool**: Spot
#' - **Rate Limit Weight**: 2
#' - **SDK Service**: Spot
#' - **SDK Sub-Service**: Order
#' - **SDK Method Name**: getOcoOrderByClientOid
#' - **Official Documentation**: [KuCoin Get OCO Order By ClientOid](https://www.kucoin.com/docs-new/rest/spot-trading/orders/get-oco-order-by-clientoid)
#'
#' ## Request
#' ### Path Parameters
#' - `clientOid`: String (required) - Unique client order ID created by the user (e.g., "5c52e1203aa6f3g7f1e493fb").
#'
#' ### Example Request
#' ```bash
#' curl --location --request GET 'https://api.kucoin.com/api/v3/oco/client-order/5c52e1203aa6f3g7f1e493fb'
#' ```
#'
#' ## Response
#' ### HTTP Code: 200
#' - **Content Type**: `application/json`
#'
#' ### Data Schema
#' - `code`: String (required) - Response code ("200000" indicates success).
#' - `data`: Object (required) - Contains:
#'   - `symbol`: String (required) - Trading pair symbol.
#'   - `clientOid`: String (required) - Client-assigned order ID.
#'   - `orderId`: String (required) - System-generated order ID.
#'   - `orderTime`: Integer<int64> (required) - Order placement time in milliseconds.
#'   - `status`: String (required) - Order status: "NEW", "DONE", "TRIGGERED", "CANCELED".
#'
#' ### JSON Response Example
#' ```json
#' {
#'   "code": "200000",
#'   "data": {
#'     "orderId": "674c3cfa72cf2800072ee7ce",
#'     "symbol": "BTC-USDT",
#'     "clientOid": "5c52e1203aa6f3g7f1e493fb",
#'     "orderTime": 1733049594803,
#'     "status": "NEW"
#'   }
#' }
#' ```
#'
#' @param keys List; API configuration parameters from `get_api_keys()`. Defaults to `get_api_keys()`.
#' @param base_url Character string; base URL for the KuCoin API. Defaults to `get_base_url()`.
#' @param clientOid Character string; the unique client order ID to retrieve (e.g., "5c52e1203aa6f3g7f1e493fb"). Required.
#' @return Promise resolving to a `data.table` with one row containing:
#'   - `orderId` (character): Unique order ID generated by the KuCoin system.
#'   - `symbol` (character): Trading pair symbol (e.g., "BTC-USDT").
#'   - `clientOid` (character): Client-assigned order ID.
#'   - `orderTime` (integer): Order placement time in milliseconds.
#'   - `status` (character): Order status ("NEW", "DONE", "TRIGGERED", "CANCELED").
#' @examples
#' \dontrun{
#' library(coro)
#' library(data.table)
#'
#' main_async <- coro::async(function() {
#'   # Retrieve OCO order by clientOid
#'   oco_order <- await(get_oco_order_by_client_oid_impl(
#'     clientOid = "5c52e1203aa6f3g7f1e493fb"
#'   ))
#'   print(oco_order)
#' })
#'
#' # Run the async function
#' main_async()
#' while (!later::loop_empty()) later::run_now()
#' }
#' @importFrom coro async await
#' @importFrom data.table data.table rbindlist
#' @importFrom httr GET timeout
#' @importFrom rlang abort
#' @export
get_oco_order_by_client_oid_impl <- coro::async(function(
    keys = get_api_keys(),
    base_url = get_base_url(),
    clientOid
) {
    tryCatch({
        # Validate parameters
        if (is.null(clientOid) || !is.character(clientOid) || nchar(clientOid) == 0) {
            rlang::abort("Parameter 'clientOid' must be a non-empty string.")
        }

        # Construct endpoint
        endpoint <- paste0("/api/v3/oco/client-order/", clientOid)
        full_url <- paste0(base_url, endpoint)

        # Generate authentication headers
        headers <- await(build_headers("GET", endpoint, NULL, keys))

        # Send GET request
        response <- httr::GET(
            url = full_url,
            headers,
            httr::timeout(3)
        )

        # Process response
        parsed_response <- process_kucoin_response(response, full_url)
        if (parsed_response$code != "200000") {
            rlang::abort(sprintf("API error: %s - %s", parsed_response$code, parsed_response$msg))
        }

        # Convert response data to data.table
        return(data.table::rbindlist(list(parsed_response$data), fill = TRUE))
    }, error = function(e) {
        rlang::abort(sprintf("Error in get_oco_order_by_client_oid_impl: %s", conditionMessage(e)))
    })
})

#' Get OCO Order Detail By OrderId (Implementation)
#'
#' Retrieves detailed information about an OCO order, including its associated limit and stop-limit orders, using its system-generated order ID (`orderId`) from the KuCoin Spot trading system asynchronously by sending a GET request to the `/api/v3/oco/order/details/{orderId}` endpoint.
#'
#' ## What is an OCO Order?
#' An OCO order links a limit order (e.g., profit target) with a stop-limit order (e.g., loss limit), canceling one when the other executes. Fetching detailed info is useful for:
#' - **Execution Analysis**: Review the specific prices and sizes of both orders to evaluate strategy effectiveness.
#' - **Debugging**: Confirm the stop and limit prices align with your intended trade plan (e.g., catching setup errors).
#' - **Performance Tracking**: Assess whether triggers are nearing execution in volatile conditions.
#' For example, detailed info on an OCO order at $50,000 for BTC might show a limit at $55,000 and a stop at $48,000, helping you adjust if the range is too wide.
#'
#' ## Description
#' This function fetches detailed OCO order information (`orderId`, `symbol`, `clientOid`, `orderTime`, `status`, and `orders` array) and returns it in a `data.table` with nested order details as a list column.
#'
#' ## Workflow
#' 1. **Parameter Validation**: Ensures `orderId` is a non-empty string.
#' 2. **Request Construction**: Constructs the endpoint URL by embedding `orderId` as a path parameter.
#' 3. **Authentication**: Generates private API headers using `build_headers()` with the GET method and endpoint.
#' 4. **API Request**: Sends a GET request to the KuCoin API with a 3-second timeout via `httr::GET`.
#' 5. **Response Processing**: Parses the response, confirms success ("200000"), and constructs a `data.table` with `orders` as a list column.
#'
#' ## API Details
#' - **Endpoint**: `GET https://api.kucoin.com/api/v3/oco/order/details/{orderId}`
#' - **Domain**: Spot
#' - **API Channel**: Private
#' - **API Permission**: General
#' - **Rate Limit Pool**: Spot
#' - **Rate Limit Weight**: 2
#' - **SDK Service**: Spot
#' - **SDK Sub-Service**: Order
#' - **SDK Method Name**: getOcoOrderDetailByOrderId
#' - **Official Documentation**: [KuCoin Get OCO Order Detail By OrderId](https://www.kucoin.com/docs-new/rest/spot-trading/orders/get-oco-order-detail-by-orderld)
#'
#' ## Request
#' ### Path Parameters
#' - `orderId`: String (required) - The unique order ID generated by the trading system (e.g., "674c3b6e688dea0007c7bab2").
#'
#' ### Example Request
#' ```bash
#' curl --location --request GET 'https://api.kucoin.com/api/v3/oco/order/details/674c3b6e688dea0007c7bab2'
#' ```
#'
#' ## Response
#' ### HTTP Code: 200
#' - **Content Type**: `application/json`
#'
#' ### Data Schema
#' - `code`: String (required) - Response code ("200000" indicates success).
#' - `data`: Object (required) - Contains:
#'   - `orderId`: String (required) - System-generated order ID.
#'   - `symbol`: String (required) - Trading pair symbol.
#'   - `clientOid`: String (required) - Client-assigned order ID.
#'   - `orderTime`: Integer<int64> (required) - Order placement time in milliseconds.
#'   - `status`: String (required) - Order status: "NEW", "DONE", "TRIGGERED", "CANCELED".
#'   - `orders`: Array[Object] (required) - List of associated orders (limit and stop-limit), each with:
#'     - `id`: String - Individual order ID.
#'     - `symbol`: String - Trading pair symbol.
#'     - `side`: String - Order side ("buy" or "sell").
#'     - `price`: String - Order price.
#'     - `stopPrice`: String - Trigger price.
#'     - `size`: String - Order quantity.
#'     - `status`: String - Order status.
#'
#' ### JSON Response Example
#' ```json
#' {
#'   "code": "200000",
#'   "data": {
#'     "orderId": "674c3b6e688dea0007c7bab2",
#'     "symbol": "BTC-USDT",
#'     "clientOid": "5c52e1203aa6f37f1e493fb",
#'     "orderTime": 1733049198863,
#'     "status": "NEW",
#'     "orders": [
#'       {
#'         "id": "vs93gpqc7dn6h3fa003sfelj",
#'         "symbol": "BTC-USDT",
#'         "side": "buy",
#'         "price": "94000.00000000000000000000",
#'         "stopPrice": "94000.00000000000000000000",
#'         "size": "0.10000000000000000000",
#'         "status": "NEW"
#'       },
#'       {
#'         "id": "vs93gpqc7dn6h3fa003sfelk",
#'         "symbol": "BTC-USDT",
#'         "side": "buy",
#'         "price": "96000.00000000000000000000",
#'         "stopPrice": "98000.00000000000000000000",
#'         "size": "0.10000000000000000000",
#'         "status": "NEW"
#'       }
#'     ]
#'   }
#' }
#' ```
#'
#' @param keys List; API configuration parameters from `get_api_keys()`. Defaults to `get_api_keys()`.
#' @param base_url Character string; base URL for the KuCoin API. Defaults to `get_base_url()`.
#' @param orderId Character string; the unique order ID to retrieve (e.g., "674c3b6e688dea0007c7bab2"). Required.
#' @return Promise resolving to a `data.table` with one row containing:
#'   - `orderId` (character): Unique order ID generated by the KuCoin system.
#'   - `symbol` (character): Trading pair symbol (e.g., "BTC-USDT").
#'   - `clientOid` (character): Client-assigned order ID.
#'   - `orderTime` (integer): Order placement time in milliseconds.
#'   - `status` (character): Order status ("NEW", "DONE", "TRIGGERED", "CANCELED").
#'   - `orders` (list): List of nested objects, each containing:
#'     - `id` (character): Individual order ID.
#'     - `symbol` (character): Trading pair symbol.
#'     - `side` (character): Order side ("buy" or "sell").
#'     - `price` (character): Order price.
#'     - `stopPrice` (character): Trigger price.
#'     - `size` (character): Order quantity.
#'     - `status` (character): Order status ("NEW", etc.).
#' @examples
#' \dontrun{
#' library(coro)
#' library(data.table)
#'
#' main_async <- coro::async(function() {
#'   # Retrieve detailed OCO order by orderId
#'   oco_detail <- await(get_oco_order_detail_by_order_id_impl(
#'     orderId = "674c3b6e688dea0007c7bab2"
#'   ))
#'   print(oco_detail)
#' })
#'
#' # Run the async function
#' main_async()
#' while (!later::loop_empty()) later::run_now()
#' }
#' @importFrom coro async await
#' @importFrom data.table data.table
#' @importFrom httr GET timeout
#' @importFrom rlang abort
#' @export
get_oco_order_detail_by_order_id_impl <- coro::async(function(
    keys = get_api_keys(),
    base_url = get_base_url(),
    orderId
) {
    tryCatch({
        # Validate parameters
        if (is.null(orderId) || !is.character(orderId) || nchar(orderId) == 0) {
            rlang::abort("Parameter 'orderId' must be a non-empty string.")
        }

        # Construct endpoint
        endpoint <- paste0("/api/v3/oco/order/details/", orderId)
        full_url <- paste0(base_url, endpoint)

        # Generate authentication headers
        headers <- await(build_headers("GET", endpoint, NULL, keys))

        # Send GET request
        response <- httr::GET(
            url = full_url,
            headers,
            httr::timeout(3)
        )

        # Process response
        parsed_response <- process_kucoin_response(response, full_url)
        if (parsed_response$code != "200000") {
            rlang::abort(sprintf("API error: %s - %s", parsed_response$code, parsed_response$msg))
        }

        # Convert response data to data.table with nested orders as a list
        return(data.table::data.table(
            orderId = parsed_response$data$orderId,
            symbol = parsed_response$data$symbol,
            clientOid = parsed_response$data$clientOid,
            orderTime = parsed_response$data$orderTime,
            status = parsed_response$data$status,
            orders = list(parsed_response$data$orders)
        ))
    }, error = function(e) {
        rlang::abort(sprintf("Error in get_oco_order_detail_by_order_id_impl: %s", conditionMessage(e)))
    })
})

#' Get OCO Order List (Implementation)
#'
#' Retrieves a paginated list of current OCO orders from the KuCoin Spot trading system asynchronously by sending a GET request to the `/api/v3/oco/orders` endpoint.
#'
#' ## What is an OCO Order?
#' An OCO order combines a limit order (profit target) with a stop-limit order (loss limit), canceling one when the other executes. Listing all OCO orders is useful for:
#' - **Portfolio Oversight**: Review all active OCO strategies across trading pairs to ensure alignment with market conditions.
#' - **Bulk Management**: Identify orders to adjust or cancel based on status (e.g., canceling "NEW" orders if a trend reverses).
#' - **Historical Insight**: Filter by time to analyze past OCO performance for strategy refinement.
#' For example, listing OCO orders might show multiple BTC-USDT pairs with varying profit/loss levels, helping you optimize risk across your portfolio.
#'
#' ## Description
#' This function fetches a list of OCO orders with optional filters (`symbol`, `startAt`, etc.), sorted by latest first, and returns them in a `data.table`.
#'
#' ## Workflow
#' 1. **Parameter Validation**: Ensures `query` is a named list and validates `symbol` if provided.
#' 2. **Request Construction**: Constructs the endpoint URL with query parameters from `build_query`.
#' 3. **Authentication**: Generates private API headers using `build_headers()` with the GET method and endpoint.
#' 4. **API Request**: Sends a GET request to the KuCoin API with a 3-second timeout via `httr::GET`.
#' 5. **Response Processing**: Parses the response, confirms success ("200000"), and converts the `items` array to a `data.table`, returning an empty structured table if no items exist.
#'
#' ## API Details
#' - **Endpoint**: `GET https://api.kucoin.com/api/v3/oco/orders`
#' - **Domain**: Spot
#' - **API Channel**: Private
#' - **API Permission**: General
#' - **Rate Limit Pool**: Spot
#' - **Rate Limit Weight**: 2
#' - **SDK Service**: Spot
#' - **SDK Sub-Service**: Order
#' - **SDK Method Name**: getOcoOrderList
#' - **Official Documentation**: [KuCoin Get OCO Order List](https://www.kucoin.com/docs-new/rest/spot-trading/orders/get-oco-order-list)
#'
#' ## Request
#' ### Query Parameters
#' - `symbol`: String (optional) - Filter by trading pair symbol (e.g., "BTC-USDT").
#' - `startAt`: Integer<int64> (optional) - Start time in milliseconds.
#' - `endAt`: Integer<int64> (optional) - End time in milliseconds.
#' - `orderIds`: String (optional) - Comma-separated list of order IDs (up to 500).
#' - `pageSize`: Integer (optional) - Results per page (10–500, default 50).
#' - `currentPage`: Integer (optional) - Page number (minimum 1, default 1).
#'
#' ### Example Request
#' ```bash
#' curl --location --request GET 'https://api.kucoin.com/api/v3/oco/orders?symbol=BTC-USDT&pageSize=10&currentPage=1'
#' ```
#'
#' ## Response
#' ### HTTP Code: 200
#' - **Content Type**: `application/json`
#'
#' ### Data Schema
#' - `code`: String (required) - Response code ("200000" indicates success).
#' - `data`: Object (required) - Contains:
#'   - `currentPage`: Integer (required) - Current page number.
#'   - `pageSize`: Integer (required) - Number of items per page.
#'   - `totalNum`: Integer (required) - Total number of OCO orders.
#'   - `totalPage`: Integer (required) - Total number of pages.
#'   - `items`: Array[Object] (required) - List of OCO orders, each with:
#'     - `orderId`: String (required) - System-generated order ID.
#'     - `symbol`: String (required) - Trading pair symbol.
#'     - `clientOid`: String (required) - Client-assigned order ID.
#'     - `orderTime`: Integer<int64> (required) - Order placement time in milliseconds.
#'     - `status`: Enum<String> (required) - Order status: "NEW", "DONE", "TRIGGERED", "CANCELED".
#'
#' ### JSON Response Example
#' ```json
#' {
#'   "code": "200000",
#'   "data": {
#'     "currentPage": 1,
#'     "pageSize": 50,
#'     "totalNum": 1,
#'     "totalPage": 1,
#'     "items": [
#'       {
#'         "orderId": "674c3cfa72cf2800072ee7ce",
#'         "symbol": "BTC-USDT",
#'         "clientOid": "5c52e1203aa6f3g7f1e493fb",
#'         "orderTime": 1733049594803,
#'         "status": "NEW"
#'       }
#'     ]
#'   }
#' }
#' ```
#'
#' @param keys List; API configuration parameters from `get_api_keys()`. Defaults to `get_api_keys()`.
#' @param base_url Character string; base URL for the KuCoin API. Defaults to `get_base_url()`.
#' @param query Named list; optional query parameters for filtering and pagination (e.g., `list(symbol = "BTC-USDT", pageSize = 10)`).
#' @return Promise resolving to a `data.table` containing:
#'   - `orderId` (character): Unique order ID generated by the KuCoin system.
#'   - `symbol` (character): Trading pair symbol (e.g., "BTC-USDT").
#'   - `clientOid` (character): Client-assigned order ID.
#'   - `orderTime` (integer): Order placement time in milliseconds.
#'   - `status` (character): Order status ("NEW", "DONE", "TRIGGERED", "CANCELED").
#' @examples
#' \dontrun{
#' library(coro)
#' library(data.table)
#'
#' main_async <- coro::async(function() {
#'   # Retrieve OCO order list with filter
#'   oco_list <- await(get_oco_order_list_impl(
#'     query = list(symbol = "BTC-USDT", pageSize = 10, currentPage = 1)
#'   ))
#'   print(oco_list)
#' })
#'
#' # Run the async function
#' main_async()
#' while (!later::loop_empty()) later::run_now()
#' }
#' @importFrom coro async await
#' @importFrom data.table data.table rbindlist
#' @importFrom httr GET timeout
#' @importFrom rlang abort
#' @export
get_oco_order_list_impl <- coro::async(function(
    keys = get_api_keys(),
    base_url = get_base_url(),
    query = list()
) {
    tryCatch({
        # Validate parameters
        if (!is.list(query)) {
            rlang::abort("Parameter 'query' must be a named list.")
        }
        if ("symbol" %in% names(query) && !is.null(query$symbol) && !verify_symbol(query$symbol)) {
            rlang::abort("Parameter 'query$symbol', if provided, must be a valid trading pair (e.g., 'BTC-USDT').")
        }
        if ("pageSize" %in% names(query) && (!is.integer(query$pageSize) || query$pageSize < 10 || query$pageSize > 500)) {
            rlang::abort("Parameter 'query$pageSize' must be an integer between 10 and 500.")
        }
        if ("currentPage" %in% names(query) && (!is.integer(query$currentPage) || query$currentPage < 1)) {
            rlang::abort("Parameter 'query$currentPage' must be an integer >= 1.")
        }

        # Construct endpoint and query string
        endpoint <- "/api/v3/oco/orders"
        query_string <- build_query(query)
        full_url <- paste0(base_url, endpoint, query_string)

        # Generate authentication headers
        headers <- await(build_headers("GET", paste0(endpoint, query_string), NULL, keys))

        # Send GET request
        response <- httr::GET(
            url = full_url,
            headers,
            httr::timeout(3)
        )

        # Process response
        parsed_response <- process_kucoin_response(response, full_url)
        if (parsed_response$code != "200000") {
            rlang::abort(sprintf("API error: %s - %s", parsed_response$code, parsed_response$msg))
        }

        # Convert response data to data.table
        if (length(parsed_response$data$items) == 0) {
            return(data.table::data.table(
                orderId = character(),
                symbol = character(),
                clientOid = character(),
                orderTime = integer(),
                status = character()
            ))
        } else {
            return(data.table::rbindlist(parsed_response$data$items, fill = TRUE))
        }
    }, error = function(e) {
        rlang::abort(sprintf("Error in get_oco_order_list_impl: %s", conditionMessage(e)))
    })
})

# ./impl_spottrading_orders_stop.R

# File: ./R/impl_spottrading_orders_stop.R

# box::use(
#     ./helpers_api[process_kucoin_response, build_headers],
#     ./utils[build_query, get_base_url, verify_symbol, get_api_keys],
#     ./utils_time_convert_kucoin[time_convert_from_kucoin],
#     coro[async, await],
#     data.table[data.table, rbindlist],
#     httr[GET, DELETE, POST, timeout, content_type_json],
#     jsonlite[toJSON],
#     rlang[abort, arg_match0]
# )

#' Add Stop Order (Implementation)
#'
#' Places a stop order (limit or market) on the KuCoin Spot trading system asynchronously.
#' This function constructs a JSON request body, sends it to the KuCoin API, and returns a `data.table`
#' containing the resulting order ID and client order ID.
#'
#' ## Description
#' This endpoint allows users to place a stop order on the KuCoin Spot trading system, which triggers when the market price reaches the specified `stopPrice`. Two types of stop orders are supported:
#' - **Limit Stop Order**: Executes at a specified `price` once triggered, requiring both `price` and `size`.
#' - **Market Stop Order**: Executes as a market order once triggered, requiring either `size` or `funds`.
#'
#' The maximum number of untriggered stop orders per trading pair in one account is 20. The function validates parameters based on the order type and ensures compliance with KuCoin API constraints.
#'
#' ## Workflow
#' 1. **Parameter Validation**: Ensures required fields (`type`, `symbol`, `side`, `stopPrice`) are valid, and type-specific fields (`price`, `size`, `funds`) meet requirements.
#' 2. **Request Construction**: Builds a JSON body with required and optional parameters.
#' 3. **Authentication**: Generates private API headers using `build_headers()` with the POST method, endpoint, and request body.
#' 4. **API Request**: Sends a POST request to the KuCoin API with a 3-second timeout.
#' 5. **Response Processing**: Parses the response, validates success, and returns a `data.table` with `orderId` and `clientOid`.
#'
#' ## API Details
#' - **Endpoint**: `POST https://api.kucoin.com/api/v1/stop-order`
#' - **Domain**: Spot
#' - **API Channel**: Private
#' - **API Permission**: Spot
#' - **Rate Limit Pool**: Spot
#' - **Rate Limit Weight**: 1
#' - **SDK Service**: Spot
#' - **SDK Sub-Service**: Order
#' - **SDK Method Name**: addStopOrder
#' - **Official Documentation**: [KuCoin Add Stop Order](https://www.kucoin.com/docs-new/rest/spot-trading/orders/add-stop-order)
#'
#' ## Request
#' ### Body Parameters (application/json)
#' - `type`: Enum<String> (required) - Order type: "limit" or "market".
#' - `symbol`: String (required) - Trading pair symbol (e.g., "BTC-USDT").
#' - `side`: Enum<String> (required) - Order side: "buy" or "sell".
#' - `clientOid`: String (optional) - Unique client order ID (max 40 characters, alphanumeric, underscores, or hyphens).
#' - `price`: String (optional) - Order price (required for limit orders).
#' - `size`: String (optional) - Order quantity (required for limit orders, optional for market orders if `funds` not provided).
#' - `funds`: String (optional) - Funds for market orders (optional if `size` provided).
#' - `stp`: Enum<String> (optional) - Self Trade Prevention: "DC", "CO", "CN", "CB".
#' - `stopPrice`: String (required) - Trigger price for the stop order.
#' - `remark`: String (optional) - Order remarks (max 20 characters).
#' - `timeInForce`: Enum<String> (optional) - Time in force: "GTC", "GTT", "IOC", "FOK" (required for limit orders).
#' - `cancelAfter`: Integer<int64> (optional) - Cancel after n seconds (for GTT).
#' - `postOnly`: Boolean (optional) - Post-only flag.
#' - `hidden`: Boolean (optional) - Hidden order flag.
#' - `iceberg`: Boolean (optional) - Iceberg order flag.
#' - `visibleSize`: String (optional) - Visible size for iceberg orders.
#' - `tradeType`: String (optional) - Trade type (default "TRADE").
#'
#' ### Example Request
#' ```bash
#' curl --location --request POST 'https://api.kucoin.com/api/v1/stop-order' \
#' --header 'Content-Type: application/json' \
#' --data-raw '{
#'     "type": "limit",
#'     "symbol": "BTC-USDT",
#'     "side": "buy",
#'     "price": "50000",
#'     "size": "0.00001",
#'     "stopPrice": "49000",
#'     "clientOid": "5c52e11203aa677f33e493fb",
#'     "remark": "order remarks"
#' }'
#' ```
#'
#' ## Response
#' ### HTTP Code: 200
#' - **Content Type**: `application/json`
#'
#' ### Data Schema
#' - `code`: String (required) - Response code ("200000" indicates success).
#' - `data`: Object (required) - Contains:
#'   - `orderId`: String (required) - Unique order ID generated by the system.
#'   - `clientOid`: String (required) - Client-assigned order ID from the request.
#'
#' ### JSON Response Example
#' ```json
#' {
#'   "code": "200000",
#'   "data": {
#'     "orderId": "670fd33bf9406e0007ab3945",
#'     "clientOid": "5c52e11203aa677f33e493fb"
#'   }
#' }
#' ```
#'
#' @param keys List; API configuration parameters from `get_api_keys()`. Defaults to `get_api_keys()`.
#' @param base_url Character string; base URL for the KuCoin API. Defaults to `get_base_url()`.
#' @param type Character string; order type: "limit" or "market". Required.
#' @param symbol Character string; trading pair symbol (e.g., "BTC-USDT"). Required.
#' @param side Character string; order side: "buy" or "sell". Required.
#' @param stopPrice Character string; trigger price for the stop order. Required.
#' @param clientOid Character string; unique client order ID (max 40 characters). Optional.
#' @param price Character string; price for limit orders. Required for limit orders.
#' @param size Character string; quantity for the order. Required for limit orders, optional for market orders.
#' @param funds Character string; funds for market orders. Optional for market orders.
#' @param stp Character string; self-trade prevention: "DC", "CO", "CN", "CB". Optional.
#' @param remark Character string; order remarks (max 20 characters). Optional.
#' @param timeInForce Character string; time in force: "GTC", "GTT", "IOC", "FOK". Optional, defaults to "GTC".
#' @param cancelAfter Integer; cancel after n seconds for GTT. Optional.
#' @param postOnly Logical; post-only flag. Optional, defaults to `FALSE`.
#' @param hidden Logical; hidden order flag. Optional, defaults to `FALSE`.
#' @param iceberg Logical; iceberg order flag. Optional, defaults to `FALSE`.
#' @param visibleSize Character string; visible size for iceberg orders. Optional.
#' @param tradeType Character string; trade type (e.g., "TRADE"). Optional, defaults to "TRADE".
#' @return Promise resolving to a `data.table` with:
#'   - `orderId` (character): Unique order ID generated by the system.
#'   - `clientOid` (character): Client-assigned order ID.
#' @examples
#' \dontrun{
#' library(coro)
#' library(data.table)
#'
#' main_async <- coro::async(function() {
#'   # Place a limit stop order
#'   result <- await(add_stop_order_impl(
#'     type = "limit",
#'     symbol = "BTC-USDT",
#'     side = "buy",
#'     stopPrice = "49000",
#'     price = "50000",
#'     size = "0.00001",
#'     clientOid = "5c52e11203aa677f33e493fb",
#'     remark = "order remarks"
#'   ))
#'   print(result)
#'
#'   # Place a market stop order with size
#'   result <- await(add_stop_order_impl(
#'     type = "market",
#'     symbol = "BTC-USDT",
#'     side = "buy",
#'     stopPrice = "49000",
#'     size = "0.00001",
#'     clientOid = "5c52e11203aa677f33e493fc"
#'   ))
#'   print(result)
#'
#'   # Place a market stop order with funds
#'   result <- await(add_stop_order_impl(
#'     type = "market",
#'     symbol = "BTC-USDT",
#'     side = "buy",
#'     stopPrice = "49000",
#'     funds = "1",
#'     clientOid = "5c52e11203aa677f33e493fd"
#'   ))
#'   print(result)
#' })
#'
#' # Run the async function
#' main_async()
#' while (!later::loop_empty()) later::run_now()
#' }
#' @importFrom coro async await
#' @importFrom data.table data.table
#' @importFrom httr POST timeout content_type_json
#' @importFrom jsonlite toJSON
#' @importFrom rlang abort arg_match0
#' @export
add_stop_order_impl <- coro::async(function(
    keys = get_api_keys(),
    base_url = get_base_url(),
    type,
    symbol,
    side,
    stopPrice,
    clientOid = NULL,
    price = NULL,
    size = NULL,
    funds = NULL,
    stp = NULL,
    remark = NULL,
    timeInForce = NULL,
    cancelAfter = NULL,
    postOnly = NULL,
    hidden = NULL,
    iceberg = NULL,
    visibleSize = NULL,
    tradeType = "TRADE"
) {
    tryCatch({
        # Validate required parameters
        if (is.null(type) || !is.character(type)) {
            rlang::abort("Parameter 'type' must be a non-empty string: 'limit' or 'market'.")
        }
        type <- rlang::arg_match0(type, c("limit", "market"), "type")

        if (is.null(symbol) || !verify_symbol(symbol)) {
            rlang::abort("Parameter 'symbol' must be a valid trading pair (e.g., 'BTC-USDT').")
        }

        if (is.null(side) || !is.character(side)) {
            rlang::abort("Parameter 'side' must be a non-empty string: 'buy' or 'sell'.")
        }
        side <- rlang::arg_match0(side, c("buy", "sell"), "side")

        if (is.null(stopPrice) || !is.character(stopPrice) || nchar(stopPrice) == 0) {
            rlang::abort("Parameter 'stopPrice' must be a non-empty string representing the trigger price.")
        }

        # Type-specific validation
        if (type == "limit") {
            if (is.null(price) || !is.character(price) || nchar(price) == 0) {
                rlang::abort("Parameter 'price' is required for limit orders and must be a non-empty string.")
            }
            if (is.null(size) || !is.character(size) || nchar(size) == 0) {
                rlang::abort("Parameter 'size' is required for limit orders and must be a non-empty string.")
            }
            if (!is.null(funds)) {
                rlang::abort("Parameter 'funds' cannot be specified for limit orders.")
            }
        } else if (type == "market") {
            if (!is.null(price)) {
                rlang::abort("Parameter 'price' cannot be specified for market orders.")
            }
            if (is.null(size) && is.null(funds)) {
                rlang::abort("For market orders, either 'size' or 'funds' must be specified.")
            }
            if (!is.null(size) && !is.null(funds)) {
                rlang::abort("For market orders, 'size' and 'funds' cannot both be specified.")
            }
            if (!is.null(size) && (!is.character(size) || nchar(size) == 0)) {
                rlang::abort("Parameter 'size' must be a non-empty string when provided for market orders.")
            }
            if (!is.null(funds) && (!is.character(funds) || nchar(funds) == 0)) {
                rlang::abort("Parameter 'funds' must be a non-empty string when provided for market orders.")
            }
        }

        # Optional parameter validation
        if (!is.null(clientOid) && (!is.character(clientOid) || nchar(clientOid) > 40)) {
            rlang::abort("Parameter 'clientOid' must be a string with a maximum length of 40 characters.")
        }
        if (!is.null(remark) && (!is.character(remark) || nchar(remark) > 20)) {
            rlang::abort("Parameter 'remark' must be a string with a maximum length of 20 characters.")
        }
        if (!is.null(stp)) {
            stp <- rlang::arg_match0(stp, c("DC", "CO", "CN", "CB"), "stp")
        }
        if (!is.null(timeInForce)) {
            timeInForce <- rlang::arg_match0(timeInForce, c("GTC", "GTT", "IOC", "FOK"), "timeInForce")
        }

        # Construct request body
        body_list <- list(
            type = type,
            symbol = symbol,
            side = side,
            stopPrice = stopPrice,
            tradeType = tradeType
        )
        if (!is.null(clientOid)) body_list$clientOid <- clientOid
        if (!is.null(price)) body_list$price <- price
        if (!is.null(size)) body_list$size <- size
        if (!is.null(funds)) body_list$funds <- funds
        if (!is.null(stp)) body_list$stp <- stp
        if (!is.null(remark)) body_list$remark <- remark
        if (!is.null(timeInForce)) body_list$timeInForce <- timeInForce
        if (!is.null(cancelAfter)) body_list$cancelAfter <- as.integer(cancelAfter)
        if (!is.null(postOnly)) body_list$postOnly <- postOnly
        if (!is.null(hidden)) body_list$hidden <- hidden
        if (!is.null(iceberg)) body_list$iceberg <- iceberg
        if (!is.null(visibleSize)) body_list$visibleSize <- visibleSize

        body_json <- jsonlite::toJSON(body_list, auto_unbox = TRUE)

        # Prepare API request
        endpoint <- "/api/v1/stop-order"
        full_url <- paste0(base_url, endpoint)

        # Generate authentication headers
        headers <- await(build_headers("POST", endpoint, body_json, keys))

        # Send POST request
        response <- httr::POST(
            url = full_url,
            body = body_json,
            headers,
            httr::content_type_json(),
            httr::timeout(3)
        )

        # Process response
        parsed_response <- process_kucoin_response(response, full_url)
        if (parsed_response$code != "200000") {
            rlang::abort(sprintf("API error: %s - %s", parsed_response$code, parsed_response$msg))
        }

        # Return as data.table
        result_dt <- data.table::data.table(
            orderId = parsed_response$data$orderId,
            clientOid = parsed_response$data$clientOid
        )
        return(result_dt)
    }, error = function(e) {
        rlang::abort(sprintf("Error in add_stop_order_impl: %s", conditionMessage(e)))
    })
})

#' Cancel Stop Order By ClientOid (Implementation)
#'
#' Cancels a stop order on the KuCoin Spot trading system using its client order ID (`clientOid`) asynchronously.
#' This function sends a cancellation request and returns a `data.table` with the cancelled order's details.
#' Note that this endpoint only initiates cancellation; the actual status must be verified via order status checks or WebSocket subscription.
#'
#' ## Description
#' This endpoint allows users to cancel a stop order identified by its `clientOid`, a user-assigned unique identifier.
#' Stop orders are conditional orders that trigger when the market price reaches a specified `stopPrice`. The function
#' sends a DELETE request to the KuCoin API and returns confirmation details upon successful initiation of the cancellation.
#' The maximum number of untriggered stop orders per trading pair is 20, and this endpoint helps manage that limit by
#' removing specific orders.
#'
#' ## Workflow
#' 1. **Parameter Validation**: Ensures `clientOid` is a non-empty string and, if provided, `symbol` is a valid trading pair.
#' 2. **Request Construction**: Builds the endpoint URL with query parameters `symbol` (optional) and `clientOid` (required).
#' 3. **Authentication**: Generates private API headers using `build_headers()` with the DELETE method and endpoint.
#' 4. **API Request**: Sends a DELETE request to the KuCoin API with a 3-second timeout.
#' 5. **Response Processing**: Parses the response, validates success, and returns a `data.table` with `cancelledOrderId` and `clientOid`.
#'
#' ## API Details
#' - **Endpoint**: `DELETE https://api.kucoin.com/api/v1/stop-order/cancelOrderByClientOid`
#' - **Domain**: Spot
#' - **API Channel**: Private
#' - **API Permission**: Spot
#' - **Rate Limit Pool**: Spot
#' - **Rate Limit Weight**: 5
#' - **SDK Service**: Spot
#' - **SDK Sub-Service**: Order
#' - **SDK Method Name**: cancelStopOrderByClientOid
#' - **Official Documentation**: [KuCoin Cancel Stop Order By ClientOid](https://www.kucoin.com/docs-new/rest/spot-trading/orders/cancel-stop-order-by-clientoid)
#'
#' ## Request
#' ### Query Parameters
#' - `symbol`: String (optional) - The trading pair symbol (e.g., "BTC-USDT").
#' - `clientOid`: String (required) - Unique client order ID created by the user (e.g., "689ff597f4414061aa819cc414836abd").
#'
#' ### Example Request
#' ```bash
#' curl --location --request DELETE 'https://api.kucoin.com/api/v1/stop-order/cancelOrderByClientOid?symbol=BTC-USDT&clientOid=689ff597f4414061aa819cc414836abd'
#' ```
#'
#' ## Response
#' ### HTTP Code: 200
#' - **Content Type**: `application/json`
#'
#' ### Data Schema
#' - `code`: String (required) - Response code ("200000" indicates success).
#' - `data`: Object (required) - Contains:
#'   - `clientOid`: String (required) - Client-assigned order ID from the request.
#'   - `cancelledOrderId`: String (required) - Unique ID of the cancelled order assigned by the system.
#'
#' ### JSON Response Example
#' ```json
#' {
#'   "code": "200000",
#'   "data": {
#'     "cancelledOrderId": "vs8hoo8ksc8mario0035a74n",
#'     "clientOid": "689ff597f4414061aa819cc414836abd"
#'   }
#' }
#' ```
#'
#' @param keys List; API configuration parameters from `get_api_keys()`. Defaults to `get_api_keys()`.
#' @param base_url Character string; base URL for the KuCoin API. Defaults to `get_base_url()`.
#' @param symbol Character string; the trading pair symbol (e.g., "BTC-USDT"). Optional.
#' @param clientOid Character string; the unique client order ID to cancel (e.g., "689ff597f4414061aa819cc414836abd"). Required.
#' @return Promise resolving to a `data.table` with one row containing:
#'   - `cancelledOrderId` (character): Unique ID of the cancelled order.
#'   - `clientOid` (character): Client-assigned order ID.
#' @examples
#' \dontrun{
#' library(coro)
#' library(data.table)
#'
#' main_async <- coro::async(function() {
#'   # Cancel a stop order by clientOid
#'   cancellation <- await(cancel_stop_order_by_client_oid_impl(
#'     symbol = "BTC-USDT",
#'     clientOid = "689ff597f4414061aa819cc414836abd"
#'   ))
#'   print(cancellation)
#' })
#'
#' # Run the async function
#' main_async()
#' while (!later::loop_empty()) later::run_now()
#'
#' # Expected Output:
#' #    cancelledOrderId         clientOid
#' # 1: vs8hoo8ksc8mario0035a74n 689ff597f4414061aa819cc414836abd
#' }
#' @importFrom coro async await
#' @importFrom data.table data.table rbindlist
#' @importFrom httr DELETE timeout
#' @importFrom rlang abort
#' @export
cancel_stop_order_by_client_oid_impl <- coro::async(function(
    keys = get_api_keys(),
    base_url = get_base_url(),
    symbol = NULL,
    clientOid
) {
    tryCatch({
        # Validate parameters
        if (is.null(clientOid) || !is.character(clientOid) || nchar(clientOid) == 0) {
            rlang::abort("Parameter 'clientOid' must be a non-empty string.")
        }
        if (!is.null(symbol) && !verify_symbol(symbol)) {
            rlang::abort("Parameter 'symbol', if provided, must be a valid ticker (e.g., 'BTC-USDT').")
        }

        # Construct endpoint and query string
        endpoint <- "/api/v1/stop-order/cancelOrderByClientOid"
        query_params <- list(clientOid = clientOid)
        if (!is.null(symbol)) query_params$symbol <- symbol
        query_string <- build_query(query_params)
        endpoint_with_query <- paste0(endpoint, query_string)
        full_url <- paste0(base_url, endpoint_with_query)

        # Generate authentication headers
        headers <- await(build_headers("DELETE", endpoint_with_query, NULL, keys))

        # Send DELETE request
        response <- httr::DELETE(
            url = full_url,
            headers,
            httr::timeout(3)
        )

        # Process response
        parsed_response <- process_kucoin_response(response, full_url)
        if (parsed_response$code != "200000") {
            rlang::abort(sprintf("API error: %s - %s", parsed_response$code, parsed_response$msg))
        }

        # Convert response data to data.table
        result_dt <- data.table::data.table(
            cancelledOrderId = parsed_response$data$cancelledOrderId,
            clientOid = parsed_response$data$clientOid
        )

        return(result_dt)
    }, error = function(e) {
        rlang::abort(sprintf("Error in cancel_stop_order_by_client_oid_impl: %s", conditionMessage(e)))
    })
})

#' Cancel Stop Order By OrderId (Implementation)
#'
#' Cancels a stop order on the KuCoin Spot trading system using its system-generated order ID (`orderId`) asynchronously.
#' This function sends a cancellation request and returns a `data.table` with the cancelled order's details.
#' Note that this endpoint only initiates cancellation; the actual status must be verified via order status checks or WebSocket subscription.
#'
#' ## Description
#' This endpoint allows users to cancel a previously placed stop order identified by its `orderId`, which is the unique identifier assigned by the KuCoin system upon order creation. Stop orders are conditional orders that trigger when the market price reaches a specified `stopPrice`. The function sends a DELETE request to the KuCoin API and returns confirmation details upon successful initiation of the cancellation. The maximum number of untriggered stop orders per trading pair is 20, and this endpoint helps manage that limit by removing specific orders.
#'
#' ## Workflow
#' 1. **Parameter Validation**: Ensures `orderId` is a non-empty string.
#' 2. **Request Construction**: Builds the endpoint URL with `orderId` as a path parameter.
#' 3. **Authentication**: Generates private API headers using `build_headers()` with the DELETE method and endpoint.
#' 4. **API Request**: Sends a DELETE request to the KuCoin API with a 3-second timeout.
#' 5. **Response Processing**: Parses the response, validates success, and returns a `data.table` with `cancelledOrderIds`.
#'
#' ## API Details
#' - **Endpoint**: `DELETE https://api.kucoin.com/api/v1/stop-order/{orderId}`
#' - **Domain**: Spot
#' - **API Channel**: Private
#' - **API Permission**: Spot
#' - **Rate Limit Pool**: Spot
#' - **Rate Limit Weight**: 3
#' - **SDK Service**: Spot
#' - **SDK Sub-Service**: Order
#' - **SDK Method Name**: cancelStopOrderByOrderId
#' - **Official Documentation**: [KuCoin Cancel Stop Order By OrderId](https://www.kucoin.com/docs-new/rest/spot-trading/orders/cancel-stop-order-by-orderld)
#'
#' ## Request
#' ### Path Parameters
#' - `orderId`: String (required) - The unique order ID generated by the trading system (e.g., "671124f9365ccb00073debd4").
#'
#' ### Example Request
#' ```bash
#' curl --location --request DELETE 'https://api.kucoin.com/api/v1/stop-order/671124f9365ccb00073debd4'
#' ```
#'
#' ## Response
#' ### HTTP Code: 200
#' - **Content Type**: `application/json`
#'
#' ### Data Schema
#' - `code`: String (required) - Response code ("200000" indicates success).
#' - `data`: Object (required) - Contains:
#'   - `cancelledOrderIds`: Array[String] (required) - Array of order IDs that were cancelled (typically a single ID for this endpoint).
#'
#' ### JSON Response Example
#' ```json
#' {
#'   "code": "200000",
#'   "data": {
#'     "cancelledOrderIds": [
#'       "671124f9365ccb00073debd4"
#'     ]
#'   }
#' }
#' ```
#'
#' @param keys List; API configuration parameters from `get_api_keys()`. Defaults to `get_api_keys()`.
#' @param base_url Character string; base URL for the KuCoin API. Defaults to `get_base_url()`.
#' @param orderId Character string; the unique order ID to cancel (e.g., "671124f9365ccb00073debd4"). Required.
#' @return Promise resolving to a `data.table` with one row containing:
#'   - `cancelledOrderIds` (character): The ID of the cancelled order.
#' @examples
#' \dontrun{
#' library(coro)
#' library(data.table)
#'
#' main_async <- coro::async(function() {
#'   # Cancel a stop order by orderId
#'   cancellation <- await(cancel_stop_order_by_order_id_impl(
#'     orderId = "671124f9365ccb00073debd4"
#'   ))
#'   print(cancellation)
#' })
#'
#' # Run the async function
#' main_async()
#' while (!later::loop_empty()) later::run_now()
#'
#' # Expected Output:
#' #    cancelledOrderIds
#' # 1: 671124f9365ccb00073debd4
#' }
#' @importFrom coro async await
#' @importFrom data.table data.table
#' @importFrom httr DELETE timeout
#' @importFrom rlang abort
#' @export
cancel_stop_order_by_order_id_impl <- coro::async(function(
    keys = get_api_keys(),
    base_url = get_base_url(),
    orderId
) {
    tryCatch({
        # Validate parameters
        if (is.null(orderId) || !is.character(orderId) || nchar(orderId) == 0) {
            rlang::abort("Parameter 'orderId' must be a non-empty string.")
        }

        # Construct endpoint
        endpoint <- paste0("/api/v1/stop-order/", orderId)
        full_url <- paste0(base_url, endpoint)

        # Generate authentication headers
        headers <- await(build_headers("DELETE", endpoint, NULL, keys))

        # Send DELETE request
        response <- httr::DELETE(
            url = full_url,
            headers,
            httr::timeout(3)
        )

        # Process response
        parsed_response <- process_kucoin_response(response, full_url)
        if (parsed_response$code != "200000") {
            rlang::abort(sprintf("API error: %s - %s", parsed_response$code, parsed_response$msg))
        }

        # Convert response data to data.table
        result_dt <- data.table::data.table(
            cancelledOrderIds = parsed_response$data$cancelledOrderIds
        )

        return(result_dt)
    }, error = function(e) {
        rlang::abort(sprintf("Error in cancel_stop_order_by_order_id_impl: %s", conditionMessage(e)))
    })
})

#' Get Stop Orders List (Implementation)
#'
#' Retrieves a paginated list of untriggered stop orders from the KuCoin Spot trading system asynchronously.
#' This function constructs a GET request to the KuCoin API and returns a promise that resolves to a `data.table`
#' containing details of stop orders, sorted by the latest update time in descending order.
#'
#' ## Description
#' This endpoint fetches a list of stop orders that have not yet been triggered. Stop orders are conditional orders
#' that become active when the market price reaches a specified `stopPrice`. The list is paginated and sorted to show
#' the most recent orders first. Users can filter the results using various query parameters such as `symbol`, `side`,
#' `type`, and time range.
#'
#' ## Workflow
#' 1. **Parameter Validation**: Ensures that provided parameters are valid, such as `symbol`, `side`, `type`, and pagination settings.
#' 2. **Request Construction**: Builds the endpoint URL with query parameters for filtering and pagination.
#' 3. **Authentication**: Generates private API headers using `build_headers()` with the GET method and endpoint.
#' 4. **API Request**: Sends a GET request to the KuCoin API with a 3-second timeout.
#' 5. **Response Processing**: Parses the response, converts the `items` array to a `data.table`, and adds datetime columns for `createdAt` and `orderTime`.
#'
#' ## API Details
#' - **Endpoint**: `GET https://api.kucoin.com/api/v1/stop-order`
#' - **Domain**: Spot
#' - **API Channel**: Private
#' - **API Permission**: General
#' - **Rate Limit Pool**: Spot
#' - **Rate Limit Weight**: 8
#' - **SDK Service**: Spot
#' - **SDK Sub-Service**: Order
#' - **SDK Method Name**: getStopOrdersList
#' - **Official Documentation**: [KuCoin Get Stop Orders List](https://www.kucoin.com/docs-new/rest/spot-trading/orders/get-stop-orders-list)
#'
#' ## Request
#' ### Query Parameters
#' - `symbol`: String (optional) - Filter by trading pair (e.g., "BTC-USDT").
#' - `side`: Enum<String> (optional) - Filter by order side: "buy" or "sell".
#' - `type`: Enum<String> (optional) - Filter by order type: "limit", "market", "limit_stop", "market_stop".
#' - `tradeType`: Enum<String> (optional) - Filter by trade type: "TRADE", "MARGIN_TRADE", "MARGIN_ISOLATED_TRADE".
#' - `startAt`: Integer<int64> (optional) - Start time in milliseconds.
#' - `endAt`: Integer<int64> (optional) - End time in milliseconds.
#' - `currentPage`: Integer (optional) - Current page number.
#' - `orderIds`: String (optional) - Comma-separated list of order IDs.
#' - `pageSize`: Integer (optional) - Number of orders per page.
#' - `stop`: String (optional) - Filter by stop order type: "stop" or "oco".
#'
#' ### Example Request
#' ```bash
#' curl --location --request GET 'https://api.kucoin.com/api/v1/stop-order?symbol=BTC-USDT&side=buy&pageSize=10'
#' ```
#'
#' ## Response
#' ### HTTP Code: 200
#' - **Content Type**: `application/json`
#'
#' ### Data Schema
#' - `code`: String (required) - Response code ("200000" indicates success).
#' - `data`: Object (required) - Contains:
#'   - `currentPage`: Integer - Current page number.
#'   - `pageSize`: Integer - Number of orders per page.
#'   - `totalNum`: Integer - Total number of stop orders.
#'   - `totalPage`: Integer - Total number of pages.
#'   - `items`: Array of objects - List of stop orders, each with fields such as:
#'     - `id`: String - Order ID.
#'     - `symbol`: String - Trading pair.
#'     - `userId`: String - User ID.
#'     - `status`: String - Order status.
#'     - `type`: String - Order type.
#'     - `side`: String - Order side.
#'     - `price`: String - Order price.
#'     - `size`: String - Order size.
#'     - `funds`: String - Order funds.
#'     - `stp`: String - Self Trade Prevention.
#'     - `timeInForce`: String - Time in force.
#'     - `cancelAfter`: Integer - Cancel after n seconds.
#'     - `postOnly`: Boolean - Post-only flag.
#'     - `hidden`: Boolean - Hidden order flag.
#'     - `iceberg`: Boolean - Iceberg order flag.
#'     - `visibleSize`: String - Visible size for iceberg orders.
#'     - `channel`: String - Order channel.
#'     - `clientOid`: String - Client order ID.
#'     - `remark`: String - Order remarks.
#'     - `tags`: String - Order tags.
#'     - `orderTime`: Integer - Order time in nanoseconds.
#'     - `domainId`: String - Domain ID.
#'     - `tradeSource`: String - Trade source.
#'     - `tradeType`: String - Trade type.
#'     - `feeCurrency`: String - Fee currency.
#'     - `takerFeeRate`: String - Taker fee rate.
#'     - `makerFeeRate`: String - Maker fee rate.
#'     - `createdAt`: Integer - Creation timestamp in milliseconds.
#'     - `stop`: String - Stop order type.
#'     - `stopTriggerTime`: Integer - Stop trigger time.
#'     - `stopPrice`: String - Stop price.
#'
#' ### JSON Response Example
#' ```json
#' {
#'   "code": "200000",
#'   "data": {
#'     "currentPage": 1,
#'     "pageSize": 50,
#'     "totalNum": 1,
#'     "totalPage": 1,
#'     "items": [
#'       {
#'         "id": "vs8hoo8kqjnklv4m0038lrfq",
#'         "symbol": "KCS-USDT",
#'         "userId": "60fe4956c43cbc0006562c2c",
#'         "status": "NEW",
#'         "type": "limit",
#'         "side": "buy",
#'         "price": "0.01000000000000000000",
#'         "size": "0.01000000000000000000",
#'         "funds": null,
#'         "stp": null,
#'         "timeInForce": "GTC",
#'         "cancelAfter": -1,
#'         "postOnly": false,
#'         "hidden": false,
#'         "iceberg": false,
#'         "visibleSize": null,
#'         "channel": "API",
#'         "clientOid": "404814a0fb4311eb9098acde48001122",
#'         "remark": null,
#'         "tags": null,
#'         "orderTime": 1628755183702150167,
#'         "domainId": "kucoin",
#'         "tradeSource": "USER",
#'         "tradeType": "TRADE",
#'         "feeCurrency": "USDT",
#'         "takerFeeRate": "0.00200000000000000000",
#'         "makerFeeRate": "0.00200000000000000000",
#'         "createdAt": 1628755183704,
#'         "stop": "loss",
#'         "stopTriggerTime": null,
#'         "stopPrice": "10.00000000000000000000"
#'       }
#'     ]
#'   }
#' }
#' ```
#'
#' @param keys List; API configuration parameters from `get_api_keys()`. Defaults to `get_api_keys()`.
#' @param base_url Character string; base URL for the KuCoin API. Defaults to `get_base_url()`.
#' @param query Named list; query parameters for filtering and pagination (e.g., `list(symbol = "BTC-USDT", side = "buy", pageSize = 10)`). Optional.
#' @return Promise resolving to a `data.table` containing stop order details, with the following columns:
#'   - `id` (character): Unique order ID assigned by KuCoin.
#'   - `symbol` (character): Trading pair (e.g., "KCS-USDT").
#'   - `userId` (character): User ID associated with the order.
#'   - `status` (character): Order status (e.g., "NEW", "TRIGGERED").
#'   - `type` (character): Order type (e.g., "limit", "market").
#'   - `side` (character): Order side ("buy" or "sell").
#'   - `price` (character): Order price.
#'   - `size` (character): Order size.
#'   - `funds` (character or NA): Order funds (NULL for untriggered orders).
#'   - `stp` (character or NA): Self Trade Prevention strategy (e.g., "DC", "CO", "CN", "CB").
#'   - `timeInForce` (character): Time in force (e.g., "GTC", "GTT", "IOC", "FOK").
#'   - `cancelAfter` (integer): Seconds until cancellation for GTT (-1 if not applicable).
#'   - `postOnly` (logical): Whether the order is post-only.
#'   - `hidden` (logical): Whether the order is hidden.
#'   - `iceberg` (logical): Whether the order is an iceberg order.
#'   - `visibleSize` (character or NA): Visible size for iceberg orders.
#'   - `channel` (character): Order source (e.g., "API").
#'   - `clientOid` (character): Client-assigned order ID.
#'   - `remark` (character or NA): Order remarks.
#'   - `tags` (character or NA): Order tags.
#'   - `orderTime` (numeric): Order creation time in nanoseconds.
#'   - `domainId` (character): Domain ID (e.g., "kucoin").
#'   - `tradeSource` (character): Trade source (e.g., "USER").
#'   - `tradeType` (character): Trade type (e.g., "TRADE").
#'   - `feeCurrency` (character): Currency used for fees.
#'   - `takerFeeRate` (character): Taker fee rate.
#'   - `makerFeeRate` (character): Maker fee rate.
#'   - `createdAt` (integer): Creation timestamp in milliseconds.
#'   - `stop` (character): Stop order type (e.g., "loss", "entry").
#'   - `stopTriggerTime` (integer or NA): Trigger time in milliseconds (NULL if untriggered).
#'   - `stopPrice` (character): Stop price.
#'   - `createdAtDatetime` (POSIXct): Creation time in UTC (derived from `createdAt`).
#'   - `orderTimeDatetime` (POSIXct): Order placement time in UTC (derived from `orderTime`).
#' @examples
#' \dontrun{
#' library(coro)
#' library(data.table)
#'
#' main_async <- coro::async(function() {
#'   # Retrieve stop orders list for BTC-USDT
#'   stop_orders <- await(get_stop_order_list_impl(
#'     query = list(symbol = "BTC-USDT", side = "buy", pageSize = 10)
#'   ))
#'   print(stop_orders)
#' })
#'
#' # Run the async function
#' main_async()
#' while (!later::loop_empty()) later::run_now()
#' }
#' @importFrom coro async await
#' @importFrom data.table data.table rbindlist
#' @importFrom httr GET timeout
#' @importFrom rlang abort
#' @export
get_stop_order_list_impl <- coro::async(function(
    keys = get_api_keys(),
    base_url = get_base_url(),
    query = list()
) {
    tryCatch({
        # Validate parameters
        if (!is.list(query)) {
            rlang::abort("Parameter 'query' must be a named list.")
        }
        if ("symbol" %in% names(query) && !is.null(query$symbol) && !verify_symbol(query$symbol)) {
            rlang::abort("Parameter 'query$symbol', if provided, must be a valid trading pair (e.g., 'BTC-USDT').")
        }

        # Construct endpoint and query string
        endpoint <- "/api/v1/stop-order"
        query_string <- build_query(query)
        full_url <- paste0(base_url, endpoint, query_string)

        # Generate authentication headers
        headers <- await(build_headers("GET", paste0(endpoint, query_string), NULL, keys))

        # Send GET request
        response <- httr::GET(
            url = full_url,
            headers,
            httr::timeout(3)
        )

        # Process response
        parsed_response <- process_kucoin_response(response, full_url)
        if (parsed_response$code != "200000") {
            rlang::abort(sprintf("API error: %s - %s", parsed_response$code, parsed_response$msg))
        }

        # Convert response data to data.table
        if (length(parsed_response$data$items) == 0) {
            stop_orders_dt <- data.table::data.table(
                id = character(),
                symbol = character(),
                userId = character(),
                status = character(),
                type = character(),
                side = character(),
                price = character(),
                size = character(),
                funds = character(),
                stp = character(),
                timeInForce = character(),
                cancelAfter = integer(),
                postOnly = logical(),
                hidden = logical(),
                iceberg = logical(),
                visibleSize = character(),
                channel = character(),
                clientOid = character(),
                remark = character(),
                tags = character(),
                orderTime = numeric(),
                domainId = character(),
                tradeSource = character(),
                tradeType = character(),
                feeCurrency = character(),
                takerFeeRate = character(),
                makerFeeRate = character(),
                createdAt = integer(),
                stop = character(),
                stopTriggerTime = integer(),
                stopPrice = character(),
                createdAtDatetime = as.POSIXct(character()),
                orderTimeDatetime = as.POSIXct(character())
            )
        } else {
            stop_orders_dt <- data.table::rbindlist(parsed_response$data$items, fill = TRUE)
            stop_orders_dt[, createdAtDatetime := time_convert_from_kucoin(createdAt, unit = "ms")]
            stop_orders_dt[, orderTimeDatetime := time_convert_from_kucoin(orderTime, unit = "ns")]
        }

        return(stop_orders_dt)
    }, error = function(e) {
        rlang::abort(sprintf("Error in get_stop_order_list_impl: %s", conditionMessage(e)))
    })
})

#' Get Stop Order By OrderId (Implementation)
#'
#' Retrieves detailed information for a single stop order using its order ID from the KuCoin Spot trading system asynchronously.
#' This function constructs a GET request to the KuCoin API and returns a promise that resolves to a `data.table`
#' with comprehensive stop order details, including additional UTC datetime columns derived from timestamps.
#'
#' ## Description
#' This endpoint fetches data for a specific stop order identified by its `orderId`, which is the unique identifier
#' assigned by the KuCoin system when the order is created. The stop order can be in various states, such as "NEW"
#' (untriggered) or "TRIGGERED" (activated).
#'
#' ## Workflow
#' 1. **Parameter Validation**: Ensures `orderId` is a non-empty string.
#' 2. **Request Construction**: Builds the endpoint URL with `orderId` as a path parameter.
#' 3. **Authentication**: Generates private API headers using `build_headers()` with the GET method and endpoint.
#' 4. **API Request**: Sends a GET request to the KuCoin API with a 3-second timeout.
#' 5. **Response Processing**: Parses the response, converts the `data` object to a `data.table`, and adds `createdAtDatetime` and `orderTimeDatetime` columns.
#'
#' ## API Details
#' - **Endpoint**: `GET https://api.kucoin.com/api/v1/stop-order/{orderId}`
#' - **Domain**: Spot
#' - **API Channel**: Private
#' - **API Permission**: General
#' - **Rate Limit Pool**: Spot
#' - **Rate Limit Weight**: 3
#' - **SDK Service**: Spot
#' - **SDK Sub-Service**: Order
#' - **SDK Method Name**: getStopOrderByOrderId
#' - **Official Documentation**: [KuCoin Get Stop Order By OrderId](https://www.kucoin.com/docs-new/rest/spot-trading/orders/get-stop-order-by-orderld)
#'
#' ## Request
#' ### Path Parameters
#' - `orderId`: String (required) - The unique order ID generated by the trading system (e.g., "vs8hoo8q2ceshiue003b67c0").
#'
#' ### Example Request
#' ```bash
#' curl --location --request GET 'https://api.kucoin.com/api/v1/stop-order/vs8hoo8q2ceshiue003b67c0'
#' ```
#'
#' ## Response
#' ### HTTP Code: 200
#' - **Content Type**: `application/json`
#'
#' ### Data Schema
#' - `code`: String (required) - Response code ("200000" indicates success).
#' - `data`: Object (required) - Stop order details with fields such as:
#'   - `id`: String - Order ID.
#'   - `symbol`: String - Trading pair.
#'   - `userId`: String - User ID.
#'   - `status`: String - Order status.
#'   - `type`: String - Order type.
#'   - `side`: String - Order side.
#'   - `price`: String - Order price.
#'   - `size`: String - Order size.
#'   - `funds`: String - Order funds.
#'   - `stp`: String - Self Trade Prevention.
#'   - `timeInForce`: String - Time in force.
#'   - `cancelAfter`: Integer - Cancel after n seconds.
#'   - `postOnly`: Boolean - Post-only flag.
#'   - `hidden`: Boolean - Hidden order flag.
#'   - `iceberg`: Boolean - Iceberg order flag.
#'   - `visibleSize`: String - Visible size for iceberg orders.
#'   - `channel`: String - Order channel.
#'   - `clientOid`: String - Client order ID.
#'   - `remark`: String - Order remarks.
#'   - `tags`: String - Order tags.
#'   - `orderTime`: Integer - Order time in nanoseconds.
#'   - `domainId`: String - Domain ID.
#'   - `tradeSource`: String - Trade source.
#'   - `tradeType`: String - Trade type.
#'   - `feeCurrency`: String - Fee currency.
#'   - `takerFeeRate`: String - Taker fee rate.
#'   - `makerFeeRate`: String - Maker fee rate.
#'   - `createdAt`: Integer - Creation timestamp in milliseconds.
#'   - `stop`: String - Stop order type.
#'   - `stopTriggerTime`: Integer - Stop trigger time.
#'   - `stopPrice`: String - Stop price.
#'
#' ### JSON Response Example
#' ```json
#' {
#'   "code": "200000",
#'   "data": {
#'     "id": "vs8hoo8q2ceshiue003b67c0",
#'     "symbol": "KCS-USDT",
#'     "userId": "60fe4956c43cbc0006562c2c",
#'     "status": "NEW",
#'     "type": "limit",
#'     "side": "buy",
#'     "price": "0.01000000000000000000",
#'     "size": "0.01000000000000000000",
#'     "funds": null,
#'     "stp": null,
#'     "timeInForce": "GTC",
#'     "cancelAfter": -1,
#'     "postOnly": false,
#'     "hidden": false,
#'     "iceberg": false,
#'     "visibleSize": null,
#'     "channel": "API",
#'     "clientOid": "40e0eb9efe6311eb8e58acde48001122",
#'     "remark": null,
#'     "tags": null,
#'     "orderTime": 1629098781127530345,
#'     "domainId": "kucoin",
#'     "tradeSource": "USER",
#'     "tradeType": "TRADE",
#'     "feeCurrency": "USDT",
#'     "takerFeeRate": "0.00200000000000000000",
#'     "makerFeeRate": "0.00200000000000000000",
#'     "createdAt": 1629098781128,
#'     "stop": "loss",
#'     "stopTriggerTime": null,
#'     "stopPrice": "10.00000000000000000000"
#'   }
#' }
#' ```
#'
#' @param keys List; API configuration parameters from `get_api_keys()`. Defaults to `get_api_keys()`.
#' @param base_url Character string; base URL for the KuCoin API. Defaults to `get_base_url()`.
#' @param orderId Character string; the unique order ID to retrieve (e.g., "vs8hoo8q2ceshiue003b67c0"). Required.
#' @return Promise resolving to a `data.table` with one row containing stop order details, with the following columns:
#'   - `id` (character): Unique order ID assigned by KuCoin.
#'   - `symbol` (character): Trading pair (e.g., "KCS-USDT").
#'   - `userId` (character): User ID associated with the order.
#'   - `status` (character): Order status (e.g., "NEW", "TRIGGERED").
#'   - `type` (character): Order type (e.g., "limit", "market").
#'   - `side` (character): Order side ("buy" or "sell").
#'   - `price` (character): Order price.
#'   - `size` (character): Order size.
#'   - `funds` (character or NA): Order funds (NULL for untriggered orders).
#'   - `stp` (character or NA): Self Trade Prevention strategy (e.g., "DC", "CO", "CN", "CB").
#'   - `timeInForce` (character): Time in force (e.g., "GTC", "GTT", "IOC", "FOK").
#'   - `cancelAfter` (integer): Seconds until cancellation for GTT (-1 if not applicable).
#'   - `postOnly` (logical): Whether the order is post-only.
#'   - `hidden` (logical): Whether the order is hidden.
#'   - `iceberg` (logical): Whether the order is an iceberg order.
#'   - `visibleSize` (character or NA): Visible size for iceberg orders.
#'   - `channel` (character): Order source (e.g., "API").
#'   - `clientOid` (character): Client-assigned order ID.
#'   - `remark` (character or NA): Order remarks.
#'   - `tags` (character or NA): Order tags.
#'   - `orderTime` (numeric): Order creation time in nanoseconds.
#'   - `domainId` (character): Domain ID (e.g., "kucoin").
#'   - `tradeSource` (character): Trade source (e.g., "USER").
#'   - `tradeType` (character): Trade type (e.g., "TRADE").
#'   - `feeCurrency` (character): Currency used for fees.
#'   - `takerFeeRate` (character): Taker fee rate.
#'   - `makerFeeRate` (character): Maker fee rate.
#'   - `createdAt` (integer): Creation timestamp in milliseconds.
#'   - `stop` (character): Stop order type (e.g., "loss", "entry").
#'   - `stopTriggerTime` (integer or NA): Trigger time in milliseconds (NULL if untriggered).
#'   - `stopPrice` (character): Stop price.
#'   - `createdAtDatetime` (POSIXct): Creation time in UTC (derived from `createdAt`).
#'   - `orderTimeDatetime` (POSIXct): Order placement time in UTC (derived from `orderTime`).
#' @examples
#' \dontrun{
#' library(coro)
#' library(data.table)
#'
#' main_async <- coro::async(function() {
#'   # Retrieve stop order details by orderId
#'   stop_order_details <- await(get_stop_order_by_order_id_impl(
#'     orderId = "vs8hoo8q2ceshiue003b67c0"
#'   ))
#'   print(stop_order_details)
#' })
#'
#' # Run the async function
#' main_async()
#' while (!later::loop_empty()) later::run_now()
#' }
#' @importFrom coro async await
#' @importFrom data.table data.table rbindlist
#' @importFrom httr GET timeout
#' @importFrom rlang abort
#' @export
get_stop_order_by_order_id_impl <- coro::async(function(
    keys = get_api_keys(),
    base_url = get_base_url(),
    orderId
) {
    tryCatch({
        # Validate parameters
        if (is.null(orderId) || !is.character(orderId) || nchar(orderId) == 0) {
            rlang::abort("Parameter 'orderId' must be a non-empty string.")
        }

        # Construct endpoint
        endpoint <- paste0("/api/v1/stop-order/", orderId)
        full_url <- paste0(base_url, endpoint)

        # Generate authentication headers
        headers <- await(build_headers("GET", endpoint, NULL, keys))

        # Send GET request
        response <- httr::GET(
            url = full_url,
            headers,
            httr::timeout(3)
        )

        # Process response
        parsed_response <- process_kucoin_response(response, full_url)
        if (parsed_response$code != "200000") {
            rlang::abort(sprintf("API error: %s - %s", parsed_response$code, parsed_response$msg))
        }

        # Convert response data to data.table
        stop_order_details <- data.table::rbindlist(list(parsed_response$data), fill = TRUE)

        # Add datetime columns from millisecond and nanosecond timestamps
        stop_order_details[, createdAtDatetime := time_convert_from_kucoin(createdAt, unit = "ms")]
        stop_order_details[, orderTimeDatetime := time_convert_from_kucoin(orderTime, unit = "ns")]

        return(stop_order_details)
    }, error = function(e) {
        rlang::abort(sprintf("Error in get_stop_order_by_order_id_impl: %s", conditionMessage(e)))
    })
})

#' Get Stop Order By ClientOid (Implementation)
#'
#' Retrieves detailed information for a single stop order using its client order ID (`clientOid`) from the KuCoin Spot trading system asynchronously.
#' This function constructs a GET request to the KuCoin API and returns a promise that resolves to a `data.table`
#' with comprehensive stop order details, including additional UTC datetime columns derived from timestamps.
#'
#' ## Description
#' This endpoint fetches data for a specific stop order identified by its `clientOid`, a unique identifier assigned
#' by the user when placing the order. The stop order can be in various states, such as "NEW" (untriggered) or
#' "TRIGGERED" (activated).
#'
#' ## Workflow
#' 1. **Parameter Validation**: Ensures `clientOid` is a non-empty string and `symbol` (if provided) is a valid trading pair.
#' 2. **Request Construction**: Builds the endpoint URL with query parameters `clientOid` and optionally `symbol`.
#' 3. **Authentication**: Generates private API headers using `build_headers()` with the GET method and endpoint.
#' 4. **API Request**: Sends a GET request to the KuCoin API with a 3-second timeout.
#' 5. **Response Processing**: Parses the response, converts the `data` array to a `data.table`, and adds `createdAtDatetime` and `orderTimeDatetime` columns.
#'
#' ## API Details
#' - **Endpoint**: `GET https://api.kucoin.com/api/v1/stop-order/queryOrderByClientOid`
#' - **Domain**: Spot
#' - **API Channel**: Private
#' - **API Permission**: General
#' - **Rate Limit Pool**: Spot
#' - **Rate Limit Weight**: 3
#' - **SDK Service**: Spot
#' - **SDK Sub-Service**: Order
#' - **SDK Method Name**: getStopOrderByClientOid
#' - **Official Documentation**: [KuCoin Get Stop Order By ClientOid](https://www.kucoin.com/docs-new/rest/spot-trading/get-stop-order-by-clientoid)
#'
#' ## Request
#' ### Query Parameters
#' - `clientOid`: String (required) - The unique client order ID (e.g., "2b700942b5db41cebe578cff48960e09").
#' - `symbol`: String (optional) - The trading pair symbol (e.g., "KCS-USDT").
#'
#' ### Example Request
#' ```bash
#' curl --location --request GET 'https://api.kucoin.com/api/v1/stop-order/queryOrderByClientOid?clientOid=404814a0fb4311eb9098acde48001122&symbol=KCS-USDT'
#' ```
#'
#' ## Response
#' ### HTTP Code: 200
#' - **Content Type**: `application/json`
#'
#' ### Data Schema
#' - `code`: String (required) - Response code ("200000" indicates success).
#' - `data`: Array of objects (required) - List of stop order details (typically one item), each with fields such as:
#'   - `id`: String - Order ID.
#'   - `symbol`: String - Trading pair.
#'   - `userId`: String - User ID.
#'   - `status`: String - Order status.
#'   - `type`: String - Order type.
#'   - `side`: String - Order side.
#'   - `price`: String - Order price.
#'   - `size`: String - Order size.
#'   - `funds`: String - Order funds.
#'   - `stp`: String - Self Trade Prevention.
#'   - `timeInForce`: String - Time in force.
#'   - `cancelAfter`: Integer - Cancel after n seconds.
#'   - `postOnly`: Boolean - Post-only flag.
#'   - `hidden`: Boolean - Hidden order flag.
#'   - `iceberg`: Boolean - Iceberg order flag.
#'   - `visibleSize`: String - Visible size for iceberg orders.
#'   - `channel`: String - Order channel.
#'   - `clientOid`: String - Client order ID.
#'   - `remark`: String - Order remarks.
#'   - `tags`: String - Order tags.
#'   - `orderTime`: Integer - Order time in nanoseconds.
#'   - `domainId`: String - Domain ID.
#'   - `tradeSource`: String - Trade source.
#'   - `tradeType`: String - Trade type.
#'   - `feeCurrency`: String - Fee currency.
#'   - `takerFeeRate`: String - Taker fee rate.
#'   - `makerFeeRate`: String - Maker fee rate.
#'   - `createdAt`: Integer - Creation timestamp in milliseconds.
#'   - `stop`: String - Stop order type.
#'   - `stopTriggerTime`: Integer - Stop trigger time.
#'   - `stopPrice`: String - Stop price.
#'
#' ### JSON Response Example
#' ```json
#' {
#'   "code": "200000",
#'   "data": [
#'     {
#'       "id": "vs8hoo8os561f5np0032vngj",
#'       "symbol": "KCS-USDT",
#'       "userId": "60fe4956c43cbc0006562c2c",
#'       "status": "NEW",
#'       "type": "limit",
#'       "side": "buy",
#'       "price": "0.01000000000000000000",
#'       "size": "0.01000000000000000000",
#'       "funds": null,
#'       "stp": null,
#'       "timeInForce": "GTC",
#'       "cancelAfter": -1,
#'       "postOnly": false,
#'       "hidden": false,
#'       "iceberg": false,
#'       "visibleSize": null,
#'       "channel": "API",
#'       "clientOid": "2b700942b5db41cebe578cff48960e09",
#'       "remark": null,
#'       "tags": null,
#'       "orderTime": 1629020492834532600,
#'       "domainId": "kucoin",
#'       "tradeSource": "USER",
#'       "tradeType": "TRADE",
#'       "feeCurrency": "USDT",
#'       "takerFeeRate": "0.00200000000000000000",
#'       "makerFeeRate": "0.00200000000000000000",
#'       "createdAt": 1629020492837,
#'       "stop": "loss",
#'       "stopTriggerTime": null,
#'       "stopPrice": "1.00000000000000000000"
#'     }
#'   ]
#' }
#' ```
#'
#' @param keys List; API configuration parameters from `get_api_keys()`. Defaults to `get_api_keys()`.
#' @param base_url Character string; base URL for the KuCoin API. Defaults to `get_base_url()`.
#' @param clientOid Character string; the unique client order ID to retrieve (e.g., "2b700942b5db41cebe578cff48960e09"). Required.
#' @param symbol Character string; the trading pair symbol (e.g., "KCS-USDT"). Optional.
#' @return Promise resolving to a `data.table` with typically one row containing stop order details, with the following columns:
#'   - `id` (character): Unique order ID assigned by KuCoin.
#'   - `symbol` (character): Trading pair (e.g., "KCS-USDT").
#'   - `userId` (character): User ID associated with the order.
#'   - `status` (character): Order status (e.g., "NEW", "TRIGGERED").
#'   - `type` (character): Order type (e.g., "limit", "market").
#'   - `side` (character): Order side ("buy" or "sell").
#'   - `price` (character): Order price.
#'   - `size` (character): Order size.
#'   - `funds` (character or NA): Order funds (NULL for untriggered orders).
#'   - `stp` (character or NA): Self Trade Prevention strategy (e.g., "DC", "CO", "CN", "CB").
#'   - `timeInForce` (character): Time in force (e.g., "GTC", "GTT", "IOC", "FOK").
#'   - `cancelAfter` (integer): Seconds until cancellation for GTT (-1 if not applicable).
#'   - `postOnly` (logical): Whether the order is post-only.
#'   - `hidden` (logical): Whether the order is hidden.
#'   - `iceberg` (logical): Whether the order is an iceberg order.
#'   - `visibleSize` (character or NA): Visible size for iceberg orders.
#'   - `channel` (character): Order source (e.g., "API").
#'   - `clientOid` (character): Client-assigned order ID.
#'   - `remark` (character or NA): Order remarks.
#'   - `tags` (character or NA): Order tags.
#'   - `orderTime` (numeric): Order creation time in nanoseconds.
#'   - `domainId` (character): Domain ID (e.g., "kucoin").
#'   - `tradeSource` (character): Trade source (e.g., "USER").
#'   - `tradeType` (character): Trade type (e.g., "TRADE").
#'   - `feeCurrency` (character): Currency used for fees.
#'   - `takerFeeRate` (character): Taker fee rate.
#'   - `makerFeeRate` (character): Maker fee rate.
#'   - `createdAt` (integer): Creation timestamp in milliseconds.
#'   - `stop` (character): Stop order type (e.g., "loss", "entry").
#'   - `stopTriggerTime` (integer or NA): Trigger time in milliseconds (NULL if untriggered).
#'   - `stopPrice` (character): Stop price.
#'   - `createdAtDatetime` (POSIXct): Creation time in UTC (derived from `createdAt`).
#'   - `orderTimeDatetime` (POSIXct): Order placement time in UTC (derived from `orderTime`).
#' @examples
#' \dontrun{
#' library(coro)
#' library(data.table)
#'
#' main_async <- coro::async(function() {
#'   # Retrieve stop order details by clientOid
#'   stop_order_details <- await(get_stop_order_by_client_oid_impl(
#'     clientOid = "2b700942b5db41cebe578cff48960e09",
#'     symbol = "KCS-USDT"
#'   ))
#'   print(stop_order_details)
#' })
#'
#' # Run the async function
#' main_async()
#' while (!later::loop_empty()) later::run_now()
#' }
#' @importFrom coro async await
#' @importFrom data.table data.table rbindlist
#' @importFrom httr GET timeout
#' @importFrom rlang abort
#' @export
get_stop_order_by_client_oid_impl <- coro::async(function(
    keys = get_api_keys(),
    base_url = get_base_url(),
    clientOid,
    symbol = NULL
) {
    tryCatch({
        # Validate parameters
        if (is.null(clientOid) || !is.character(clientOid) || nchar(clientOid) == 0) {
            rlang::abort("Parameter 'clientOid' must be a non-empty string.")
        }
        if (!is.null(symbol) && !verify_symbol(symbol)) {
            rlang::abort("Parameter 'symbol', if provided, must be a valid trading pair (e.g., 'KCS-USDT').")
        }

        # Construct endpoint and query string
        endpoint <- "/api/v1/stop-order/queryOrderByClientOid"
        query_params <- list(clientOid = clientOid)
        if (!is.null(symbol)) {
            query_params$symbol <- symbol
        }
        query_string <- build_query(query_params)
        full_url <- paste0(base_url, endpoint, query_string)

        # Generate authentication headers
        headers <- await(build_headers("GET", paste0(endpoint, query_string), NULL, keys))

        # Send GET request
        response <- httr::GET(
            url = full_url,
            headers,
            httr::timeout(3)
        )

        # Process response
        parsed_response <- process_kucoin_response(response, full_url)
        if (parsed_response$code != "200000") {
            rlang::abort(sprintf("API error: %s - %s", parsed_response$code, parsed_response$msg))
        }

        # Convert response data to data.table
        if (length(parsed_response$data) == 0) {
            stop_order_details <- data.table::data.table(
                id = character(),
                symbol = character(),
                userId = character(),
                status = character(),
                type = character(),
                side = character(),
                price = character(),
                size = character(),
                funds = character(),
                stp = character(),
                timeInForce = character(),
                cancelAfter = integer(),
                postOnly = logical(),
                hidden = logical(),
                iceberg = logical(),
                visibleSize = character(),
                channel = character(),
                clientOid = character(),
                remark = character(),
                tags = character(),
                orderTime = numeric(),
                domainId = character(),
                tradeSource = character(),
                tradeType = character(),
                feeCurrency = character(),
                takerFeeRate = character(),
                makerFeeRate = character(),
                createdAt = integer(),
                stop = character(),
                stopTriggerTime = integer(),
                stopPrice = character(),
                createdAtDatetime = as.POSIXct(character()),
                orderTimeDatetime = as.POSIXct(character())
            )
        } else {
            stop_order_details <- data.table::rbindlist(parsed_response$data, fill = TRUE)
            stop_order_details[, createdAtDatetime := time_convert_from_kucoin(createdAt, unit = "ms")]
            stop_order_details[, orderTimeDatetime := time_convert_from_kucoin(orderTime, unit = "ns")]
        }

        return(stop_order_details)
    }, error = function(e) {
        rlang::abort(sprintf("Error in get_stop_order_by_client_oid_impl: %s", conditionMessage(e)))
    })
})

#' Batch Cancel Stop Orders (Implementation)
#'
#' Cancels a batch of stop orders on the KuCoin Spot trading system asynchronously by sending a DELETE request to the `/api/v1/stop-order/cancel` endpoint.
#' Returns a `data.table` with the IDs of the canceled stop orders.
#'
#' ## What is a Stop Order and Batch Cancellation?
#' A stop order is a conditional order that triggers a market or limit order when a specified price (stop price) is reached, commonly used for:
#' - **Loss Limiting**: Sell an asset if its price drops to a threshold (e.g., sell BTC at $48,000 if it falls from $50,000).
#' - **Breakout Trading**: Buy an asset if its price rises past a resistance level (e.g., buy BTC at $52,000 if it breaks $51,000).
#' Batch cancellation allows you to cancel multiple stop orders at once, which is useful for:
#' - **Portfolio Adjustment**: Clear all stop orders for a symbol (e.g., "BTC-USDT") if market conditions shift unexpectedly.
#' - **Strategy Reset**: Cancel outdated stop orders across multiple pairs or IDs when refining your trading plan.
#' - **Risk Management**: Remove pending stops during high volatility to avoid unintended triggers (e.g., canceling stops on ETH-BTC during a flash crash).
#' For example, if you have stop orders at $48,000 and $47,000 for BTC-USDT but anticipate a rally, batch canceling them prevents premature sales.
#'
#' ## Description
#' This function cancels multiple stop orders using optional filters (`symbol`, `tradeType`, `orderIds`) via a DELETE request, returning the canceled order IDs in a `data.table`.
#'
#' ## Workflow
#' 1. **Parameter Validation**: Ensures `query` is a named list, validates `symbol` if provided, and checks `tradeType` enum.
#' 2. **Request Construction**: Builds the endpoint URL with query parameters (`symbol`, `tradeType`, `orderIds`) using `build_query`.
#' 3. **Authentication**: Generates private API headers using `build_headers()` with the DELETE method and endpoint.
#' 4. **API Request**: Sends a DELETE request to the KuCoin API with a 3-second timeout via `httr::DELETE`.
#' 5. **Response Processing**: Parses the response with `process_kucoin_response`, confirms success ("200000"), and converts the `cancelledOrderIds` array to a `data.table` column as a list.
#'
#' ## API Details
#' - **Endpoint**: `DELETE https://api.kucoin.com/api/v1/stop-order/cancel`
#' - **Domain**: Spot
#' - **API Channel**: Private
#' - **API Permission**: Spot
#' - **Rate Limit Pool**: Spot
#' - **Rate Limit Weight**: 3
#' - **SDK Service**: Spot
#' - **SDK Sub-Service**: Order
#' - **SDK Method Name**: batchCancelStopOrder
#' - **Official Documentation**: [KuCoin Batch Cancel Stop Orders](https://www.kucoin.com/docs-new/rest/spot-trading/orders/batch-cancel-stop-orders)
#'
#' ## Request
#' ### Query Parameters
#' - `symbol`: String (optional) - Filter by trading pair symbol (e.g., "ETH-BTC"). Cancels all stop orders for this symbol if specified.
#' - `tradeType`: Enum<String> (optional) - Transaction type: "TRADE" (Spot), "MARGIN_TRADE" (Cross Margin), "MARGIN_ISOLATED_TRADE" (Isolated Margin). Defaults to "TRADE".
#' - `orderIds`: String (optional) - Comma-separated list of stop order IDs (e.g., "5bd6e9286d99522a52e458de,5bd6e9286d99522a52e458df").
#'
#' ### Example Request
#' ```bash
#' curl --location --request DELETE 'https://api.kucoin.com/api/v1/stop-order/cancel?symbol=ETH-BTC&tradeType=TRADE&orderIds=5bd6e9286d99522a52e458de,5bd6e9286d99522a52e458df'
#' ```
#'
#' ## Response
#' ### HTTP Code: 200
#' - **Content Type**: `application/json`
#'
#' ### Data Schema
#' - `code`: String (required) - Response code ("200000" indicates success).
#' - `data`: Object (required) - Contains:
#'   - `cancelledOrderIds`: Array[String] (required) - List of canceled stop order IDs.
#'
#' ### JSON Response Example
#' ```json
#' {
#'   "code": "200000",
#'   "data": {
#'     "cancelledOrderIds": [
#'       "671124f9365ccb00073debd4"
#'     ]
#'   }
#' }
#' ```
#'
#' @param keys List; API configuration parameters from `get_api_keys()`. Defaults to `get_api_keys()`.
#' @param base_url Character string; base URL for the KuCoin API. Defaults to `get_base_url()`.
#' @param query Named list; optional query parameters for filtering (e.g., `list(symbol = "ETH-BTC", orderIds = "5bd6e9286d99522a52e458de,5bd6e9286d99522a52e458df")`).
#' @return Promise resolving to a `data.table` with one row containing:
#'   - `cancelledOrderIds` (list): A list of character strings representing the IDs of the canceled stop orders.
#' @examples
#' \dontrun{
#' library(coro)
#' library(data.table)
#'
#' main_async <- coro::async(function() {
#'   # Batch cancel stop orders for ETH-BTC
#'   canceled_orders <- await(cancel_stop_order_batch_impl(
#'     query = list(
#'       symbol = "ETH-BTC",
#'       tradeType = "TRADE",
#'       orderIds = "5bd6e9286d99522a52e458de,5bd6e9286d99522a52e458df"
#'     )
#'   ))
#'   print(canceled_orders)
#' })
#'
#' # Run the async function
#' main_async()
#' while (!later::loop_empty()) later::run_now()
#' }
#' @importFrom coro async await
#' @importFrom data.table data.table
#' @importFrom httr DELETE timeout
#' @importFrom rlang abort arg_match0
#' @export
cancel_stop_order_batch_impl <- coro::async(function(
    keys = get_api_keys(),
    base_url = get_base_url(),
    query = list()
) {
    tryCatch({
        # Validate parameters
        if (!is.list(query)) {
            rlang::abort("Parameter 'query' must be a named list.")
        }
        if ("symbol" %in% names(query) && !is.null(query$symbol) && !verify_symbol(query$symbol)) {
            rlang::abort("Parameter 'query$symbol', if provided, must be a valid trading pair (e.g., 'ETH-BTC').")
        }
        if ("tradeType" %in% names(query) && !is.null(query$tradeType)) {
            query$tradeType <- rlang::arg_match0(
                query$tradeType,
                c("TRADE", "MARGIN_TRADE", "MARGIN_ISOLATED_TRADE"),
                "query$tradeType"
            )
        }
        if ("orderIds" %in% names(query) && (!is.character(query$orderIds) || nchar(query$orderIds) == 0)) {
            rlang::abort("Parameter 'query$orderIds', if provided, must be a non-empty comma-separated string.")
        }

        # Construct endpoint and query string
        endpoint <- "/api/v1/stop-order/cancel"
        query_string <- build_query(query)
        full_url <- paste0(base_url, endpoint, query_string)

        # Generate authentication headers
        headers <- await(build_headers("DELETE", paste0(endpoint, query_string), NULL, keys))

        # Send DELETE request
        response <- httr::DELETE(
            url = full_url,
            headers,
            httr::timeout(3)
        )

        # Process response
        parsed_response <- process_kucoin_response(response, full_url)
        if (parsed_response$code != "200000") {
            rlang::abort(sprintf("API error: %s - %s", parsed_response$code, parsed_response$msg))
        }

        # Return as data.table
        return(data.table::data.table(cancelledOrderIds = list(parsed_response$data$cancelledOrderIds)))
    }, error = function(e) {
        rlang::abort(sprintf("Error in cancel_stop_order_batch_impl: %s", conditionMessage(e)))
    })
})


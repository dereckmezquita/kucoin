# File: ./R/impl_spottrading_orders_add_order.R

box::use(
    ./helpers_api[process_kucoin_response, build_headers],
    ./utils[build_query, get_base_url, verify_symbol],
    ./utils_time_convert_kucoin[time_convert_to_kucoin],
    coro[async, await],
    data.table[as.data.table],
    httr[POST, timeout, content_type_json],
    jsonlite[toJSON],
    rlang[abort, arg_match0]
)

#' Place Order (Shared Implementation)
#'
#' This is a shared helper function for placing orders or testing order placement on the KuCoin Spot trading system.
#' It handles parameter validation, request body construction, authentication, API request sending, and response processing.
#'
#' @param keys List; API configuration parameters from `get_api_keys()`, including:
#'   - `api_key` (character): KuCoin API key.
#'   - `api_secret` (character): KuCoin API secret.
#'   - `api_passphrase` (character): KuCoin API passphrase.
#'   - `key_version` (character): API key version (e.g., "2"). Defaults to `get_api_keys()`.
#' @param base_url Character string; base URL for the KuCoin API. Defaults to `get_base_url()`.
#' @param endpoint Character string; the API endpoint to use (e.g., "/api/v1/hf/orders" or "/api/v1/hf/orders/test").
#' @param type Character string; order type: "limit" or "market". Required.
#' @param symbol Character string; trading pair (e.g., "BTC-USDT"). Required.
#' @param side Character string; order side: "buy" or "sell". Required.
#' @param clientOid Character string; unique client order ID (recommended UUID, max 40 chars). Optional.
#' @param price Character string; price for limit orders (must align with priceIncrement). Required for limit orders.
#' @param size Character string; quantity for limit or market orders (must align with baseIncrement). Required for limit, optional for market.
#' @param funds Character string; funds for market orders (must align with quoteIncrement). Optional for market, mutually exclusive with size.
#' @param stp Character string; self-trade prevention strategy: "CN", "CO", "CB", or "DC". Optional.
#' @param tags Character string; order tag (max 20 ASCII chars). Optional.
#' @param remark Character string; order remarks (max 20 ASCII chars). Optional.
#' @param timeInForce Character string; time-in-force strategy: "GTC", "GTT", "IOC", or "FOK". Optional, defaults to "GTC".
#' @param cancelAfter Integer; cancel after n seconds (for GTT). Optional.
#' @param postOnly Logical; passive order flag (disabled for IOC/FOK). Optional, defaults to FALSE.
#' @param hidden Logical; hide order from order book. Optional, defaults to FALSE.
#' @param iceberg Logical; show only visible portion in iceberg orders. Optional, defaults to FALSE.
#' @param visibleSize Character string; max visible quantity for iceberg orders. Optional.
#' @return Promise resolving to a `data.table` containing:
#'   - `orderId` (character): Unique order ID generated by KuCoin (or simulated for test).
#'   - `clientOid` (character): Client-specified order ID.
place_order_helper <- coro::async(function(
    keys = get_api_keys(),
    base_url = get_base_url(),
    endpoint,
    type,
    symbol,
    side,
    clientOid = NULL,
    price = NULL,
    size = NULL,
    funds = NULL,
    stp = NULL,
    tags = NULL,
    remark = NULL,
    timeInForce = NULL,
    cancelAfter = NULL,
    postOnly = NULL,
    hidden = NULL,
    iceberg = NULL,
    visibleSize = NULL
) {
    tryCatch({
        # Validate required parameters
        type <- rlang::arg_match0(type, c("limit", "market"), arg_name = "type")
        if (is.null(symbol) || !verify_symbol(symbol)) {
            rlang::abort("Parameter 'symbol' must be a valid ticker (e.g., 'BTC-USDT').")
        }
        side <- rlang::arg_match0(side, c("buy", "sell"), arg_name = "side")

        # Validate order type-specific parameters
        if (type == "limit") {
            if (is.null(price) || !is.character(price)) {
                rlang::abort("Parameter 'price' is required for limit orders and must be a character string.")
            }
            if (is.null(size) || !is.character(size)) {
                rlang::abort("Parameter 'size' is required for limit orders and must be a character string.")
            }
            if (!is.null(funds)) {
                rlang::abort("Parameter 'funds' is not applicable for limit orders.")
            }
        } else if (type == "market") {
            if (!is.null(price)) {
                rlang::abort("Parameter 'price' is not applicable for market orders.")
            }
            if (is.null(size) && is.null(funds)) {
                rlang::abort("Either 'size' or 'funds' must be specified for market orders.")
            }
            if (!is.null(size) && !is.null(funds)) {
                rlang::abort("Parameters 'size' and 'funds' are mutually exclusive for market orders.")
            }
            if (!is.null(size) && !is.character(size)) {
                rlang::abort("Parameter 'size' must be a character string for market orders.")
            }
            if (!is.null(funds) && !is.character(funds)) {
                rlang::abort("Parameter 'funds' must be a character string for market orders.")
            }
        }

        # Validate optional parameters
        if (!is.null(clientOid)) {
            if (!is.character(clientOid) || nchar(clientOid) > 40 || !grepl("^[a-zA-Z0-9_-]+$", clientOid)) {
                rlang::abort("Parameter 'clientOid' must be a string with maximum 40 characters, containing only letters, numbers, underscores, or hyphens.")
            }
        }
        if (!is.null(stp)) {
            stp <- rlang::arg_match0(stp, c("CN", "CO", "CB", "DC"), arg_name = "stp")
        }
        if (!is.null(tags)) {
            if (!is.character(tags) || nchar(tags) > 20 || !grepl("^[[:ascii:]]+$", tags)) {
                rlang::abort("Parameter 'tags' must be ASCII and maximum 20 characters.")
            }
        }
        if (!is.null(remark)) {
            if (!is.character(remark) || nchar(remark) > 20 || !grepl("^[[:ascii:]]+$", remark)) {
                rlang::abort("Parameter 'remark' must be ASCII and maximum 20 characters.")
            }
        }
        if (!is.null(timeInForce)) {
            timeInForce <- rlang::arg_match0(timeInForce, c("GTC", "GTT", "IOC", "FOK"), arg_name = "timeInForce")
        } else {
            timeInForce <- "GTC"  # Default as per API documentation
        }
        if (!is.null(cancelAfter)) {
            if (!is.numeric(cancelAfter) || cancelAfter <= 0) {
                rlang::abort("Parameter 'cancelAfter' must be a positive number.")
            }
        }
        if (!is.null(postOnly)) {
            if (!is.logical(postOnly)) {
                rlang::abort("Parameter 'postOnly' must be a logical value.")
            }
        } else {
            postOnly <- FALSE  # Default as per API documentation
        }
        if (!is.null(hidden)) {
            if (!is.logical(hidden)) {
                rlang::abort("Parameter 'hidden' must be a logical value.")
            }
        } else {
            hidden <- FALSE  # Default as per API documentation
        }
        if (!is.null(iceberg)) {
            if (!is.logical(iceberg)) {
                rlang::abort("Parameter 'iceberg' must be a logical value.")
            }
        } else {
            iceberg <- FALSE  # Default as per API documentation
        }
        if (!is.null(visibleSize)) {
            if (!is.character(visibleSize)) {
                rlang::abort("Parameter 'visibleSize' must be a character string.")
            }
            if (!iceberg) {
                rlang::abort("Parameter 'visibleSize' is only applicable when 'iceberg' is TRUE.")
            }
        }

        # Additional validation for timeInForce constraints
        if (timeInForce == "GTT" && is.null(cancelAfter)) {
            rlang::abort("Parameter 'cancelAfter' is required when 'timeInForce' is 'GTT'.")
        }
        if (postOnly && timeInForce %in% c("IOC", "FOK")) {
            rlang::abort("Parameter 'postOnly' cannot be TRUE when 'timeInForce' is 'IOC' or 'FOK'.")
        }
        if (iceberg && hidden) {
            rlang::abort("Parameters 'iceberg' and 'hidden' cannot both be TRUE.")
        }

        # Construct request body
        body_list <- list(
            type = type,
            symbol = symbol,
            side = side,
            clientOid = clientOid,
            price = price,
            size = size,
            funds = funds,
            stp = stp,
            tags = tags,
            remark = remark,
            timeInForce = timeInForce,
            cancelAfter = if (!is.null(cancelAfter)) as.integer(cancelAfter) else NULL,
            postOnly = postOnly,
            hidden = hidden,
            iceberg = iceberg,
            visibleSize = visibleSize
        )
        # Remove NULL values
        body_list <- body_list[!sapply(body_list, is.null)]
        body_json <- jsonlite::toJSON(body_list, auto_unbox = TRUE)

        # Prepare API request
        url <- paste0(base_url, endpoint)
        method <- "POST"

        # Generate authentication headers
        headers <- await(build_headers(method, endpoint, body_json, keys))

        # Send POST request
        response <- httr::POST(
            url = url,
            body = body_json,
            headers,
            httr::content_type_json(),
            httr::timeout(3)
        )

        # Process response
        parsed_response <- process_kucoin_response(response, url)
        if (parsed_response$code != "200000") {
            rlang::abort(sprintf("API error: %s - %s", parsed_response$code, parsed_response$msg))
        }

        # Convert response data to data.table
        result_dt <- data.table::as.data.table(parsed_response$data)

        return(result_dt)
    }, error = function(e) {
        rlang::abort(sprintf("Error in place_order_helper: %s", conditionMessage(e)))
    })
})

#' Add Order (Implementation)
#'
#' Places a new order (limit or market) to the KuCoin Spot trading system asynchronously.
#' This function handles both limit and market order types, validates parameters according to KuCoin's specifications,
#' and returns the order ID and client order ID upon successful placement.
#'
#' ### Workflow Overview
#' 1. **Parameter Validation**: Validates required and optional parameters based on order type (limit/market) using `rlang::arg_match0` for enumerated values.
#' 2. **Request Body Construction**: Builds a JSON body with mandatory and optional parameters.
#' 3. **Authentication**: Generates headers with API credentials using `build_headers()`.
#' 4. **API Request**: Sends a POST request to the KuCoin API with a 3-second timeout.
#' 5. **Response Processing**: Parses the response, validates success, and returns order details as a `data.table`.
#'
#' ### API Endpoint
#' `POST https://api.kucoin.com/api/v1/hf/orders`
#'
#' ### Usage
#' Utilised to place spot trading orders on KuCoin. Supports limit orders (price + size) and market orders (size or funds).
#' Requires sufficient funds in the account and adheres to KuCoin's trading rules (e.g., max 2000 active orders).
#'
#' ### Official Documentation
#' [KuCoin Add Order](https://www.kucoin.com/docs-new/rest/spot-trading/orders/add-order)
#'
#' @param keys List; API configuration parameters from `get_api_keys()`. Defaults to `get_api_keys()`.
#' @param base_url Character string; base URL for the KuCoin API. Defaults to `get_base_url()`.
#' @param type Character string; order type: "limit" or "market". Required.
#' @param symbol Character string; trading pair (e.g., "BTC-USDT"). Required.
#' @param side Character string; order side: "buy" or "sell". Required.
#' @param clientOid Character string; unique client order ID (recommended UUID, max 40 chars). Optional.
#' @param price Character string; price for limit orders (must align with priceIncrement). Required for limit orders.
#' @param size Character string; quantity for limit or market orders (must align with baseIncrement). Required for limit, optional for market.
#' @param funds Character string; funds for market orders (must align with quoteIncrement). Optional for market, mutually exclusive with size.
#' @param stp Character string; self-trade prevention strategy: "CN", "CO", "CB", or "DC". Optional.
#' @param tags Character string; order tag (max 20 ASCII chars). Optional.
#' @param remark Character string; order remarks (max 20 ASCII chars). Optional.
#' @param timeInForce Character string; time-in-force strategy: "GTC", "GTT", "IOC", or "FOK". Optional, defaults to "GTC".
#' @param cancelAfter Integer; cancel after n seconds (for GTT). Optional.
#' @param postOnly Logical; passive order flag (disabled for IOC/FOK). Optional, defaults to FALSE.
#' @param hidden Logical; hide order from order book. Optional, defaults to FALSE.
#' @param iceberg Logical; show only visible portion in iceberg orders. Optional, defaults to FALSE.
#' @param visibleSize Character string; max visible quantity for iceberg orders. Optional.
#' @return Promise resolving to a `data.table` containing:
#'   - `orderId` (character): Unique order ID generated by KuCoin.
#'   - `clientOid` (character): Client-specified order ID.
#' @examples
#' \dontrun{
#' main_async <- coro::async(function() {
#'   # Place a limit buy order
#'   order <- await(add_order_impl(
#'     type = "limit",
#'     symbol = "BTC-USDT",
#'     side = "buy",
#'     price = "50000",
#'     size = "0.0001",
#'     clientOid = uuid::UUIDgenerate(),
#'     remark = "Test limit order"
#'   ))
#'   print(order)
#'
#'   # Place a market buy order with funds
#'   market_order <- await(add_order_impl(
#'     type = "market",
#'     symbol = "BTC-USDT",
#'     side = "buy",
#'     funds = "10",
#'     clientOid = uuid::UUIDgenerate()
#'   ))
#'   print(market_order)
#' })
#' main_async()
#' while (!later::loop_empty()) later::run_now()
#' }
#' @importFrom coro async await
#' @importFrom data.table as.data.table
#' @importFrom httr POST timeout content_type_json
#' @importFrom jsonlite toJSON
#' @importFrom rlang abort arg_match0
#' @export
add_order_impl <- coro::async(function(
    keys = get_api_keys(),
    base_url = get_base_url(),
    type,
    symbol,
    side,
    clientOid = NULL,
    price = NULL,
    size = NULL,
    funds = NULL,
    stp = NULL,
    tags = NULL,
    remark = NULL,
    timeInForce = NULL,
    cancelAfter = NULL,
    postOnly = NULL,
    hidden = NULL,
    iceberg = NULL,
    visibleSize = NULL
) {
    return(place_order_helper(
        keys = keys,
        base_url = base_url,
        endpoint = "/api/v1/hf/orders",
        type = type,
        symbol = symbol,
        side = side,
        clientOid = clientOid,
        price = price,
        size = size,
        funds = funds,
        stp = stp,
        tags = tags,
        remark = remark,
        timeInForce = timeInForce,
        cancelAfter = cancelAfter,
        postOnly = postOnly,
        hidden = hidden,
        iceberg = iceberg,
        visibleSize = visibleSize
    ))
})

#' Add Order Test (Implementation)
#'
#' Simulates placing a new order (limit or market) to the KuCoin Spot trading system asynchronously for testing purposes.
#' This function validates parameters and checks the signature without actually placing an order.
#' It returns the same response structure as the actual order placement endpoint.
#'
#' ### Workflow Overview
#' 1. **Parameter Validation**: Validates required and optional parameters based on order type (limit/market) using `rlang::arg_match0` for enumerated values.
#' 2. **Request Body Construction**: Builds a JSON body with mandatory and optional parameters.
#' 3. **Authentication**: Generates headers with API credentials using `build_headers()`.
#' 4. **API Request**: Sends a POST request to the KuCoin API test endpoint with a 3-second timeout.
#' 5. **Response Processing**: Parses the response, validates success, and returns simulated order details as a `data.table`.
#'
#' ### API Endpoint
#' `POST https://api.kucoin.com/api/v1/hf/orders/test`
#'
#' ### Usage
#' Utilised to test order placement logic and signature validity without affecting the actual trading system.
#'
#' ### Official Documentation
#' [KuCoin Add Order Test](https://www.kucoin.com/docs-new/rest/spot-trading/orders/add-order-test)
#'
#' @param keys List; API configuration parameters from `get_api_keys()`. Defaults to `get_api_keys()`.
#' @param base_url Character string; base URL for the KuCoin API. Defaults to `get_base_url()`.
#' @param type Character string; order type: "limit" or "market". Required.
#' @param symbol Character string; trading pair (e.g., "BTC-USDT"). Required.
#' @param side Character string; order side: "buy" or "sell". Required.
#' @param clientOid Character string; unique client order ID (recommended UUID, max 40 chars). Optional.
#' @param price Character string; price for limit orders (must align with priceIncrement). Required for limit orders.
#' @param size Character string; quantity for limit or market orders (must align with baseIncrement). Required for limit, optional for market.
#' @param funds Character string; funds for market orders (must align with quoteIncrement). Optional for market, mutually exclusive with size.
#' @param stp Character string; self-trade prevention strategy: "CN", "CO", "CB", or "DC". Optional.
#' @param tags Character string; order tag (max 20 ASCII chars). Optional.
#' @param remark Character string; order remarks (max 20 ASCII chars). Optional.
#' @param timeInForce Character string; time-in-force strategy: "GTC", "GTT", "IOC", or "FOK". Optional, defaults to "GTC".
#' @param cancelAfter Integer; cancel after n seconds (for GTT). Optional.
#' @param postOnly Logical; passive order flag (disabled for IOC/FOK). Optional, defaults to FALSE.
#' @param hidden Logical; hide order from order book. Optional, defaults to FALSE.
#' @param iceberg Logical; show only visible portion in iceberg orders. Optional, defaults to FALSE.
#' @param visibleSize Character string; max visible quantity for iceberg orders. Optional.
#' @return Promise resolving to a `data.table` containing:
#'   - `orderId` (character): Simulated unique order ID.
#'   - `clientOid` (character): Client-specified order ID.
#' @examples
#' \dontrun{
#' main_async <- coro::async(function() {
#'   # Test a limit buy order
#'   test_order <- await(add_order_test_impl(
#'     type = "limit",
#'     symbol = "BTC-USDT",
#'     side = "buy",
#'     price = "50000",
#'     size = "0.0001",
#'     clientOid = uuid::UUIDgenerate(),
#'     remark = "Test limit order"
#'   ))
#'   print(test_order)
#'
#'   # Test a market buy order with funds
#'   test_market_order <- await(add_order_test_impl(
#'     type = "market",
#'     symbol = "BTC-USDT",
#'     side = "buy",
#'     funds = "10",
#'     clientOid = uuid::UUIDgenerate()
#'   ))
#'   print(test_market_order)
#' })
#' main_async()
#' while (!later::loop_empty()) later::run_now()
#' }
#' @importFrom coro async await
#' @importFrom data.table as.data.table
#' @importFrom httr POST timeout content_type_json
#' @importFrom jsonlite toJSON
#' @importFrom rlang abort arg_match0
#' @export
add_order_test_impl <- coro::async(function(
    keys = get_api_keys(),
    base_url = get_base_url(),
    type,
    symbol,
    side,
    clientOid = NULL,
    price = NULL,
    size = NULL,
    funds = NULL,
    stp = NULL,
    tags = NULL,
    remark = NULL,
    timeInForce = NULL,
    cancelAfter = NULL,
    postOnly = NULL,
    hidden = NULL,
    iceberg = NULL,
    visibleSize = NULL
) {
    return(place_order_helper(
        keys = keys,
        base_url = base_url,
        endpoint = "/api/v1/hf/orders/test",
        type = type,
        symbol = symbol,
        side = side,
        clientOid = clientOid,
        price = price,
        size = size,
        funds = funds,
        stp = stp,
        tags = tags,
        remark = remark,
        timeInForce = timeInForce,
        cancelAfter = cancelAfter,
        postOnly = postOnly,
        hidden = hidden,
        iceberg = iceberg,
        visibleSize = visibleSize
    ))
})

# ------------------------------------------------------------------------------

#' Validate a Single Order for Batch Placement
#'
#' Validates the parameters of a single order within a batch, ensuring all required fields are present
#' and optional fields meet KuCoin's specifications. Sets default values where applicable.
#'
#' @param order List; a list containing order parameters such as `symbol`, `type`, `side`, etc.
#' @return List; the validated order with defaults applied.
validate_order <- function(order) {
    if (!is.list(order)) {
        rlang::abort("Each order must be a list.")
    }

    # Check required fields
    required_fields <- c("symbol", "type", "side")
    for (field in required_fields) {
        if (is.null(order[[field]])) {
            rlang::abort(sprintf("Missing required field '%s' in order.", field))
        }
    }

    # Validate core parameters
    type <- rlang::arg_match0(order$type, c("limit", "market"), arg_name = "type")
    side <- rlang::arg_match0(order$side, c("buy", "sell"), arg_name = "side")
    if (!verify_symbol(order$symbol)) {
        rlang::abort(sprintf("Invalid symbol '%s' in order.", order$symbol))
    }

    # Initialize validated order with required fields
    validated_order <- list(
        symbol = order$symbol,
        type = type,
        side = side
    )

    # Type-specific validation
    if (type == "limit") {
        if (is.null(order$price) || !is.character(order$price)) {
            rlang::abort("Parameter 'price' is required for limit orders and must be a character string.")
        }
        if (is.null(order$size) || !is.character(order$size)) {
            rlang::abort("Parameter 'size' is required for limit orders and must be a character string.")
        }
        if (!is.null(order$funds)) {
            rlang::abort("Parameter 'funds' is not applicable for limit orders.")
        }
        validated_order$price <- order$price
        validated_order$size <- order$size
    } else if (type == "market") {
        if (!is.null(order$price)) {
            rlang::abort("Parameter 'price' is not applicable for market orders.")
        }
        if (is.null(order$size) && is.null(order$funds)) {
            rlang::abort("Either 'size' or 'funds' must be specified for market orders.")
        }
        if (!is.null(order$size) && !is.null(order$funds)) {
            rlang::abort("Parameters 'size' and 'funds' are mutually exclusive for market orders.")
        }
        if (!is.null(order$size)) {
            if (!is.character(order$size)) {
                rlang::abort("Parameter 'size' must be a character string for market orders.")
            }
            validated_order$size <- order$size
        }
        if (!is.null(order$funds)) {
            if (!is.character(order$funds)) {
                rlang::abort("Parameter 'funds' must be a character string for market orders.")
            }
            validated_order$funds <- order$funds
        }
    }

    # Validate optional parameters
    if (!is.null(order$clientOid)) {
        if (!is.character(order$clientOid) || nchar(order$clientOid) > 40 || !grepl("^[a-zA-Z0-9_-]+$", order$clientOid)) {
            rlang::abort("Parameter 'clientOid' must be a string with maximum 40 characters, containing only letters, numbers, underscores, or hyphens.")
        }
        validated_order$clientOid <- order$clientOid
    }
    if (!is.null(order$stp)) {
        validated_order$stp <- rlang::arg_match0(order$stp, c("CN", "CO", "CB", "DC"), arg_name = "stp")
    }
    if (!is.null(order$tags)) {
        if (!is.character(order$tags) || nchar(order$tags) > 20 || !grepl("^[[:ascii:]]+$", order$tags)) {
            rlang::abort("Parameter 'tags' must be ASCII and maximum 20 characters.")
        }
        validated_order$tags <- order$tags
    }
    if (!is.null(order$remark)) {
        if (!is.character(order$remark) || nchar(order$remark) > 20 || !grepl("^[[:ascii:]]+$", order$remark)) {
            rlang::abort("Parameter 'remark' must be ASCII and maximum 20 characters.")
        }
        validated_order$remark <- order$remark
    }
    if (!is.null(order$timeInForce)) {
        validated_order$timeInForce <- rlang::arg_match0(order$timeInForce, c("GTC", "GTT", "IOC", "FOK"), arg_name = "timeInForce")
    } else {
        validated_order$timeInForce <- "GTC"  # Default as per API documentation
    }
    if (!is.null(order$cancelAfter)) {
        if (!is.numeric(order$cancelAfter) || order$cancelAfter <= 0) {
            rlang::abort("Parameter 'cancelAfter' must be a positive number.")
        }
        validated_order$cancelAfter <- as.integer(order$cancelAfter)
    }
    if (!is.null(order$postOnly)) {
        if (!is.logical(order$postOnly)) {
            rlang::abort("Parameter 'postOnly' must be a logical value.")
        }
        validated_order$postOnly <- order$postOnly
    } else {
        validated_order$postOnly <- FALSE  # Default as per API documentation
    }
    if (!is.null(order$hidden)) {
        if (!is.logical(order$hidden)) {
            rlang::abort("Parameter 'hidden' must be a logical value.")
        }
        validated_order$hidden <- order$hidden
    } else {
        validated_order$hidden <- FALSE  # Default as per API documentation
    }
    if (!is.null(order$iceberg)) {
        if (!is.logical(order$iceberg)) {
            rlang::abort("Parameter 'iceberg' must be a logical value.")
        }
        validated_order$iceberg <- order$iceberg
    } else {
        validated_order$iceberg <- FALSE  # Default as per API documentation
    }
    if (!is.null(order$visibleSize)) {
        if (!is.character(order$visibleSize)) {
            rlang::abort("Parameter 'visibleSize' must be a character string.")
        }
        if (!validated_order$iceberg) {
            rlang::abort("Parameter 'visibleSize' is only applicable when 'iceberg' is TRUE.")
        }
        validated_order$visibleSize <- order$visibleSize
    }

    # Additional validation for timeInForce constraints
    if (validated_order$timeInForce == "GTT" && is.null(validated_order$cancelAfter)) {
        rlang::abort("Parameter 'cancelAfter' is required when 'timeInForce' is 'GTT'.")
    }
    if (validated_order$postOnly && validated_order$timeInForce %in% c("IOC", "FOK")) {
        rlang::abort("Parameter 'postOnly' cannot be TRUE when 'timeInForce' is 'IOC' or 'FOK'.")
    }
    if (validated_order$iceberg && validated_order$hidden) {
        rlang::abort("Parameters 'iceberg' and 'hidden' cannot both be TRUE.")
    }

    return(validated_order)
}

#' Add Orders Batch (Implementation)
#'
#' Places multiple new orders (up to 20) to the KuCoin Spot trading system asynchronously.
#' This function validates a list of orders, constructs a batch request, and returns the placement results for each order.
#'
#' ### Workflow Overview
#' 1. **Parameter Validation**: Ensures the `order_list` contains 1–20 valid orders, each validated via `validate_order()`.
#' 2. **Request Body Construction**: Builds a JSON body with the `orderList` key containing validated orders.
#' 3. **Authentication**: Generates headers with API credentials using `build_headers()`.
#' 4. **API Request**: Sends a POST request to the KuCoin API with a 3-second timeout.
#' 5. **Response Processing**: Parses the response and returns results as a `data.table`.
#'
#' ### API Endpoint
#' `POST https://api.kucoin.com/api/v1/hf/orders/multi`
#'
#' ### Usage
#' Used to place multiple spot trading orders on KuCoin in a single request. Each order can be a limit or market order,
#' with appropriate parameters. Requires sufficient funds and adheres to KuCoin's limits (e.g., max 20 orders per request,
#' 2000 active orders per account).
#'
#' ### Official Documentation
#' [KuCoin Batch Add Orders](https://www.kucoin.com/docs-new/rest/spot-trading/orders/batch-add-orders)
#'
#' @param keys List; API configuration parameters from `get_api_keys()`, including:
#'   - `api_key` (character): KuCoin API key.
#'   - `api_secret` (character): KuCoin API secret.
#'   - `api_passphrase` (character): KuCoin API passphrase.
#'   - `key_version` (character): API key version (e.g., "2"). Defaults to `get_api_keys()`.
#' @param base_url Character string; base URL for the KuCoin API. Defaults to `get_base_url()`.
#' @param order_list List; a list of orders, where each order is a list with parameters:
#'   - `symbol` (character): Trading pair (e.g., "BTC-USDT"). Required.
#'   - `type` (character): Order type: "limit" or "market". Required.
#'   - `side` (character): Order side: "buy" or "sell". Required.
#'   - `clientOid` (character): Unique client order ID (max 40 chars). Optional.
#'   - `price` (character): Price for limit orders. Required for limit.
#'   - `size` (character): Quantity for limit or market orders. Required for limit, optional for market.
#'   - `funds` (character): Funds for market orders. Optional for market, mutually exclusive with `size`.
#'   - `stp` (character): Self-trade prevention: "CN", "CO", "CB", or "DC". Optional.
#'   - `tags` (character): Order tag (max 20 ASCII chars). Optional.
#'   - `remark` (character): Order remarks (max 20 ASCII chars). Optional.
#'   - `timeInForce` (character): Time-in-force: "GTC", "GTT", "IOC", or "FOK". Optional, defaults to "GTC".
#'   - `cancelAfter` (integer): Cancel after n seconds (for GTT). Optional.
#'   - `postOnly` (logical): Passive order flag. Optional, defaults to FALSE.
#'   - `hidden` (logical): Hide order from order book. Optional, defaults to FALSE.
#'   - `iceberg` (logical): Iceberg order flag. Optional, defaults to FALSE.
#'   - `visibleSize` (character): Visible quantity for iceberg orders. Optional.
#' @return Promise resolving to a `data.table` containing results for each order, with columns:
#'   - `success` (logical): Whether the order placement was successful.
#'   - `orderId` (character): Unique order ID (if successful).
#'   - `clientOid` (character): Client-specified order ID (if provided).
#'   - `failMsg` (character): Error message (if failed).
#' @examples
#' \dontrun{
#' main_async <- coro::async(function() {
#'   # Define two orders
#'   order1 <- list(
#'     clientOid = uuid::UUIDgenerate(),
#'     symbol = "BTC-USDT",
#'     type = "limit",
#'     side = "buy",
#'     price = "30000",
#'     size = "0.00001",
#'     remark = "Batch buy"
#'   )
#'   order2 <- list(
#'     clientOid = uuid::UUIDgenerate(),
#'     symbol = "ETH-USDT",
#'     type = "market",
#'     side = "sell",
#'     size = "0.01"
#'   )
#'   # Place batch orders
#'   result <- await(add_order_batch_impl(order_list = list(order1, order2)))
#'   print(result)
#' })
#' main_async()
#' while (!later::loop_empty()) later::run_now()
#' }
#' @importFrom coro async await
#' @importFrom data.table as.data.table
#' @importFrom httr POST timeout content_type_json
#' @importFrom jsonlite toJSON
#' @importFrom rlang abort arg_match0
#' @export
add_order_batch_impl <- coro::async(function(
    keys = get_api_keys(),
    base_url = get_base_url(),
    order_list
) {
    tryCatch({
        # Validate order_list
        if (!is.list(order_list) || length(order_list) == 0 || length(order_list) > 20) {
            rlang::abort("Parameter 'order_list' must be a list containing 1 to 20 orders.")
        }

        # Validate each order in the list
        validated_orders <- lapply(order_list, validate_order)

        # Construct request body
        body_list <- list(orderList = validated_orders)
        body_json <- jsonlite::toJSON(body_list, auto_unbox = TRUE)

        # Prepare API request
        endpoint <- "/api/v1/hf/orders/multi"
        url <- paste0(base_url, endpoint)
        method <- "POST"

        # Generate authentication headers
        headers <- await(build_headers(method, endpoint, body_json, keys))

        # Send POST request
        response <- httr::POST(
            url = url,
            body = body_json,
            headers,
            httr::content_type_json(),
            httr::timeout(3)
        )

        # Process response
        parsed_response <- process_kucoin_response(response, url)
        if (parsed_response$code != "200000") {
            rlang::abort(sprintf("API error: %s - %s", parsed_response$code, parsed_response$msg))
        }

        # Convert response data to data.table
        result_dt <- data.table::as.data.table(parsed_response$data)

        return(result_dt)
    }, error = function(e) {
        rlang::abort(sprintf("Error in add_order_batch_impl: %s", conditionMessage(e)))
    })
})

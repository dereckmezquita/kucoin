# File: ./R/impl_spottrading_orders_add_order.R

box::use(
    ./helpers_api[process_kucoin_response, build_headers],
    ./utils[get_base_url, verify_symbol],
    coro[async, await],
    data.table[as.data.table],
    httr[POST, timeout, content_type_json],
    jsonlite[toJSON],
    rlang[abort, arg_match0]
)

#' Place Order (Shared Implementation Helper)
#'
#' This is a shared helper function for placing orders or testing order placement on the KuCoin Spot trading system.
#' It handles parameter validation, request body construction, authentication, API request sending, and response processing.
#'
#' @param keys List; API configuration parameters from `get_api_keys()`, including:
#'   - `api_key` (character): KuCoin API key.
#'   - `api_secret` (character): KuCoin API secret.
#'   - `api_passphrase` (character): KuCoin API passphrase.
#'   - `key_version` (character): API key version (e.g., "2"). Defaults to `get_api_keys()`.
#' @param base_url Character string; base URL for the KuCoin API. Defaults to `get_base_url()`.
#' @param endpoint Character string; the API endpoint to use (e.g., "/api/v1/hf/orders" or "/api/v1/hf/orders/test").
#' @param type Character string; order type: "limit" or "market". Required.
#' @param symbol Character string; trading pair (e.g., "BTC-USDT"). Required.
#' @param side Character string; order side: "buy" or "sell". Required.
#' @param clientOid Character string; unique client order ID (recommended UUID, max 40 chars). Optional.
#' @param price Numeric; price for limit orders (must align with priceIncrement). Required for limit orders.
#' @param size Numeric; quantity for limit or market orders (must align with baseIncrement). Required for limit, optional for market.
#' @param funds Numeric; funds for market orders (must align with quoteIncrement). Optional for market, mutually exclusive with size.
#' @param stp Character string; self-trade prevention strategy: "CN", "CO", "CB", or "DC". Optional.
#' @param tags Character string; order tag (max 20 ASCII chars). Optional.
#' @param remark Character string; order remarks (max 20 ASCII chars). Optional.
#' @param timeInForce Character string; time-in-force strategy: "GTC", "GTT", "IOC", or "FOK". Optional, defaults to "GTC".
#' @param cancelAfter Numeric; cancel after n seconds (for GTT). Optional.
#' @param postOnly Logical; passive order flag (disabled for IOC/FOK). Optional, defaults to FALSE.
#' @param hidden Logical; hide order from order book. Optional, defaults to FALSE.
#' @param iceberg Logical; show only visible portion in iceberg orders. Optional, defaults to FALSE.
#' @param visibleSize Numeric; max visible quantity for iceberg orders. Optional.
#' @return Promise resolving to a `data.table` containing:
#'   - `orderId` (character): Unique order ID generated by KuCoin (or simulated for test).
#'   - `clientOid` (character): Client-specified order ID.
place_order_helper <- coro::async(function(
    keys = get_api_keys(),
    base_url = get_base_url(),
    endpoint,
    type,
    symbol,
    side,
    clientOid = NULL,
    price = NULL,
    size = NULL,
    funds = NULL,
    stp = NULL,
    tags = NULL,
    remark = NULL,
    timeInForce = NULL,
    cancelAfter = NULL,
    postOnly = NULL,
    hidden = NULL,
    iceberg = NULL,
    visibleSize = NULL
) {
    tryCatch({
        # Validate required parameters
        type <- rlang::arg_match0(type, c("limit", "market"))
        if (is.null(symbol) || !verify_symbol(symbol)) {
            rlang::abort("Parameter 'symbol' must be a valid ticker (e.g., 'BTC-USDT').")
        }
        side <- rlang::arg_match0(side, c("buy", "sell"))

        # Convert numeric parameters to character strings as required by the API
        if (!is.null(price)) price <- as.character(price)
        if (!is.null(size)) size <- as.character(size)
        if (!is.null(funds)) funds <- as.character(funds)
        if (!is.null(visibleSize)) visibleSize <- as.character(visibleSize)

        # Validate order type-specific parameters
        if (type == "limit") {
            if (is.null(price)) {
                rlang::abort("Parameter 'price' is required for limit orders.")
            }
            if (is.null(size)) {
                rlang::abort("Parameter 'size' is required for limit orders.")
            }
            if (!is.null(funds)) {
                rlang::abort("Parameter 'funds' is not applicable for limit orders.")
            }
        } else if (type == "market") {
            if (!is.null(price)) {
                rlang::abort("Parameter 'price' is not applicable for market orders.")
            }
            if (is.null(size) && is.null(funds)) {
                rlang::abort("Either 'size' or 'funds' must be specified for market orders.")
            }
            if (!is.null(size) && !is.null(funds)) {
                rlang::abort("Parameters 'size' and 'funds' are mutually exclusive for market orders.")
            }
        }

        # Validate optional parameters
        if (!is.null(clientOid)) {
            if (!is.character(clientOid) || nchar(clientOid) > 40 || !grepl("^[a-zA-Z0-9_-]+$", clientOid)) {
                rlang::abort("Parameter 'clientOid' must be a string with maximum 40 characters, containing only letters, numbers, underscores, or hyphens.")
            }
        }
        if (!is.null(stp)) {
            stp <- rlang::arg_match0(stp, c("CN", "CO", "CB", "DC"))
        }
        if (!is.null(tags)) {
            if (!is.character(tags) || nchar(tags) > 20 || !all(charToRaw(tags) <= 127)) {
                rlang::abort("Parameter 'tags' must be ASCII and maximum 20 characters.")
            }
        }
        if (!is.null(remark)) {
            if (!is.character(remark) || nchar(remark) > 20 || !all(charToRaw(remark) <= 127)) {
                rlang::abort("Parameter 'remark' must be ASCII and maximum 20 characters.")
            }
        }
        if (!is.null(timeInForce)) {
            timeInForce <- rlang::arg_match0(timeInForce, c("GTC", "GTT", "IOC", "FOK"))
        } else {
            timeInForce <- "GTC"  # Default as per API documentation
        }
        if (!is.null(cancelAfter)) {
            if (!is.numeric(cancelAfter) || cancelAfter <= 0) {
                rlang::abort("Parameter 'cancelAfter' must be a positive number.")
            }
            cancelAfter <- as.integer(cancelAfter)
        }
        if (is.null(postOnly)) {
            postOnly <- FALSE  # Default as per API documentation
        } else if (!is.logical(postOnly)) {
            rlang::abort("Parameter 'postOnly' must be a logical value.")
        }
        if (is.null(hidden)) {
            hidden <- FALSE  # Default as per API documentation
        } else if (!is.logical(hidden)) {
            rlang::abort("Parameter 'hidden' must be a logical value.")
        }
        if (is.null(iceberg)) {
            iceberg <- FALSE  # Default as per API documentation
        } else if (!is.logical(iceberg)) {
            rlang::abort("Parameter 'iceberg' must be a logical value.")
        }
        if (!is.null(visibleSize)) {
            if (iceberg == FALSE) {
                rlang::abort("Parameter 'visibleSize' is only applicable when 'iceberg' is TRUE.")
            }
        }

        # Additional validation for timeInForce constraints
        if (timeInForce == "GTT" && is.null(cancelAfter)) {
            rlang::abort("Parameter 'cancelAfter' is required when 'timeInForce' is 'GTT'.")
        }
        if (postOnly && timeInForce %in% c("IOC", "FOK")) {
            rlang::abort("Parameter 'postOnly' cannot be TRUE when 'timeInForce' is 'IOC' or 'FOK'.")
        }
        if (iceberg && hidden) {
            rlang::abort("Parameters 'iceberg' and 'hidden' cannot both be TRUE.")
        }

        # Construct request body
        body_list <- list(
            type = type,
            symbol = symbol,
            side = side,
            clientOid = clientOid,
            price = price,
            size = size,
            funds = funds,
            stp = stp,
            tags = tags,
            remark = remark,
            timeInForce = timeInForce,
            cancelAfter = cancelAfter,
            postOnly = postOnly,
            hidden = hidden,
            iceberg = iceberg,
            visibleSize = visibleSize
        )
        # Remove NULL values
        body_list <- body_list[!sapply(body_list, is.null)]
        body_json <- jsonlite::toJSON(body_list, auto_unbox = TRUE)

        # Prepare API request
        url <- paste0(base_url, endpoint)
        method <- "POST"

        # Generate authentication headers
        headers <- await(build_headers(method, endpoint, body_json, keys))

        # Send POST request
        response <- httr::POST(
            url = url,
            body = body_json,
            headers,
            httr::content_type_json(),
            httr::timeout(3)
        )
        test_vs_live <- grepl("test", endpoint)
        # file_name <- paste0("place_order_helper-", ifelse(test_vs_live, "test", "live"), ".json")
        # saveRDS(response, paste0("../../api-responses/impl_spottrading_market_data/response-", file_name, ".ignore.Rds"))

        parsed_response <- process_kucoin_response(response, url)
        # saveRDS(parsed_response, paste0("../../api-responses/impl_spottrading_market_data/parsed_response-get_market_list_impl-", file_name, ".Rds"))

        if (parsed_response$code != "200000") {
            rlang::abort(sprintf("API error: %s - %s", parsed_response$code, parsed_response$msg))
        }

        # Convert response data to data.table
        result_dt <- data.table::as.data.table(parsed_response$data)

        if (is.null(result_dt$clientOid)) {
            result_dt[, clientOid := NA_character_]
        }

        return(result_dt)
    }, error = function(e) {
        rlang::abort(sprintf("Error in place_order_helper: %s", conditionMessage(e)))
    })
})

#' Add Order (Implementation)
#'
#' Places a new order (limit or market) to the KuCoin Spot trading system asynchronously.
#'
#' @section Requirements Before Use:
#' Before placing orders, please ensure the following:
#'   1. **Check Account Balance**: Verify you have sufficient funds using `get_account_balance_impl()` or related functions.
#'   2. **Get Symbol Information**: Obtain the trading pair details using `get_symbols_impl()` to understand:
#'      - `priceIncrement`: The minimum price precision for limit orders
#'      - `baseIncrement`: The minimum quantity precision for the base asset
#'      - `quoteIncrement`: The minimum funds precision for the quote asset
#'      - `baseMinSize` & `baseMaxSize`: The min/max size limits for the base asset
#'      - `quoteMinSize` & `quoteMaxSize`: The min/max funds limits for the quote asset
#'   3. **Consider Trading Limits**: KuCoin allows maximum 2000 active orders per account, with 200 active orders per trading pair.
#'   4. **Generate Client ID**: Consider using `uuid::UUIDgenerate()` to create unique `clientOid` values.
#'
#' @section Order Types and Parameters:
#' 1. **Limit Orders**:
#'    - Required: `type="limit"`, `symbol`, `side`, `price`, `size`
#'    - The `price` must be a multiple of the trading pair's `priceIncrement`
#'    - The `size` must be a multiple of the trading pair's `baseIncrement` and be between `baseMinSize` and `baseMaxSize`
#'
#' 2. **Market Orders**:
#'    - Required: `type="market"`, `symbol`, `side`, and either `size` OR `funds` (not both)
#'    - For `size` (quantity-based): Must be a multiple of `baseIncrement` and be between `baseMinSize` and `baseMaxSize`
#'    - For `funds` (amount-based): Must be a multiple of `quoteIncrement` and be between `quoteMinSize` and `quoteMaxSize`
#'
#' @section Order Lifecycle:
#' When an order is placed:
#'   1. Funds are frozen for the order duration (full amount for limit orders, estimated amount for market orders)
#'   2. Orders may be partially or fully filled
#'   3. Orders remain active until fully filled or cancelled (except for IOC and FOK orders)
#'   4. Trading fees are deducted upon execution
#'
#' @section Price Protection:
#' KuCoin implements a price protection mechanism:
#'   - For orders that would significantly impact the market price beyond a certain threshold (available via API)
#'   - Limit orders that would breach this threshold are cancelled
#'   - Market orders are partially executed up to the threshold and then stopped
#'
#' @section Self-Trade Prevention:
#' The `stp` parameter offers four strategies to prevent self-trading:
#'   - "CN" (Cancel Newest): Cancel the incoming order
#'   - "CO" (Cancel Oldest): Cancel the existing order
#'   - "CB" (Cancel Both): Cancel both orders
#'   - "DC" (Decrease and Cancel): Decrease the order quantity by the matched amount (from both sides if needed), then cancel if size becomes zero
#'
#' @section Time-In-Force Options:
#'   - "GTC" (Good Till Cancelled): Order remains active until explicitly cancelled
#'   - "GTT" (Good Till Time): Order remains active until cancelled or the `cancelAfter` time is reached
#'   - "IOC" (Immediate Or Cancel): Order is executed immediately for whatever portion can be filled and the rest is cancelled
#'   - "FOK" (Fill Or Kill): Order must be filled in its entirety immediately or be cancelled completely
#'
#' @param keys List; API configuration parameters from `get_api_keys()`. Defaults to `get_api_keys()`.
#' @param base_url Character string; base URL for the KuCoin API. Defaults to `get_base_url()`.
#' @param type Character string; order type: "limit" or "market". Required.
#' @param symbol Character string; trading pair (e.g., "BTC-USDT"). Required.
#' @param side Character string; order side: "buy" or "sell". Required.
#' @param clientOid Character string; unique client order ID (recommended UUID, max 40 chars). Optional.
#' @param price Numeric; price for limit orders. Must align with priceIncrement of the symbol. Required for limit orders.
#' @param size Numeric; quantity for limit or market orders. Must align with baseIncrement of the symbol. 
#'        Required for limit orders, optional for market orders (if funds is provided).
#' @param funds Numeric; funds to use for market orders. Must align with quoteIncrement of the symbol.
#'        Optional for market orders (if size is provided), not applicable for limit orders.
#' @param stp Character string; self-trade prevention strategy: "CN", "CO", "CB", or "DC". Optional.
#' @param tags Character string; order tag (max 20 ASCII chars). Optional.
#' @param remark Character string; order remarks (max 20 ASCII chars). Optional.
#' @param timeInForce Character string; time-in-force strategy: "GTC", "GTT", "IOC", or "FOK". Optional, defaults to "GTC".
#' @param cancelAfter Numeric; cancel after n seconds (for GTT). Required if timeInForce is "GTT", otherwise not applicable.
#' @param postOnly Logical; passive order flag (disabled for IOC/FOK). Optional, defaults to FALSE.
#' @param hidden Logical; hide order from order book. Optional, defaults to FALSE.
#' @param iceberg Logical; show only visible portion in iceberg orders. Optional, defaults to FALSE.
#' @param visibleSize Numeric; max visible quantity for iceberg orders. Optional, required if iceberg is TRUE.
#' @return Promise resolving to a `data.table` containing:
#'   - `orderId` (character): Unique order ID generated by KuCoin.
#'   - `clientOid` (character): Client-specified order ID.
#' @examples
#' \dontrun{
#' # Get symbol information first to understand precision requirements
#' main_async <- coro::async(function() {
#'   # Get symbol information
#'   symbols <- await(get_symbols_impl())
#'   btc_usdt <- symbols[symbol == "BTC-USDT"]
#'   print(paste("Price increment:", btc_usdt$priceIncrement))
#'   print(paste("Base increment:", btc_usdt$baseIncrement))
#'
#'   # Check account balance
#'   balances <- await(get_account_balance_impl())
#'   usdt_balance <- balances[currency == "USDT" & type == "trade", available]
#'   print(paste("Available USDT:", usdt_balance))
#'
#'   # Place a limit buy order
#'   order <- await(add_order_impl(
#'     type = "limit",
#'     symbol = "BTC-USDT",
#'     side = "buy",
#'     price = 50000,     # Will be converted to string internally
#'     size = 0.0001,     # Will be converted to string internally
#'     clientOid = uuid::UUIDgenerate(),
#'     remark = "Test limit order"
#'   ))
#'   print(order)
#'
#'   # Place a market buy order with funds
#'   market_order <- await(add_order_impl(
#'     type = "market",
#'     symbol = "BTC-USDT",
#'     side = "buy",
#'     funds = 10,        # Will be converted to string internally
#'     clientOid = uuid::UUIDgenerate()
#'   ))
#'   print(market_order)
#' })
#' main_async()
#' while (!later::loop_empty()) later::run_now()
#' }
#' @importFrom coro async await
#' @importFrom data.table as.data.table
#' @importFrom httr POST timeout content_type_json
#' @importFrom jsonlite toJSON
#' @importFrom rlang abort arg_match0
#' @export
add_order_impl <- coro::async(function(
    keys = get_api_keys(),
    base_url = get_base_url(),
    type,
    symbol,
    side,
    clientOid = NULL,
    price = NULL,
    size = NULL,
    funds = NULL,
    stp = NULL,
    tags = NULL,
    remark = NULL,
    timeInForce = NULL,
    cancelAfter = NULL,
    postOnly = NULL,
    hidden = NULL,
    iceberg = NULL,
    visibleSize = NULL
) {
    return(place_order_helper(
        keys = keys,
        base_url = base_url,
        endpoint = "/api/v1/hf/orders",
        type = type,
        symbol = symbol,
        side = side,
        clientOid = clientOid,
        price = price,
        size = size,
        funds = funds,
        stp = stp,
        tags = tags,
        remark = remark,
        timeInForce = timeInForce,
        cancelAfter = cancelAfter,
        postOnly = postOnly,
        hidden = hidden,
        iceberg = iceberg,
        visibleSize = visibleSize
    ))
})

#' Add Order Test (Implementation)
#'
#' Simulates placing a new order (limit or market) to the KuCoin Spot trading system asynchronously for testing purposes.
#' This function validates parameters and checks the signature without actually placing an order.
#' It returns the same response structure as the actual order placement endpoint.
#'
#' @section Purpose:
#' This function is useful for:
#'   1. Testing your API authentication setup without risking funds
#'   2. Validating parameter values and formats before placing actual orders
#'   3. Checking if an order would be accepted without executing it
#'   4. Understanding the response format for order placement
#'
#' @section Requirements Before Use:
#' See the documentation for `add_order_impl()` for details on prerequisites and parameter requirements.
#' 
#' @param keys List; API configuration parameters from `get_api_keys()`. Defaults to `get_api_keys()`.
#' @param base_url Character string; base URL for the KuCoin API. Defaults to `get_base_url()`.
#' @param type Character string; order type: "limit" or "market". Required.
#' @param symbol Character string; trading pair (e.g., "BTC-USDT"). Required.
#' @param side Character string; order side: "buy" or "sell". Required.
#' @param clientOid Character string; unique client order ID (recommended UUID, max 40 chars). Optional.
#' @param price Numeric; price for limit orders. Must align with priceIncrement of the symbol. Required for limit orders.
#' @param size Numeric; quantity for limit or market orders. Must align with baseIncrement of the symbol. 
#'        Required for limit orders, optional for market orders (if funds is provided).
#' @param funds Numeric; funds to use for market orders. Must align with quoteIncrement of the symbol.
#'        Optional for market orders (if size is provided), not applicable for limit orders.
#' @param stp Character string; self-trade prevention strategy: "CN", "CO", "CB", or "DC". Optional.
#' @param tags Character string; order tag (max 20 ASCII chars). Optional.
#' @param remark Character string; order remarks (max 20 ASCII chars). Optional.
#' @param timeInForce Character string; time-in-force strategy: "GTC", "GTT", "IOC", or "FOK". Optional, defaults to "GTC".
#' @param cancelAfter Numeric; cancel after n seconds (for GTT). Required if timeInForce is "GTT", otherwise not applicable.
#' @param postOnly Logical; passive order flag (disabled for IOC/FOK). Optional, defaults to FALSE.
#' @param hidden Logical; hide order from order book. Optional, defaults to FALSE.
#' @param iceberg Logical; show only visible portion in iceberg orders. Optional, defaults to FALSE.
#' @param visibleSize Numeric; max visible quantity for iceberg orders. Optional, required if iceberg is TRUE.
#' @return Promise resolving to a `data.table` containing:
#'   - `orderId` (character): Simulated unique order ID.
#'   - `clientOid` (character): Client-specified order ID.
#' @examples
#' \dontrun{
#' main_async <- coro::async(function() {
#'   # Test a limit buy order
#'   test_order <- await(add_order_test_impl(
#'     type = "limit",
#'     symbol = "BTC-USDT",
#'     side = "buy",
#'     price = 50000,
#'     size = 0.0001,
#'     clientOid = uuid::UUIDgenerate(),
#'     remark = "Test limit order"
#'   ))
#'   print(test_order)
#'
#'   # Test a market buy order with funds
#'   test_market_order <- await(add_order_test_impl(
#'     type = "market",
#'     symbol = "BTC-USDT",
#'     side = "buy",
#'     funds = 10,
#'     clientOid = uuid::UUIDgenerate()
#'   ))
#'   print(test_market_order)
#' })
#' main_async()
#' while (!later::loop_empty()) later::run_now()
#' }
#' @importFrom coro async await
#' @importFrom data.table as.data.table
#' @importFrom httr POST timeout content_type_json
#' @importFrom jsonlite toJSON
#' @importFrom rlang abort arg_match0
#' @export
add_order_test_impl <- coro::async(function(
    keys = get_api_keys(),
    base_url = get_base_url(),
    type,
    symbol,
    side,
    clientOid = NULL,
    price = NULL,
    size = NULL,
    funds = NULL,
    stp = NULL,
    tags = NULL,
    remark = NULL,
    timeInForce = NULL,
    cancelAfter = NULL,
    postOnly = NULL,
    hidden = NULL,
    iceberg = NULL,
    visibleSize = NULL
) {
    return(place_order_helper(
        keys = keys,
        base_url = base_url,
        endpoint = "/api/v1/hf/orders/test",
        type = type,
        symbol = symbol,
        side = side,
        clientOid = clientOid,
        price = price,
        size = size,
        funds = funds,
        stp = stp,
        tags = tags,
        remark = remark,
        timeInForce = timeInForce,
        cancelAfter = cancelAfter,
        postOnly = postOnly,
        hidden = hidden,
        iceberg = iceberg,
        visibleSize = visibleSize
    ))
})

# ------------------------------------------------------------------------------

#' Validate a Single Order for Batch Placement
#'
#' Validates the parameters of a single order within a batch, ensuring all required fields are present
#' and optional fields meet KuCoin's specifications. Sets default values where applicable.
#'
#' @param order List; a list containing order parameters such as `symbol`, `type`, `side`, etc.
#' @return List; the validated order with defaults applied.
validate_order <- function(order) {
    if (!is.list(order)) {
        rlang::abort("Each order must be a list.")
    }

    # Check required fields
    required_fields <- c("symbol", "type", "side")
    for (field in required_fields) {
        if (is.null(order[[field]])) {
            rlang::abort(sprintf("Missing required field '%s' in order.", field))
        }
    }

    # Validate core parameters
    type <- rlang::arg_match0(order$type, c("limit", "market"))
    side <- rlang::arg_match0(order$side, c("buy", "sell"))
    if (!verify_symbol(order$symbol)) {
        rlang::abort(sprintf("Invalid symbol '%s' in order.", order$symbol))
    }

    # Initialize validated order with required fields
    validated_order <- list(
        symbol = order$symbol,
        type = type,
        side = side
    )

    # Convert numeric parameters to character strings as required by the API
    if (!is.null(order$price)) {
        order$price <- as.character(order$price)
    }
    if (!is.null(order$size)) {
        order$size <- as.character(order$size)
    }
    if (!is.null(order$funds)) {
        order$funds <- as.character(order$funds)
    }
    if (!is.null(order$visibleSize)) {
        order$visibleSize <- as.character(order$visibleSize)
    }

    # Type-specific validation
    if (type == "limit") {
        if (is.null(order$price)) {
            rlang::abort("Parameter 'price' is required for limit orders.")
        }
        if (is.null(order$size)) {
            rlang::abort("Parameter 'size' is required for limit orders.")
        }
        if (!is.null(order$funds)) {
            rlang::abort("Parameter 'funds' is not applicable for limit orders.")
        }
        validated_order$price <- order$price
        validated_order$size <- order$size
    } else if (type == "market") {
        if (!is.null(order$price)) {
            rlang::abort("Parameter 'price' is not applicable for market orders.")
        }
        if (is.null(order$size) && is.null(order$funds)) {
            rlang::abort("Either 'size' or 'funds' must be specified for market orders.")
        }
        if (!is.null(order$size) && !is.null(order$funds)) {
            rlang::abort("Parameters 'size' and 'funds' are mutually exclusive for market orders.")
        }
        if (!is.null(order$size)) {
            validated_order$size <- order$size
        }
        if (!is.null(order$funds)) {
            validated_order$funds <- order$funds
        }
    }

    # Validate optional parameters
    if (!is.null(order$clientOid)) {
        if (!is.character(order$clientOid) || nchar(order$clientOid) > 40 || !grepl("^[a-zA-Z0-9_-]+$", order$clientOid)) {
            rlang::abort("Parameter 'clientOid' must be a string with maximum 40 characters, containing only letters, numbers, underscores, or hyphens.")
        }
        validated_order$clientOid <- order$clientOid
    }
    if (!is.null(order$stp)) {
        validated_order$stp <- rlang::arg_match0(order$stp, c("CN", "CO", "CB", "DC"))
    }
    if (!is.null(order$tags)) {
        if (!is.character(order$tags) || nchar(order$tags) > 20 || !all(charToRaw(order$tags) <= 127)) {
            rlang::abort("Parameter 'tags' must be ASCII and maximum 20 characters.")
        }
        validated_order$tags <- order$tags
    }
    if (!is.null(order$remark)) {
        if (!is.character(order$remark) || nchar(order$remark) > 20 || !all(charToRaw(order$remark) <= 127)) {
            rlang::abort("Parameter 'remark' must be ASCII and maximum 20 characters.")
        }
        validated_order$remark <- order$remark
    }
    if (!is.null(order$timeInForce)) {
        validated_order$timeInForce <- rlang::arg_match0(order$timeInForce, c("GTC", "GTT", "IOC", "FOK"))
    } else {
        validated_order$timeInForce <- "GTC"  # Default as per API documentation
    }
    if (!is.null(order$cancelAfter)) {
        if (!is.numeric(order$cancelAfter) || order$cancelAfter <= 0) {
            rlang::abort("Parameter 'cancelAfter' must be a positive number.")
        }
        validated_order$cancelAfter <- as.integer(order$cancelAfter)
    }
    if (is.null(order$postOnly)) {
        validated_order$postOnly <- FALSE  # Default as per API documentation
    } else if (!is.logical(order$postOnly)) {
        rlang::abort("Parameter 'postOnly' must be a logical value.")
    } else {
        validated_order$postOnly <- order$postOnly
    }
    if (is.null(order$hidden)) {
        validated_order$hidden <- FALSE  # Default as per API documentation
    } else if (!is.logical(order$hidden)) {
        rlang::abort("Parameter 'hidden' must be a logical value.")
    } else {
        validated_order$hidden <- order$hidden
    }
    if (is.null(order$iceberg)) {
        validated_order$iceberg <- FALSE  # Default as per API documentation
    } else if (!is.logical(order$iceberg)) {
        rlang::abort("Parameter 'iceberg' must be a logical value.")
    } else {
        validated_order$iceberg <- order$iceberg
    }
    if (!is.null(order$visibleSize)) {
        if (!validated_order$iceberg) {
            rlang::abort("Parameter 'visibleSize' is only applicable when 'iceberg' is TRUE.")
        }
        validated_order$visibleSize <- order$visibleSize
    }

    # Additional validation for timeInForce constraints
    if (validated_order$timeInForce == "GTT" && is.null(validated_order$cancelAfter)) {
        rlang::abort("Parameter 'cancelAfter' is required when 'timeInForce' is 'GTT'.")
    }
    if (validated_order$postOnly && validated_order$timeInForce %in% c("IOC", "FOK")) {
        rlang::abort("Parameter 'postOnly' cannot be TRUE when 'timeInForce' is 'IOC' or 'FOK'.")
    }
    if (validated_order$iceberg && validated_order$hidden) {
        rlang::abort("Parameters 'iceberg' and 'hidden' cannot both be TRUE.")
    }

    return(validated_order)
}

#' Add Orders Batch (Implementation)
#'
#' Places multiple new orders (up to 20) to the KuCoin Spot trading system asynchronously.
#' This function validates a list of orders, constructs a batch request, and returns the placement results for each order.
#'
#' @section Requirements Before Use:
#' See the documentation for `add_order_impl()` for detailed prerequisites. Additionally:
#'   1. Maximum 20 orders can be included in a single batch request
#'   2. Each order must meet the same validation criteria as individual orders
#'   3. Consider the total account impact of all orders in the batch
#'
#' @section Batch Response Handling:
#' Unlike individual order placement, batch responses include a success/failure status for each order:
#'   - Orders may partially succeed - some orders can be placed while others fail
#'   - Failed orders include error messages in the `failMsg` field
#'   - You should check the `success` field for each order to verify placement
#'
#' @param keys List; API configuration parameters from `get_api_keys()`. Defaults to `get_api_keys()`.
#' @param base_url Character string; base URL for the KuCoin API. Defaults to `get_base_url()`.
#' @param order_list List; a list of orders, where each order is a list with parameters:
#'   - `symbol` (character): Trading pair (e.g., "BTC-USDT"). Required.
#'   - `type` (character): Order type: "limit" or "market". Required.
#'   - `side` (character): Order side: "buy" or "sell". Required.
#'   - `clientOid` (character): Unique client order ID (max 40 chars). Optional.
#'   - `price` (numeric): Price for limit orders. Required for limit.
#'   - `size` (numeric): Quantity for limit or market orders. Required for limit, optional for market.
#'   - `funds` (numeric): Funds for market orders. Optional for market, mutually exclusive with `size`.
#'   - Other optional parameters as described in `add_order_impl()`
#' @return Promise resolving to a `data.table` containing results for each order, with columns:
#'   - `success` (logical): Whether the order placement was successful.
#'   - `orderId` (character): Unique order ID (if successful).
#'   - `clientOid` (character): Client-specified order ID (if provided).
#'   - `failMsg` (character): Error message (if failed).
#' @examples
#' \dontrun{
#' main_async <- coro::async(function() {
#'   # Define two orders
#'   order1 <- list(
#'     clientOid = uuid::UUIDgenerate(),
#'     symbol = "BTC-USDT",
#'     type = "limit",
#'     side = "buy",
#'     price = 30000,
#'     size = 0.00001,
#'     remark = "Batch buy"
#'   )
#'   order2 <- list(
#'     clientOid = uuid::UUIDgenerate(),
#'     symbol = "ETH-USDT",
#'     type = "market",
#'     side = "sell",
#'     size = 0.01
#'   )
#'   # Place batch orders
#'   result <- await(add_order_batch_impl(order_list = list(order1, order2)))
#'   print(result)
#' })
#' main_async()
#' while (!later::loop_empty()) later::run_now()
#' }
#' @importFrom coro async await
#' @importFrom data.table as.data.table
#' @importFrom httr POST timeout content_type_json
#' @importFrom jsonlite toJSON
#' @importFrom rlang abort arg_match0
#' @export
add_order_batch_impl <- coro::async(function(
    keys = get_api_keys(),
    base_url = get_base_url(),
    order_list
) {
    tryCatch({
        # Validate order_list
        if (!is.list(order_list) || length(order_list) == 0 || length(order_list) > 20) {
            rlang::abort("Parameter 'order_list' must be a list containing 1 to 20 orders.")
        }

        # Validate each order in the list
        validated_orders <- lapply(order_list, validate_order)

        # Construct request body
        body_list <- list(orderList = validated_orders)
        body_json <- jsonlite::toJSON(body_list, auto_unbox = TRUE)

        # Prepare API request
        endpoint <- "/api/v1/hf/orders/multi"
        url <- paste0(base_url, endpoint)
        method <- "POST"

        # Generate authentication headers
        headers <- await(build_headers(method, endpoint, body_json, keys))

        # Send POST request
        response <- httr::POST(
            url = url,
            body = body_json,
            headers,
            httr::content_type_json(),
            httr::timeout(3)
        )

        # Process response
        parsed_response <- process_kucoin_response(response, url)
        if (parsed_response$code != "200000") {
            rlang::abort(sprintf("API error: %s - %s", parsed_response$code, parsed_response$msg))
        }

        # Convert response data to data.table
        result_dt <- data.table::as.data.table(parsed_response$data)

        return(result_dt)
    }, error = function(e) {
        rlang::abort(sprintf("Error in add_order_batch_impl: %s", conditionMessage(e)))
    })
})

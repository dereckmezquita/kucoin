# File: ./R/impl_spottrading_orders_add_order.R

box::use(
    ./helpers_api[process_kucoin_response, build_headers],
    ./utils[build_query, get_base_url, verify_symbol],
    ./utils_time_convert_kucoin[time_convert_to_kucoin],
    coro[async, await],
    data.table[as.data.table],
    httr[POST, timeout, content_type_json],
    jsonlite[toJSON],
    rlang[abort, arg_match0]
)

#' Place Order (Shared Implementation)
#'
#' This is a shared helper function for placing orders or testing order placement on the KuCoin Spot trading system.
#' It handles parameter validation, request body construction, authentication, API request sending, and response processing.
#'
#' @param keys List; API configuration parameters from `get_api_keys()`, including:
#'   - `api_key` (character): KuCoin API key.
#'   - `api_secret` (character): KuCoin API secret.
#'   - `api_passphrase` (character): KuCoin API passphrase.
#'   - `key_version` (character): API key version (e.g., "2"). Defaults to `get_api_keys()`.
#' @param base_url Character string; base URL for the KuCoin API. Defaults to `get_base_url()`.
#' @param endpoint Character string; the API endpoint to use (e.g., "/api/v1/hf/orders" or "/api/v1/hf/orders/test").
#' @param type Character string; order type: "limit" or "market". Required.
#' @param symbol Character string; trading pair (e.g., "BTC-USDT"). Required.
#' @param side Character string; order side: "buy" or "sell". Required.
#' @param clientOid Character string; unique client order ID (recommended UUID, max 40 chars). Optional.
#' @param price Character string; price for limit orders (must align with priceIncrement). Required for limit orders.
#' @param size Character string; quantity for limit or market orders (must align with baseIncrement). Required for limit, optional for market.
#' @param funds Character string; funds for market orders (must align with quoteIncrement). Optional for market, mutually exclusive with size.
#' @param stp Character string; self-trade prevention strategy: "CN", "CO", "CB", or "DC". Optional.
#' @param tags Character string; order tag (max 20 ASCII chars). Optional.
#' @param remark Character string; order remarks (max 20 ASCII chars). Optional.
#' @param timeInForce Character string; time-in-force strategy: "GTC", "GTT", "IOC", or "FOK". Optional, defaults to "GTC".
#' @param cancelAfter Integer; cancel after n seconds (for GTT). Optional.
#' @param postOnly Logical; passive order flag (disabled for IOC/FOK). Optional, defaults to FALSE.
#' @param hidden Logical; hide order from order book. Optional, defaults to FALSE.
#' @param iceberg Logical; show only visible portion in iceberg orders. Optional, defaults to FALSE.
#' @param visibleSize Character string; max visible quantity for iceberg orders. Optional.
#' @return Promise resolving to a `data.table` containing:
#'   - `orderId` (character): Unique order ID generated by KuCoin (or simulated for test).
#'   - `clientOid` (character): Client-specified order ID.
place_order_helper <- coro::async(function(
    keys = get_api_keys(),
    base_url = get_base_url(),
    endpoint,
    type,
    symbol,
    side,
    clientOid = NULL,
    price = NULL,
    size = NULL,
    funds = NULL,
    stp = NULL,
    tags = NULL,
    remark = NULL,
    timeInForce = NULL,
    cancelAfter = NULL,
    postOnly = NULL,
    hidden = NULL,
    iceberg = NULL,
    visibleSize = NULL
) {
    tryCatch({
        # Validate required parameters
        type <- rlang::arg_match0(type, c("limit", "market"), arg_name = "type")
        if (is.null(symbol) || !verify_symbol(symbol)) {
            rlang::abort("Parameter 'symbol' must be a valid ticker (e.g., 'BTC-USDT').")
        }
        side <- rlang::arg_match0(side, c("buy", "sell"), arg_name = "side")

        # Validate order type-specific parameters
        if (type == "limit") {
            if (is.null(price) || !is.character(price)) {
                rlang::abort("Parameter 'price' is required for limit orders and must be a character string.")
            }
            if (is.null(size) || !is.character(size)) {
                rlang::abort("Parameter 'size' is required for limit orders and must be a character string.")
            }
            if (!is.null(funds)) {
                rlang::abort("Parameter 'funds' is not applicable for limit orders.")
            }
        } else if (type == "market") {
            if (!is.null(price)) {
                rlang::abort("Parameter 'price' is not applicable for market orders.")
            }
            if (is.null(size) && is.null(funds)) {
                rlang::abort("Either 'size' or 'funds' must be specified for market orders.")
            }
            if (!is.null(size) && !is.null(funds)) {
                rlang::abort("Parameters 'size' and 'funds' are mutually exclusive for market orders.")
            }
            if (!is.null(size) && !is.character(size)) {
                rlang::abort("Parameter 'size' must be a character string for market orders.")
            }
            if (!is.null(funds) && !is.character(funds)) {
                rlang::abort("Parameter 'funds' must be a character string for market orders.")
            }
        }

        # Validate optional parameters
        if (!is.null(clientOid)) {
            if (!is.character(clientOid) || nchar(clientOid) > 40 || !grepl("^[a-zA-Z0-9_-]+$", clientOid)) {
                rlang::abort("Parameter 'clientOid' must be a string with maximum 40 characters, containing only letters, numbers, underscores, or hyphens.")
            }
        }
        if (!is.null(stp)) {
            stp <- rlang::arg_match0(stp, c("CN", "CO", "CB", "DC"), arg_name = "stp")
        }
        if (!is.null(tags)) {
            if (!is.character(tags) || nchar(tags) > 20 || !grepl("^[[:ascii:]]+$", tags)) {
                rlang::abort("Parameter 'tags' must be ASCII and maximum 20 characters.")
            }
        }
        if (!is.null(remark)) {
            if (!is.character(remark) || nchar(remark) > 20 || !grepl("^[[:ascii:]]+$", remark)) {
                rlang::abort("Parameter 'remark' must be ASCII and maximum 20 characters.")
            }
        }
        if (!is.null(timeInForce)) {
            timeInForce <- rlang::arg_match0(timeInForce, c("GTC", "GTT", "IOC", "FOK"), arg_name = "timeInForce")
        } else {
            timeInForce <- "GTC"  # Default as per API documentation
        }
        if (!is.null(cancelAfter)) {
            if (!is.numeric(cancelAfter) || cancelAfter <= 0) {
                rlang::abort("Parameter 'cancelAfter' must be a positive number.")
            }
        }
        if (!is.null(postOnly)) {
            if (!is.logical(postOnly)) {
                rlang::abort("Parameter 'postOnly' must be a logical value.")
            }
        } else {
            postOnly <- FALSE  # Default as per API documentation
        }
        if (!is.null(hidden)) {
            if (!is.logical(hidden)) {
                rlang::abort("Parameter 'hidden' must be a logical value.")
            }
        } else {
            hidden <- FALSE  # Default as per API documentation
        }
        if (!is.null(iceberg)) {
            if (!is.logical(iceberg)) {
                rlang::abort("Parameter 'iceberg' must be a logical value.")
            }
        } else {
            iceberg <- FALSE  # Default as per API documentation
        }
        if (!is.null(visibleSize)) {
            if (!is.character(visibleSize)) {
                rlang::abort("Parameter 'visibleSize' must be a character string.")
            }
            if (!iceberg) {
                rlang::abort("Parameter 'visibleSize' is only applicable when 'iceberg' is TRUE.")
            }
        }

        # Additional validation for timeInForce constraints
        if (timeInForce == "GTT" && is.null(cancelAfter)) {
            rlang::abort("Parameter 'cancelAfter' is required when 'timeInForce' is 'GTT'.")
        }
        if (postOnly && timeInForce %in% c("IOC", "FOK")) {
            rlang::abort("Parameter 'postOnly' cannot be TRUE when 'timeInForce' is 'IOC' or 'FOK'.")
        }
        if (iceberg && hidden) {
            rlang::abort("Parameters 'iceberg' and 'hidden' cannot both be TRUE.")
        }

        # Construct request body
        body_list <- list(
            type = type,
            symbol = symbol,
            side = side,
            clientOid = clientOid,
            price = price,
            size = size,
            funds = funds,
            stp = stp,
            tags = tags,
            remark = remark,
            timeInForce = timeInForce,
            cancelAfter = if (!is.null(cancelAfter)) as.integer(cancelAfter) else NULL,
            postOnly = postOnly,
            hidden = hidden,
            iceberg = iceberg,
            visibleSize = visibleSize
        )
        # Remove NULL values
        body_list <- body_list[!sapply(body_list, is.null)]
        body_json <- jsonlite::toJSON(body_list, auto_unbox = TRUE)

        # Prepare API request
        url <- paste0(base_url, endpoint)
        method <- "POST"

        # Generate authentication headers
        headers <- await(build_headers(method, endpoint, body_json, keys))

        # Send POST request
        response <- httr::POST(
            url = url,
            body = body_json,
            headers,
            httr::content_type_json(),
            httr::timeout(3)
        )

        # Process response
        parsed_response <- process_kucoin_response(response, url)
        if (parsed_response$code != "200000") {
            rlang::abort(sprintf("API error: %s - %s", parsed_response$code, parsed_response$msg))
        }

        # Convert response data to data.table
        result_dt <- data.table::as.data.table(parsed_response$data)

        return(result_dt)
    }, error = function(e) {
        rlang::abort(sprintf("Error in place_order_helper: %s", conditionMessage(e)))
    })
})

#' Add Order (Implementation)
#'
#' Places a new order (limit or market) to the KuCoin Spot trading system asynchronously.
#' This function handles both limit and market order types, validates parameters according to KuCoin's specifications,
#' and returns the order ID and client order ID upon successful placement.
#'
#' ### Workflow Overview
#' 1. **Parameter Validation**: Validates required and optional parameters based on order type (limit/market) using `rlang::arg_match0` for enumerated values.
#' 2. **Request Body Construction**: Builds a JSON body with mandatory and optional parameters.
#' 3. **Authentication**: Generates headers with API credentials using `build_headers()`.
#' 4. **API Request**: Sends a POST request to the KuCoin API with a 3-second timeout.
#' 5. **Response Processing**: Parses the response, validates success, and returns order details as a `data.table`.
#'
#' ### API Endpoint
#' `POST https://api.kucoin.com/api/v1/hf/orders`
#'
#' ### Usage
#' Utilised to place spot trading orders on KuCoin. Supports limit orders (price + size) and market orders (size or funds).
#' Requires sufficient funds in the account and adheres to KuCoin's trading rules (e.g., max 2000 active orders).
#'
#' ### Official Documentation
#' [KuCoin Add Order](https://www.kucoin.com/docs-new/rest/spot-trading/orders/add-order)
#'
#' @param keys List; API configuration parameters from `get_api_keys()`. Defaults to `get_api_keys()`.
#' @param base_url Character string; base URL for the KuCoin API. Defaults to `get_base_url()`.
#' @param type Character string; order type: "limit" or "market". Required.
#' @param symbol Character string; trading pair (e.g., "BTC-USDT"). Required.
#' @param side Character string; order side: "buy" or "sell". Required.
#' @param clientOid Character string; unique client order ID (recommended UUID, max 40 chars). Optional.
#' @param price Character string; price for limit orders (must align with priceIncrement). Required for limit orders.
#' @param size Character string; quantity for limit or market orders (must align with baseIncrement). Required for limit, optional for market.
#' @param funds Character string; funds for market orders (must align with quoteIncrement). Optional for market, mutually exclusive with size.
#' @param stp Character string; self-trade prevention strategy: "CN", "CO", "CB", or "DC". Optional.
#' @param tags Character string; order tag (max 20 ASCII chars). Optional.
#' @param remark Character string; order remarks (max 20 ASCII chars). Optional.
#' @param timeInForce Character string; time-in-force strategy: "GTC", "GTT", "IOC", or "FOK". Optional, defaults to "GTC".
#' @param cancelAfter Integer; cancel after n seconds (for GTT). Optional.
#' @param postOnly Logical; passive order flag (disabled for IOC/FOK). Optional, defaults to FALSE.
#' @param hidden Logical; hide order from order book. Optional, defaults to FALSE.
#' @param iceberg Logical; show only visible portion in iceberg orders. Optional, defaults to FALSE.
#' @param visibleSize Character string; max visible quantity for iceberg orders. Optional.
#' @return Promise resolving to a `data.table` containing:
#'   - `orderId` (character): Unique order ID generated by KuCoin.
#'   - `clientOid` (character): Client-specified order ID.
#' @examples
#' \dontrun{
#' main_async <- coro::async(function() {
#'   # Place a limit buy order
#'   order <- await(add_order_impl(
#'     type = "limit",
#'     symbol = "BTC-USDT",
#'     side = "buy",
#'     price = "50000",
#'     size = "0.0001",
#'     clientOid = uuid::UUIDgenerate(),
#'     remark = "Test limit order"
#'   ))
#'   print(order)
#'
#'   # Place a market buy order with funds
#'   market_order <- await(add_order_impl(
#'     type = "market",
#'     symbol = "BTC-USDT",
#'     side = "buy",
#'     funds = "10",
#'     clientOid = uuid::UUIDgenerate()
#'   ))
#'   print(market_order)
#' })
#' main_async()
#' while (!later::loop_empty()) later::run_now()
#' }
#' @importFrom coro async await
#' @importFrom data.table as.data.table
#' @importFrom httr POST timeout content_type_json
#' @importFrom jsonlite toJSON
#' @importFrom rlang abort arg_match0
#' @export
add_order_impl <- coro::async(function(
    keys = get_api_keys(),
    base_url = get_base_url(),
    type,
    symbol,
    side,
    clientOid = NULL,
    price = NULL,
    size = NULL,
    funds = NULL,
    stp = NULL,
    tags = NULL,
    remark = NULL,
    timeInForce = NULL,
    cancelAfter = NULL,
    postOnly = NULL,
    hidden = NULL,
    iceberg = NULL,
    visibleSize = NULL
) {
    return(place_order_helper(
        keys = keys,
        base_url = base_url,
        endpoint = "/api/v1/hf/orders",
        type = type,
        symbol = symbol,
        side = side,
        clientOid = clientOid,
        price = price,
        size = size,
        funds = funds,
        stp = stp,
        tags = tags,
        remark = remark,
        timeInForce = timeInForce,
        cancelAfter = cancelAfter,
        postOnly = postOnly,
        hidden = hidden,
        iceberg = iceberg,
        visibleSize = visibleSize
    ))
})

#' Add Order Test (Implementation)
#'
#' Simulates placing a new order (limit or market) to the KuCoin Spot trading system asynchronously for testing purposes.
#' This function validates parameters and checks the signature without actually placing an order.
#' It returns the same response structure as the actual order placement endpoint.
#'
#' ### Workflow Overview
#' 1. **Parameter Validation**: Validates required and optional parameters based on order type (limit/market) using `rlang::arg_match0` for enumerated values.
#' 2. **Request Body Construction**: Builds a JSON body with mandatory and optional parameters.
#' 3. **Authentication**: Generates headers with API credentials using `build_headers()`.
#' 4. **API Request**: Sends a POST request to the KuCoin API test endpoint with a 3-second timeout.
#' 5. **Response Processing**: Parses the response, validates success, and returns simulated order details as a `data.table`.
#'
#' ### API Endpoint
#' `POST https://api.kucoin.com/api/v1/hf/orders/test`
#'
#' ### Usage
#' Utilised to test order placement logic and signature validity without affecting the actual trading system.
#'
#' ### Official Documentation
#' [KuCoin Add Order Test](https://www.kucoin.com/docs-new/rest/spot-trading/orders/add-order-test)
#'
#' @param keys List; API configuration parameters from `get_api_keys()`. Defaults to `get_api_keys()`.
#' @param base_url Character string; base URL for the KuCoin API. Defaults to `get_base_url()`.
#' @param type Character string; order type: "limit" or "market". Required.
#' @param symbol Character string; trading pair (e.g., "BTC-USDT"). Required.
#' @param side Character string; order side: "buy" or "sell". Required.
#' @param clientOid Character string; unique client order ID (recommended UUID, max 40 chars). Optional.
#' @param price Character string; price for limit orders (must align with priceIncrement). Required for limit orders.
#' @param size Character string; quantity for limit or market orders (must align with baseIncrement). Required for limit, optional for market.
#' @param funds Character string; funds for market orders (must align with quoteIncrement). Optional for market, mutually exclusive with size.
#' @param stp Character string; self-trade prevention strategy: "CN", "CO", "CB", or "DC". Optional.
#' @param tags Character string; order tag (max 20 ASCII chars). Optional.
#' @param remark Character string; order remarks (max 20 ASCII chars). Optional.
#' @param timeInForce Character string; time-in-force strategy: "GTC", "GTT", "IOC", or "FOK". Optional, defaults to "GTC".
#' @param cancelAfter Integer; cancel after n seconds (for GTT). Optional.
#' @param postOnly Logical; passive order flag (disabled for IOC/FOK). Optional, defaults to FALSE.
#' @param hidden Logical; hide order from order book. Optional, defaults to FALSE.
#' @param iceberg Logical; show only visible portion in iceberg orders. Optional, defaults to FALSE.
#' @param visibleSize Character string; max visible quantity for iceberg orders. Optional.
#' @return Promise resolving to a `data.table` containing:
#'   - `orderId` (character): Simulated unique order ID.
#'   - `clientOid` (character): Client-specified order ID.
#' @examples
#' \dontrun{
#' main_async <- coro::async(function() {
#'   # Test a limit buy order
#'   test_order <- await(add_order_test_impl(
#'     type = "limit",
#'     symbol = "BTC-USDT",
#'     side = "buy",
#'     price = "50000",
#'     size = "0.0001",
#'     clientOid = uuid::UUIDgenerate(),
#'     remark = "Test limit order"
#'   ))
#'   print(test_order)
#'
#'   # Test a market buy order with funds
#'   test_market_order <- await(add_order_test_impl(
#'     type = "market",
#'     symbol = "BTC-USDT",
#'     side = "buy",
#'     funds = "10",
#'     clientOid = uuid::UUIDgenerate()
#'   ))
#'   print(test_market_order)
#' })
#' main_async()
#' while (!later::loop_empty()) later::run_now()
#' }
#' @importFrom coro async await
#' @importFrom data.table as.data.table
#' @importFrom httr POST timeout content_type_json
#' @importFrom jsonlite toJSON
#' @importFrom rlang abort arg_match0
#' @export
add_order_test_impl <- coro::async(function(
    keys = get_api_keys(),
    base_url = get_base_url(),
    type,
    symbol,
    side,
    clientOid = NULL,
    price = NULL,
    size = NULL,
    funds = NULL,
    stp = NULL,
    tags = NULL,
    remark = NULL,
    timeInForce = NULL,
    cancelAfter = NULL,
    postOnly = NULL,
    hidden = NULL,
    iceberg = NULL,
    visibleSize = NULL
) {
    return(place_order_helper(
        keys = keys,
        base_url = base_url,
        endpoint = "/api/v1/hf/orders/test",
        type = type,
        symbol = symbol,
        side = side,
        clientOid = clientOid,
        price = price,
        size = size,
        funds = funds,
        stp = stp,
        tags = tags,
        remark = remark,
        timeInForce = timeInForce,
        cancelAfter = cancelAfter,
        postOnly = postOnly,
        hidden = hidden,
        iceberg = iceberg,
        visibleSize = visibleSize
    ))
})

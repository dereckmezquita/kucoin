# File: ./R/impl_spottrading_orders_stop.R

box::use(
    ./helpers_api[process_kucoin_response, build_headers],
    ./utils[build_query, get_base_url, verify_symbol, get_api_keys],
    coro[async, await],
    data.table[data.table],
    httr[POST, timeout, content_type_json],
    jsonlite[toJSON],
    rlang[abort, arg_match0]
)

#' Add Stop Order (Implementation)
#'
#' Places a stop order (limit or market) on the KuCoin Spot trading system asynchronously.
#' This function constructs a JSON request body, sends it to the KuCoin API, and returns a `data.table`
#' containing the resulting order ID and client order ID.
#'
#' ## Description
#' This endpoint allows users to place a stop order on the KuCoin Spot trading system, which triggers when the market price reaches the specified `stopPrice`. Two types of stop orders are supported:
#' - **Limit Stop Order**: Executes at a specified `price` once triggered, requiring both `price` and `size`.
#' - **Market Stop Order**: Executes as a market order once triggered, requiring either `size` or `funds`.
#'
#' The maximum number of untriggered stop orders per trading pair in one account is 20. The function validates parameters based on the order type and ensures compliance with KuCoin API constraints.
#'
#' ## Workflow
#' 1. **Parameter Validation**: Ensures required fields (`type`, `symbol`, `side`, `stopPrice`) are valid, and type-specific fields (`price`, `size`, `funds`) meet requirements.
#' 2. **Request Construction**: Builds a JSON body with required and optional parameters.
#' 3. **Authentication**: Generates private API headers using `build_headers()` with the POST method, endpoint, and request body.
#' 4. **API Request**: Sends a POST request to the KuCoin API with a 3-second timeout.
#' 5. **Response Processing**: Parses the response, validates success, and returns a `data.table` with `orderId` and `clientOid`.
#'
#' ## API Details
#' - **Endpoint**: `POST https://api.kucoin.com/api/v1/stop-order`
#' - **Domain**: Spot
#' - **API Channel**: Private
#' - **API Permission**: Spot
#' - **Rate Limit Pool**: Spot
#' - **Rate Limit Weight**: 1
#' - **SDK Service**: Spot
#' - **SDK Sub-Service**: Order
#' - **SDK Method Name**: addStopOrder
#' - **Official Documentation**: [KuCoin Add Stop Order](https://www.kucoin.com/docs-new/rest/spot-trading/orders/add-stop-order)
#'
#' ## Request
#' ### Body Parameters (application/json)
#' - `type`: Enum<String> (required) - Order type: "limit" or "market".
#' - `symbol`: String (required) - Trading pair symbol (e.g., "BTC-USDT").
#' - `side`: Enum<String> (required) - Order side: "buy" or "sell".
#' - `clientOid`: String (optional) - Unique client order ID (max 40 characters, alphanumeric, underscores, or hyphens).
#' - `price`: String (optional) - Order price (required for limit orders).
#' - `size`: String (optional) - Order quantity (required for limit orders, optional for market orders if `funds` not provided).
#' - `funds`: String (optional) - Funds for market orders (optional if `size` provided).
#' - `stp`: Enum<String> (optional) - Self Trade Prevention: "DC", "CO", "CN", "CB".
#' - `stopPrice`: String (required) - Trigger price for the stop order.
#' - `remark`: String (optional) - Order remarks (max 20 characters).
#' - `timeInForce`: Enum<String> (optional) - Time in force: "GTC", "GTT", "IOC", "FOK" (required for limit orders).
#' - `cancelAfter`: Integer<int64> (optional) - Cancel after n seconds (for GTT).
#' - `postOnly`: Boolean (optional) - Post-only flag.
#' - `hidden`: Boolean (optional) - Hidden order flag.
#' - `iceberg`: Boolean (optional) - Iceberg order flag.
#' - `visibleSize`: String (optional) - Visible size for iceberg orders.
#' - `tradeType`: String (optional) - Trade type (default "TRADE").
#'
#' ### Example Request
#' ```bash
#' curl --location --request POST 'https://api.kucoin.com/api/v1/stop-order' \
#' --header 'Content-Type: application/json' \
#' --data-raw '{
#'     "type": "limit",
#'     "symbol": "BTC-USDT",
#'     "side": "buy",
#'     "price": "50000",
#'     "size": "0.00001",
#'     "stopPrice": "49000",
#'     "clientOid": "5c52e11203aa677f33e493fb",
#'     "remark": "order remarks"
#' }'
#' ```
#'
#' ## Response
#' ### HTTP Code: 200
#' - **Content Type**: `application/json`
#'
#' ### Data Schema
#' - `code`: String (required) - Response code ("200000" indicates success).
#' - `data`: Object (required) - Contains:
#'   - `orderId`: String (required) - Unique order ID generated by the system.
#'   - `clientOid`: String (required) - Client-assigned order ID from the request.
#'
#' ### JSON Response Example
#' ```json
#' {
#'   "code": "200000",
#'   "data": {
#'     "orderId": "670fd33bf9406e0007ab3945",
#'     "clientOid": "5c52e11203aa677f33e493fb"
#'   }
#' }
#' ```
#'
#' @param keys List; API configuration parameters from `get_api_keys()`. Defaults to `get_api_keys()`.
#' @param base_url Character string; base URL for the KuCoin API. Defaults to `get_base_url()`.
#' @param type Character string; order type: "limit" or "market". Required.
#' @param symbol Character string; trading pair symbol (e.g., "BTC-USDT"). Required.
#' @param side Character string; order side: "buy" or "sell". Required.
#' @param stopPrice Character string; trigger price for the stop order. Required.
#' @param clientOid Character string; unique client order ID (max 40 characters). Optional.
#' @param price Character string; price for limit orders. Required for limit orders.
#' @param size Character string; quantity for the order. Required for limit orders, optional for market orders.
#' @param funds Character string; funds for market orders. Optional for market orders.
#' @param stp Character string; self-trade prevention: "DC", "CO", "CN", "CB". Optional.
#' @param remark Character string; order remarks (max 20 characters). Optional.
#' @param timeInForce Character string; time in force: "GTC", "GTT", "IOC", "FOK". Optional, defaults to "GTC".
#' @param cancelAfter Integer; cancel after n seconds for GTT. Optional.
#' @param postOnly Logical; post-only flag. Optional, defaults to `FALSE`.
#' @param hidden Logical; hidden order flag. Optional, defaults to `FALSE`.
#' @param iceberg Logical; iceberg order flag. Optional, defaults to `FALSE`.
#' @param visibleSize Character string; visible size for iceberg orders. Optional.
#' @param tradeType Character string; trade type (e.g., "TRADE"). Optional, defaults to "TRADE".
#' @return Promise resolving to a `data.table` with:
#'   - `orderId` (character): Unique order ID generated by the system.
#'   - `clientOid` (character): Client-assigned order ID.
#' @examples
#' \dontrun{
#' library(coro)
#' library(data.table)
#'
#' main_async <- coro::async(function() {
#'   # Place a limit stop order
#'   result <- await(add_stop_order_impl(
#'     type = "limit",
#'     symbol = "BTC-USDT",
#'     side = "buy",
#'     stopPrice = "49000",
#'     price = "50000",
#'     size = "0.00001",
#'     clientOid = "5c52e11203aa677f33e493fb",
#'     remark = "order remarks"
#'   ))
#'   print(result)
#'
#'   # Place a market stop order with size
#'   result <- await(add_stop_order_impl(
#'     type = "market",
#'     symbol = "BTC-USDT",
#'     side = "buy",
#'     stopPrice = "49000",
#'     size = "0.00001",
#'     clientOid = "5c52e11203aa677f33e493fc"
#'   ))
#'   print(result)
#'
#'   # Place a market stop order with funds
#'   result <- await(add_stop_order_impl(
#'     type = "market",
#'     symbol = "BTC-USDT",
#'     side = "buy",
#'     stopPrice = "49000",
#'     funds = "1",
#'     clientOid = "5c52e11203aa677f33e493fd"
#'   ))
#'   print(result)
#' })
#'
#' # Run the async function
#' main_async()
#' while (!later::loop_empty()) later::run_now()
#' }
#' @importFrom coro async await
#' @importFrom data.table data.table
#' @importFrom httr POST timeout content_type_json
#' @importFrom jsonlite toJSON
#' @importFrom rlang abort arg_match0
#' @export
add_stop_order_impl <- coro::async(function(
    keys = get_api_keys(),
    base_url = get_base_url(),
    type,
    symbol,
    side,
    stopPrice,
    clientOid = NULL,
    price = NULL,
    size = NULL,
    funds = NULL,
    stp = NULL,
    remark = NULL,
    timeInForce = NULL,
    cancelAfter = NULL,
    postOnly = NULL,
    hidden = NULL,
    iceberg = NULL,
    visibleSize = NULL,
    tradeType = "TRADE"
) {
    tryCatch({
        # Validate required parameters
        if (is.null(type) || !is.character(type)) {
            rlang::abort("Parameter 'type' must be a non-empty string: 'limit' or 'market'.")
        }
        type <- rlang::arg_match0(type, c("limit", "market"), "type")

        if (is.null(symbol) || !verify_symbol(symbol)) {
            rlang::abort("Parameter 'symbol' must be a valid trading pair (e.g., 'BTC-USDT').")
        }

        if (is.null(side) || !is.character(side)) {
            rlang::abort("Parameter 'side' must be a non-empty string: 'buy' or 'sell'.")
        }
        side <- rlang::arg_match0(side, c("buy", "sell"), "side")

        if (is.null(stopPrice) || !is.character(stopPrice) || nchar(stopPrice) == 0) {
            rlang::abort("Parameter 'stopPrice' must be a non-empty string representing the trigger price.")
        }

        # Type-specific validation
        if (type == "limit") {
            if (is.null(price) || !is.character(price) || nchar(price) == 0) {
                rlang::abort("Parameter 'price' is required for limit orders and must be a non-empty string.")
            }
            if (is.null(size) || !is.character(size) || nchar(size) == 0) {
                rlang::abort("Parameter 'size' is required for limit orders and must be a non-empty string.")
            }
            if (!is.null(funds)) {
                rlang::abort("Parameter 'funds' cannot be specified for limit orders.")
            }
        } else if (type == "market") {
            if (!is.null(price)) {
                rlang::abort("Parameter 'price' cannot be specified for market orders.")
            }
            if (is.null(size) && is.null(funds)) {
                rlang::abort("For market orders, either 'size' or 'funds' must be specified.")
            }
            if (!is.null(size) && !is.null(funds)) {
                rlang::abort("For market orders, 'size' and 'funds' cannot both be specified.")
            }
            if (!is.null(size) && (!is.character(size) || nchar(size) == 0)) {
                rlang::abort("Parameter 'size' must be a non-empty string when provided for market orders.")
            }
            if (!is.null(funds) && (!is.character(funds) || nchar(funds) == 0)) {
                rlang::abort("Parameter 'funds' must be a non-empty string when provided for market orders.")
            }
        }

        # Optional parameter validation
        if (!is.null(clientOid) && (!is.character(clientOid) || nchar(clientOid) > 40)) {
            rlang::abort("Parameter 'clientOid' must be a string with a maximum length of 40 characters.")
        }
        if (!is.null(remark) && (!is.character(remark) || nchar(remark) > 20)) {
            rlang::abort("Parameter 'remark' must be a string with a maximum length of 20 characters.")
        }
        if (!is.null(stp)) {
            stp <- rlang::arg_match0(stp, c("DC", "CO", "CN", "CB"), "stp")
        }
        if (!is.null(timeInForce)) {
            timeInForce <- rlang::arg_match0(timeInForce, c("GTC", "GTT", "IOC", "FOK"), "timeInForce")
        }

        # Construct request body
        body_list <- list(
            type = type,
            symbol = symbol,
            side = side,
            stopPrice = stopPrice,
            tradeType = tradeType
        )
        if (!is.null(clientOid)) body_list$clientOid <- clientOid
        if (!is.null(price)) body_list$price <- price
        if (!is.null(size)) body_list$size <- size
        if (!is.null(funds)) body_list$funds <- funds
        if (!is.null(stp)) body_list$stp <- stp
        if (!is.null(remark)) body_list$remark <- remark
        if (!is.null(timeInForce)) body_list$timeInForce <- timeInForce
        if (!is.null(cancelAfter)) body_list$cancelAfter <- as.integer(cancelAfter)
        if (!is.null(postOnly)) body_list$postOnly <- postOnly
        if (!is.null(hidden)) body_list$hidden <- hidden
        if (!is.null(iceberg)) body_list$iceberg <- iceberg
        if (!is.null(visibleSize)) body_list$visibleSize <- visibleSize

        body_json <- jsonlite::toJSON(body_list, auto_unbox = TRUE)

        # Prepare API request
        endpoint <- "/api/v1/stop-order"
        full_url <- paste0(base_url, endpoint)

        # Generate authentication headers
        headers <- await(build_headers("POST", endpoint, body_json, keys))

        # Send POST request
        response <- httr::POST(
            url = full_url,
            body = body_json,
            headers,
            httr::content_type_json(),
            httr::timeout(3)
        )

        # Process response
        parsed_response <- process_kucoin_response(response, full_url)
        if (parsed_response$code != "200000") {
            rlang::abort(sprintf("API error: %s - %s", parsed_response$code, parsed_response$msg))
        }

        # Return as data.table
        result_dt <- data.table::data.table(
            orderId = parsed_response$data$orderId,
            clientOid = parsed_response$data$clientOid
        )
        return(result_dt)
    }, error = function(e) {
        rlang::abort(sprintf("Error in add_stop_order_impl: %s", conditionMessage(e)))
    })
})
